{
    "mergeSortedArray": {
        "refName": "mergeSortedArray",
        "category": "Array",
        "dificulty": "Easy",
        "title": "Merged Sorted Array",
        "tags": ["Easy", "Array"],
        "description": "<p>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.</p><p>Merge nums1 and nums2 into a single array sorted in non-decreasing order.</p><p>The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.</p>",
        "examples": {
            "example1": {
                "input": "nums1 = [1,2,3,0,0,0];\nm = 3;\nnums2 = [2,5,6];\nn = 3;",
                "output": "[1,2,2,3,5,6]\n//Explanation:\n//The arrays we are merging are [1,2,3] and [2,5,6]"
            },
            "example2": {
                "input": "      5\n    /   |x5C \n  5      5</",
                "output": "[1,2,2,3,5,6]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function mergeSortedArray(nums1, m, nums2, n) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\nfunction mergeSortedArray(nums1, m, nums2, n) {\n    let first = m - 1;\n    let second = n - 1;\n    let i = m + n - 1;\n    while (second >= 0) {\n        let fVal = nums1[first];\n        let sVal = nums2[second];\n        if (fVal > sVal) {\n            nums1[i] = fVal;\n            i--;\n            first--;\n        } else {\n            nums1[i] = sVal;\n            i--;\n            second--;\n        }\n    }\n    return nums1;\n}",
                "// Solution 2\nfunction mergeSortedArray(nums1, m, nums2, n) {\n    let p1 = m - 1;\n    let p2 = n - 1;\n    let p3 = m + n - 1;\n    while (p2 >= 0) {\n      nums1[p3--] = p1 >= 0 && nums1[p1] > nums2[p2] ? nums1[p1--] : nums2[p2--];\n    }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": "function mergeSortedArray(nums1, m, nums2, n) {\n    let first = m - 1;\n    let second = n - 1;\n    let i = m + n - 1;\n    while (second >= 0) {\n        let fVal = nums1[first];\n        let sVal = nums2[second];\n        if (fVal > sVal) {\n            nums1[i] = fVal;\n            i--;\n            first--;\n        } else {\n            nums1[i] = sVal;\n            i--;\n            second--;\n        }\n    }\n    return nums1;\n}"
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3],
                "test_expected": [1, 2, 2, 3, 5, 6],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[1], 1, [], 0],
                "test_expected": [1],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[0], 0, [1], 1],
                "test_expected": [1],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[2, 5, 6], 3, [1, 2, 3, 0, 0, 0], 3],
                "test_expected": [1, 2, 2, 3, 5, 6],
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [[1, 2, 3, 4, 5], 3, [4, 5, 6, 7, 8], 3],
                "test_expected": [1, 2, 3, 4, 5, 6],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "stringRotation": {
        "refName": "stringRotation",
        "category": "String",
        "dificulty": "Easy",
        "title": "String Rotation",
        "tags": ["Easy", "String"],
        "description": "<p>There are three types of edits that can be performed on strings: Assume you have a method isSubstring which checks if one word is a substring of another.</p><p>Given two strings, sl and s2, write code to check if s2 is a rotation of sl using only one call to isSubstring.</p>",
        "examples": {
            "example1": {
                "input": "s1 = 'waterbottle';\ns2 = 'erbottlewat';",
                "output": "true"
            },
            "example2": {
                "input": "s1 = 'teaspoon';\ns2 = 'spoontea';",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function stringRotation(s1, s2) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\nfunction stringRotation(s1, s2) {\n    if (s1.length !== s2.length) return false;\n    const s1s1 = s1 + s1;\n    return s1s1.includes(s2);\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["waterbottle", "erbottlewat"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
              },
              "Test_2": {
                "test_input": ["teaspoon", "poonteas"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
              },
              "Test_3": {
                "test_input": ["miniCar", "Carmini"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
              },
              "Test_4": {
                "test_input": ["houses", "sehou"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
              },
              "Test_5": {
                "test_input": ["power-bank", "bankpower"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
              },
              "Test_6": {
                "test_input": ["Jhony", "JhonY"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
              }
        }
    },
    "uniqueChar": {
        "refName": "uniqueChar",
        "category": "String",
        "dificulty": "Easy",
        "title": "Unique Char",
        "tags": ["Easy", "String"],
        "description": "<p>Given a string, determine if the string has all unique characters.</p><p>What if you cannot use additional data structures?</p>",
        "examples": {
            "example1": {
                "input": "'abcd'",
                "output": "true"
            },
            "example2": {
                "input": "'aabcd'",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function uniqueChar(str) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\nfunction uniqueChar(str) {\n    const list = new Set();\n    for (const letter of str) {\n        if (!list.has(letter)) {\n            list.add(letter);\n        } else {\n            return false\n        }\n    }\n    return true;\n}\n/*\n * IMPORTANT: you cannot use additional data structures!\n * \n * SOLUTION: Compare every character of the string to every other character of \n * the string. This will take 0( n^2) time and 0(1) space.\n */\n/*\n * If we are allowed to modify the input string, we could sort the string in \n * O(n log(n)) time and then linearly check the string for neighboring characters \n * that are identical. Careful, though: many sorting algorithms take up extra space.\n */\nfunction uniqueChar(str) {\n    for (const letter of str) {\n        if (str.indexOf(letter) !== str.lastIndexOf(letter)) {\n            return false;\n        }\n    }\n    return true;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["abcd"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
              },
              "Test_2": {
                "test_input": ["table"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
              },
              "Test_3": {
                "test_input": ["superman"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
              },
              "Test_4": {
                "test_input": ["aaaa"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
              },
              "Test_5": {
                "test_input": ["supermarket"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
              },
              "Test_6": {
                "test_input": ["fgjeW_fug"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
              }
        }
    }
}
