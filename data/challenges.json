{
    "a1": {
        "url": "https://www.gillmeister-software.com/online-tools/text/remove-line-breaks.aspx",
        "refName": "mergeSortedArray",
        "refNumber": 1,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Merged Sorted Array",
        "tags": ["Easy", "Array"],
        "description": "<p>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.</p><p>Merge nums1 and nums2 into a single array sorted in non-decreasing order.</p><p>The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.</p>",
        "examples": {
            "example1": {
                "input": "nums1 = [1,2,3,0,0,0];\nm = 3;\nnums2 = [2,5,6];\nn = 3;",
                "output": "[1,2,2,3,5,6]\n//Explanation:\n//The arrays we are merging are [1,2,3] and [2,5,6]"
            },
            "example2": {
                "input": "      5\n    /   |x5C \n  5      5</",
                "output": "[1,2,2,3,5,6]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function mergeSortedArray(nums1, m, nums2, n) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\nfunction mergeSortedArray(nums1, m, nums2, n) {\n    let first = m - 1;\n    let second = n - 1;\n    let i = m + n - 1;\n    while (second >= 0) {\n        let fVal = nums1[first];\n        let sVal = nums2[second];\n        if (fVal > sVal) {\n            nums1[i] = fVal;\n            i--;\n            first--;\n        } else {\n            nums1[i] = sVal;\n            i--;\n            second--;\n        }\n    }\n    return nums1;\n}",
                "// Solution 2\nfunction mergeSortedArray(nums1, m, nums2, n) {\n    let p1 = m - 1;\n    let p2 = n - 1;\n    let p3 = m + n - 1;\n    while (p2 >= 0) {\n      nums1[p3--] = p1 >= 0 && nums1[p1] > nums2[p2] ? nums1[p1--] : nums2[p2--];\n    }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": "function mergeSortedArray(nums1, m, nums2, n) {\n    let first = m - 1;\n    let second = n - 1;\n    let i = m + n - 1;\n    while (second >= 0) {\n        let fVal = nums1[first];\n        let sVal = nums2[second];\n        if (fVal > sVal) {\n            nums1[i] = fVal;\n            i--;\n            first--;\n        } else {\n            nums1[i] = sVal;\n            i--;\n            second--;\n        }\n    }\n    return nums1;\n}"
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3],
                "test_expected": [1, 2, 2, 3, 5, 6],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[1], 1, [], 0],
                "test_expected": [1],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[0], 0, [1], 1],
                "test_expected": [1],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[2, 5, 6], 3, [1, 2, 3, 0, 0, 0], 3],
                "test_expected": [1, 2, 2, 3, 5, 6],
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [[1, 2, 3, 4, 5], 3, [4, 5, 6, 7, 8], 3],
                "test_expected": [1, 2, 3, 4, 5, 6],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "aaa": {
        "url": "https://www.gillmeister-software.com/online-tools/text/remove-line-breaks.aspx",
        "refName": "mergeSortedArray",
        "refNumber": 2,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Merged Sorted Array",
        "tags": ["Easy", "Array"],
        "description": "<p>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.</p><p>Merge nums1 and nums2 into a single array sorted in non-decreasing order.</p><p>The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.</p>",
        "examples": {
            "example1": {
                "input": "nums1 = [1,2,3,0,0,0];\nm = 3;\nnums2 = [2,5,6];\nn = 3;",
                "output": "[1,2,2,3,5,6]\n//Explanation:\n//The arrays we are merging are [1,2,3] and [2,5,6]"
            },
            "example2": {
                "input": "      5\n    /   |x5C \n  5      5</",
                "output": "[1,2,2,3,5,6]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function mergeSortedArray(nums1, m, nums2, n) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\nfunction mergeSortedArray(nums1, m, nums2, n) {\n    let first = m - 1;\n    let second = n - 1;\n    let i = m + n - 1;\n    while (second >= 0) {\n        let fVal = nums1[first];\n        let sVal = nums2[second];\n        if (fVal > sVal) {\n            nums1[i] = fVal;\n            i--;\n            first--;\n        } else {\n            nums1[i] = sVal;\n            i--;\n            second--;\n        }\n    }\n    return nums1;\n}",
                "// Solution 2\nfunction mergeSortedArray(nums1, m, nums2, n) {\n    let p1 = m - 1;\n    let p2 = n - 1;\n    let p3 = m + n - 1;\n    while (p2 >= 0) {\n      nums1[p3--] = p1 >= 0 && nums1[p1] > nums2[p2] ? nums1[p1--] : nums2[p2--];\n    }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": "function mergeSortedArray(nums1, m, nums2, n) {\n    let first = m - 1;\n    let second = n - 1;\n    let i = m + n - 1;\n    while (second >= 0) {\n        let fVal = nums1[first];\n        let sVal = nums2[second];\n        if (fVal > sVal) {\n            nums1[i] = fVal;\n            i--;\n            first--;\n        } else {\n            nums1[i] = sVal;\n            i--;\n            second--;\n        }\n    }\n    return nums1;\n}"
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3],
                "test_expected": [1, 2, 2, 3, 5, 6],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[1], 1, [], 0],
                "test_expected": [1],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[0], 0, [1], 1],
                "test_expected": [1],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[2, 5, 6], 3, [1, 2, 3, 0, 0, 0], 3],
                "test_expected": [1, 2, 2, 3, 5, 6],
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [[1, 2, 3, 4, 5], 3, [4, 5, 6, 7, 8], 3],
                "test_expected": [1, 2, 3, 4, 5, 6],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "stringRotation": {
        "refName": "stringRotation",
        "refNumber": 3,
        "category": "String",
        "difficulty": "Easy",
        "title": "String Rotation",
        "tags": ["Easy", "String"],
        "isChallengeSubmitted": true,
        "description": "<p>There are three types of edits that can be performed on strings: Assume you have a method isSubstring which checks if one word is a substring of another.</p><p>Given two strings, sl and s2, write code to check if s2 is a rotation of sl using only one call to isSubstring.</p>",
        "examples": {
            "example1": {
                "input": "s1 = 'waterbottle';\ns2 = 'erbottlewat';",
                "output": "true"
            },
            "example2": {
                "input": "s1 = 'teaspoon';\ns2 = 'spoontea';",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function stringRotation(s1, s2) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\n// Time: O(n)\n// Space: O(n)\nfunction stringRotation(s1, s2) {\n   for (let i = 0; i < s1.length; i++) {\n      if (s1.slice(i) + s1.slice(0, i) === s2) return true;\n   }\n   return false;\n}\n// Solution 2\n// Time: O(n)\n// Space: O(n)\nfunction stringRotation(s1, s2) {\n   if (s1.length !== s2.length) return false;\n   const s1s1 = s1 + s1;\n   return s1s1.includes(s2);\n}"
            ]
        },
        "submittedCode": {
            "javaScript": "a"
        },
        "testCases": {
            "Test_1": {
                "test_input": ["waterbottle", "erbottlewat"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["teaspoon", "poonteas"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["miniCar", "Carmini"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["houses", "sehou"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["power-bank", "bankpower"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["Jhony", "JhonY"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "uniqueChar": {
        "refName": "uniqueChar",
        "refNumber": 4,
        "category": "String",
        "difficulty": "Easy",
        "title": "Unique Char",
        "tags": ["Easy", "String"],
        "description": "<p>Given a string, determine if the string has all unique characters.</p><p>What if you cannot use additional data structures?</p>",
        "examples": {
            "example1": {
                "input": "'abcd'",
                "output": "true"
            },
            "example2": {
                "input": "'aabcd'",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function uniqueChar(str) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "//SOLUTION 1 useing additional data structures\nfunction uniqueChar(str) {\n   const uniques = new Set();\n   for (const char of str) {\n      if (uniques.has(char)) return false;\n      uniques.add(char);\n   }\n   return true;\n}\n/*\n * IMPORTANT: you cannot use additional data structures!\n*/\n \n// SOLUTION 1: \n// Compare every character of the string to every other character \n// of the string. This will take 0( n^2) time and 0(1) space.\nfunction uniqueChar(str) {\n   for (const letter of str) {\n      if (str.indexOf(letter) !== str.lastIndexOf(letter)) {\n         return false;\n      }\n   }\n   return true;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["abcd"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["table"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["superman"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["aaaa"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["supermarket"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["fgjeW_fug"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "checkPermutation": {
        "refName": "checkPermutation",
        "refNumber": 5,
        "category": "String",
        "difficulty": "Easy",
        "title": "Check Permutation",
        "tags": ["Easy", "String"],
        "description": "<p>Write a function to check whether two given strings are Permutation of each other or not.</p><p>A Permutation of a string is another string that contains same characters, only the order of characters can be different.</p>",
        "examples": {
            "example1": {
                "input": "str1 = 'abcd';\nstr2 = 'dabc';",
                "output": "true"
            },
            "example2": {
                "input": "str1 = 'abcd';\nstr2 = 'mfd';",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function checkPermutation(str1, str2) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\n/*\n * N = str1, M = str2\n * Time: O(N + M)\n * Additional space: O(N)\n */\nfunction checkPermutation(str1, str2) {\n  if (str1.length !== str2.length) return false;\n  const list = new Map();\n  for (const letter of str1) {\n    if (list.has(letter)) {\n      const val = list.get(letter);\n      list.set(letter, val + 1);\n    } else {\n      list.set(letter, 1);\n    }\n  }\n  for (const letter of str2) {\n    if (list.has(letter)) {\n      let val = list.get(letter);\n      list.set(letter, val - 1);\n      val = list.get(letter);\n      if (val === 0) list.delete(letter);\n    } else {\n      return false;\n    }\n  }\n  return list.size === 0;\n}\n/**\n * Sort both strings and check if they are equal afterwards. Permutations will\n * be identical sorted strings.\n *\n * N = |str1| && M = |str2|\n * Time: O(N lg N + M lg M)\n * Additional space: O(1) if able to modify original strings, O(N + M) otherwise\n */\nfunction isPermutationSorted(str1, str2) {\n  if (str1.length === 0 || str1.length !== str2.length) {\n    return false;\n  }\n  const arr1 = str1.split('');\n  const arr2 = str2.split('');\n  arr1.sort();\n  arr2.sort();\n  return arr1.every((v, i) => v === arr2[i]);\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["abcd", "dabc"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["ABC", "BAC"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["hfWmdVpqcd", "mdVpqchfWd"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["abc", "adeg"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["opKrs", "abCd"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["aabb", "abcd"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "palindromePermutation": {
        "refName": "palindromePermutation",
        "refNumber": 6,
        "category": "String",
        "difficulty": "Easy",
        "title": "Palindrome Permutation",
        "tags": ["Easy", "String"],
        "description": "<p>Write a function that checks whether any permutation of a string is a palindrome. The palindrome does not need to be limited to just dictionary words.</p><p>A palindrome is a word or phrase that is the same forwards and backwards.</p><p>A permutation is a rearrangement of letters.</p>",
        "examples": {
            "example1": {
                "input": "str1 = 'redivider';",
                "output": "true"
            },
            "example2": {
                "input": "str1 = 'house'",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function palindromePermutation(str) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\nfunction palindromePermutation(str) {\n    let p1 = 0;\n    let p2 = str.length - 1;\n    while (p1 <= p2) {\n        if (str[p1] !== str[p2]) return false;\n        p1++;\n        p2--;\n    }\n    return true;\n}\n// Solution 2\nfunction palindromePermutation(str) {\n    for (let i = 0; i < str.length / 2; i++) {\n        if (str[i] !== str[str.length - 1 - i]) return false;\n    }   \n    return true;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["redivider"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["deified"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["_reviver_"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["kayak"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["fhe4"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["A_fgp"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": ["deified."],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": ["a_ia"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "oneWay": {
        "refName": "oneWay",
        "refNumber": 7,
        "category": "String",
        "difficulty": "Easy",
        "title": "One Way",
        "tags": ["Easy", "String"],
        "description": "<p>There are three types of edits that can be performed on strings:</p>\n<ul>\n  <li>insert a character.</li>\n  <li>remove a character.</li>\n  <li>replace a character.</li>\n</ul>\n<p>Given two strings, write a function to check if they are one edit (or zero edits) away.</p>",
        "examples": {
            "example1": {
                "input": "str1 = 'geeks;\nstr2 = 'geek';",
                "output": "true"
            },
            "example2": {
                "input": "str1 = 'peaks';\nstr2 = 'geeks';",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function oneWay(str1, str2) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\nfunction oneWay(str1, str2) {\n    const diff = Math.abs(str1.length - str2.length);\n    const maxLength = Math.max(str1.length, str2.length);\n    if (diff > 1) return false;\n    let isEdited = 0;\n    for (let p1 = 0, p2 = 0; p1 < maxLength || p2 < maxLength; p1++, p2++) {\n        if (str1[p1] !== str2[p2]) {\n            isEdited++;\n            if (isEdited > 1) return false;\n            if(str1[p1] === str2[p2 + 1]) p2++;\n            if (str1[p1 + 1] === str2[p2]) p1++;\n        }\n    }\n    return true;\n}\n// Solution 2\nfunction oneWay(str1, str2) {\n    const diff = Math.abs(str1.length - str2.length);\n    const maxLength = Math.max(str1.length, str2.length);\n    if (diff > 1) return false;\n    let p1 = 0;\n    let p2 = 0;\n    let isEdited = 0;\n    while (p1 < maxLength || p2 < maxLength) {\n        if (str1[p1] !== str2[p2]) {\n            isEdited++;\n            if (isEdited > 1) return false;\n            if(str1[p1] === str2[p2 + 1]) p2++;\n            if (str1[p1 + 1] === str2[p2]) p1++;\n        }\n        p1++;\n        p2++;\n    }\n    return true;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["geeks", "geek"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["book", "books"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["demon", "dem"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["discovery", "discovery"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["Moon", "Moonlight"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "stringCompression": {
        "refName": "stringCompression",
        "refNumber": 8,
        "category": "String",
        "difficulty": "Easy",
        "title": "String Compression",
        "tags": ["Easy", "String"],
        "description": "<p>Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabcccccaaa would become a2blc5a3.</p><p>If the 'compressed' string would not become smaller than the original string, your method should return the original string. You can assume the string has only uppercase and lowercase letters (a - z).</p>",
        "examples": {
            "example1": {
                "input": "str1 = 'mdddoppppmmmm';",
                "output": "'m1d2d1o1p1m4'"
            },
            "example2": {
                "input": "str1 = 'abcd'",
                "output": "'abcd'"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function stringCompression(str) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of string\n// Time: O(n)\n// Space: O(n)\nfunction stringCompression(str) {\n    let counter = 1;\n    const result = [];\n    for (let p2=0; p2<str.length; p2++) {\n        if (str[p2] === str[p2+1]) {\n            counter++;\n        }else {\n            result.push(str[p2] + counter);\n            counter = 1;\n        }\n    }\n    return result.join('').length > str.length ? str : result.join('');\n}\n// n = length of string\n// Time: O(n)\n// Space: O(n)\nfunction stringCompression(str) {\n    const result = [];\n    let p1 = 0;\n    let p2 = 0;\n    while(p1<= str.length){\n        if (str[p1] === str[p2]) {\n            p1++;\n        } else {\n            const num = p1 - p2;\n            result.push(str[p2] + num);\n            p2=p1;\n        }\n    }\n    return result.join('').length > str.length ? str : result.join('');\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["mdddoppppmmmm"],
                "test_expected": "m1d3o1p4m4",
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["aabcccccaaa"],
                "test_expected": "a2b1c5a3",
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["abcd"],
                "test_expected": "abcd",
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["doopwwwwwvvvvvvvmsssssssdkjkzzzpp"],
                "test_expected": "d1o2p1w5v7m1s7d1k1j1k1z3p2",
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["cbdklwysmdsh"],
                "test_expected": "cbdklwysmdsh",
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["abcdefghijklmnopqrst"],
                "test_expected": "abcdefghijklmnopqrst",
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "numJewelsInStones": {
        "refName": "numJewelsInStones",
        "refNumber": 9,
        "category": "String",
        "difficulty": "Easy",
        "title": "Num Jewels In Stones",
        "tags": ["Easy", "String"],
        "description": "<p>You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.</p><p>Letters are case sensitive, so 'a' is considered a different type of stone from 'A'.</p>",
        "examples": {
            "example1": {
                "input": "jewels = 'aA';\nstones = 'aAAbbbb';",
                "output": "3"
            },
            "example2": {
                "input": "jewels = 'z';\nstones = 'ZZ';",
                "output": "0"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function numJewelsInStones(J, S) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// solution 1\nfunction numJewelsInStones(J, S) {\n   let result = 0;\n   for (let char of S) {\n       if (J.includes(char)) result++;\n   }\n    \n    return result;\n}\n// solution 2\nfunction numJewelsInStones(J, S) {\n   let result = 0;\n   const list = new Set();\n   for (let char of J) {\n       list.add(char);\n   }\n   for (let char of S) {\n       if (list.has(char)) result++;\n   }\n    \n    return result;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["aA", "aAAbbbb"],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["z", "ZZ"],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "maximumBalancedStringPartitions": {
        "refName": "maximumBalancedStringPartitions",
        "refNumber": 10,
        "category": "String",
        "difficulty": "Easy",
        "title": "Maximum Balanced String Partitions",
        "tags": ["Easy", "String"],
        "description": "<p>Given a balanced string str of size N with an equal number of L and R, the task is to find a maximum number X, such that a given string can be partitioned into X balanced substring. A string called to be balanced if the number of ‘L’s in the string equals the number of ‘R’s.</p>",
        "examples": {
            "example1": {
                "input": "str = 'LRLLRRLRRL';",
                "output": "4 // { 'LR', 'LLRR', 'LR', 'RL'} are the possible partitions."
            },
            "example2": {
                "input": "'LRRRRLLRLLRL'",
                "output": "3 //{'LR', 'RRRLLRLL', “RL”} are the possible partitions."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function maximumBalancedStringPartitions(str, n) {\n// Write your solution...\nreturn true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// solution 1\nfunction maximumBalancedStringPartitions(str) {\nlet L = 0;\nlet R = 0;\nlet LBlock = false;\nlet RBlock = false;\nlet result = 0;\nfor (let char of str) {\nif (char === 'L') {\nif (LBlock) {\nL++;\n} else {\nL = 1;\nLBlock = true;\nRBlock = false;\n}\n}\nif (char === 'R') {\nif (RBlock) {\nR++;\n} else {\nR = 1;\nLBlock = false;\nRBlock = true;\n}\n}\nif (R === L) {\nresult++;\nR = 0;\nL = 0;\n}\n}\nreturn result;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["LRLLRRLRRL", 10],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["LRRRRLLRLLRL", 12],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["LLLLRLLRRLRLLLRRRLLLRRLLLLRRLLRRLR", 12],
                "test_expected": 9,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "shuffleString": {
        "refName": "shuffleString",
        "refNumber": 11,
        "category": "String",
        "difficulty": "Easy",
        "title": "Shuffle String",
        "tags": ["Easy", "String"],
        "description": "<p>You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.</p>",
        "examples": {
            "example1": {
                "input": "s = 'codeleet';\nindices = [4,5,6,7,0,2,1,3];",
                "output": "'leetcode'"
            },
            "example2": {
                "input": "s = 'abc';\nindices = [0,1,2];",
                "output": "'abc"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function shuffleString(s, indices) {\n// Write your solution...\nreturn true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// solution 1\nfunction shuffleString(s, indices) {\nconst result = new Array(s.length).fill(0);\nfor (let i = 0; i < s.length; i++) {\nresult[indices[i]] = s[i];\n}\nreturn result.join('');\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["codeleet", [4, 5, 6, 7, 0, 2, 1, 3]],
                "test_expected": "leetcode",
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["abc", [0, 1, 2]],
                "test_expected": "abc",
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "toLowerCase": {
        "refName": "toLowerCase",
        "refNumber": 12,
        "category": "String",
        "difficulty": "Easy",
        "title": "To LowerCase",
        "tags": ["Easy", "String"],
        "description": "<p>Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.</p>",
        "examples": {
            "example1": {
                "input": "'HELLO",
                "output": "'hello'"
            },
            "example2": {
                "input": "'LOVELY'",
                "output": "'lovely'"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function toLowerCase(s) {\n// Write your solution...\nreturn true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// solution 1\nfunction toLowerCase(s) {\nlet ans = ''\nfor (let c of s) {\nlet n = c.charCodeAt()\nans += n > 64 && n < 91 ? String.fromCharCode(n + 32) : c\n}\nreturn ans\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["Hello"],
                "test_expected": "hello",
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["here"],
                "test_expected": "here",
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["LOVELY"],
                "test_expected": "lovely",
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "uniqueMorseWords": {
        "refName": "uniqueMorseWords",
        "refNumber": 13,
        "category": "String",
        "difficulty": "Easy",
        "title": "Unique Morse Words",
        "tags": ["Easy", "String"],
        "description": "<p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:</p>\n<p>'a' maps to '.-', 'b' maps to '-...', 'c' maps to '-.-.', and so on.</p>\n<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>\n<p>['.-','-...','-.-.','-..','.','..-.','--.','....','..','.---','-.-','.-..','--','-.','---','.--.','--.-','.-.','...','-','..-','...-','.--','-..-','-.--','--..']</p>\n<p>Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter. For example, 'cab' can be written as '-.-..--...', which is the concatenation of '-.-.', '.-', and '-...'. We will call such a concatenation the transformation of a word.</p>\n<p>Return the number of different transformations among all words we have. Constraints:</p>\n<ul>\n<li>\nThe length of words will be at most 100.\n</li>\n<li>\nEach words[i] will have length in range [1, 12].\n</li>\n<li>\nwords[i] will only consist of lowercase letters.\n</li>\n</ul>",
        "examples": {
            "example1": {
                "input": "words = ['gin', 'zen', 'gig', 'msg']",
                "output": "2\n// gin -> '--...-.'\nzen -> '--...-.'\ngig -> '--...--.''\nmsg' -> '--...--.'"
            },
            "example2": {
                "input": "words = ['a']",
                "output": "1"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function uniqueMorseWords(words) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\nfunction uniqueMorseWords(words) {\n   const alphapet = 'abcdefghijklmnopqrstuvwxyz';\n   const morseCodes = ['.-', '-...', '-.-.', '-..', '.', '..-.', '--.', '....', '..', '.---', '-.-', '.-..', '--', '-.', '---', '.--.', '--.-', '.-.', '...', '-', '..-', '...-', '.--', '-..-', '-.--', '--..'];\n   const morseLetters = new Map(morseCodes.map((code, index) => [alphapet[index], code]));\n   const transformations = new Set();\n   words.forEach((w) => {\n      const morseWord = w.split('').map(l => morseLetters.get(l)).join('');\n      transformations.add(morseWord);\n   });\n   return transformations.size;\n}\n// solution 2\nfunction uniqueMorseWords(words) {\nconst morseCodes = ['.-', '-...', '-.-.', '-..', '.', '..-.', '--.', '....', '..', '.---', '-.-', '.-..', '--', '-.', '---', '.--.', '--.-', '.-.', '...', '-', '..-', '...-', '.--', '-..-', '-.--', '--..'];\nlet morseWords = [];\nlet word;\nfor (let i = 0; i < words.length; i++) {\nword = words[i].split('').map((c) => morseCodes[c.charCodeAt(0) - 97]).join('');\nif (morseWords.indexOf(word) === -1) {\nmorseWords.push(word);\n}\n}\nreturn morseWords.length;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [["zocd", "gjkl", "hzqk", "hzgq", "gjkl"]],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [["yxmine", "yxzd", "eljys", "uiaopi", "pwlk"]],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [["gin", "zen", "gig", "msg"]],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [["a"]],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "robotReturnToOrigin": {
        "refName": "robotReturnToOrigin",
        "refNumber": 14,
        "category": "String",
        "difficulty": "Easy",
        "title": "Robot Return To Origin",
        "tags": ["Easy", "String"],
        "description": "<p>There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.</p><p>You are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are 'R' (right), 'L' (left), 'U' (up), and 'D' (down). Return true if the robot returns to the origin after it finishes all of its moves, or false otherwise.</p><p>Note: The way that the robot is 'facing' is irrelevant. 'R' will always make the robot move to the right once, 'L' will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.</p><p>Constraints:</p><p>1 <= moves.length <= 2 * 104 moves only contains the characters 'U', 'D', 'L' and 'R'.</p>",
        "examples": {
            "example1": {
                "input": "moves = 'UD'",
                "output": "true\n// Explanation:The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true."
            },
            "example2": {
                "input": "moves = 'LL'",
                "output": "false\nExplanation: The robot moves left twice. It ends up two 'moves' to the left of the origin. We return false because it is not at the origin at the end of its moves."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function robotReturnToOrigin(moves) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// solution 1\nfunction robotReturnToOrigin(moves) {\n    let x = 0, y = 0;\n    for (let move of moves) {\n        if (move == 'U') y -= 1\n        if (move == 'D') y += 1\n        if (move == 'L') x -= 1\n        if (move == 'R') x += 1\n    }\n    return x == 0 && y == 0;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["UD"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["LL"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "reverseString": {
        "refName": "reverseString",
        "refNumber": 15,
        "category": "String",
        "difficulty": "Easy",
        "title": "Reverse String",
        "tags": ["Easy", "String"],
        "description": "<p>Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory.</p>",
        "examples": {
            "example1": {
                "input": "str = ['h','e','l','l','o']",
                "output": "['o','l','l','e','h']"
            },
            "example2": {
                "input": "str = ['H','a','n','n','a','h']",
                "output": "['h','a','n','n','a','H']"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function reverseString(s) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// solution 1\nfunction reverseString(s) {\n    for (let i = 0; i < s.length/2; i++) {\n        let n = s[i]\n        s[i] = s[s.length-i-1]\n        s[s.length-i-1] = n\n    }\n    return s\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [["h", "e", "l", "l", "o"]],
                "test_expected": ["o", "l", "l", "e", "h"],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [["H", "a", "n", "n", "a", "h"]],
                "test_expected": ["h", "a", "n", "n", "a", "H"],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "implementStrStr": {
        "refName": "implementStrStr",
        "refNumber": 16,
        "category": "String",
        "difficulty": "Easy",
        "title": "Implement StrStr",
        "tags": ["Easy", "String"],
        "description": "<p>Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><p><b>Clarification:</b></p><p>What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().</p>",
        "examples": {
            "example1": {
                "input": "haystack = 'hello'\nneedle = 'll'",
                "output": "2"
            },
            "example2": {
                "input": "haystack = 'aaaaa', needle = 'bba'",
                "output": "-1"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function implementStrStr(haystack, needle)  {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// solution 1\nfunction implementStrStr(haystack, needle) {\n    if (needle.length === 0) return 0;\n    if (needle === haystack) return 0;\n    for (let i = 0; i <= haystack.length - needle.length; i++) {\n        if (needle === haystack.substring(i, i + needle.length)) {\n            return i;\n        }\n    }\n    return -1;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["hello", "ll"],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["aaaaa", "bba"],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["", ""],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "validParentheses": {
        "refName": "validParentheses",
        "refNumber": 17,
        "category": "String",
        "difficulty": "Easy",
        "title": "Valid Parentheses",
        "tags": ["Easy", "String"],
        "description": "<p>Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.</p><p>Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.</p>",
        "examples": {
            "example1": {
                "input": "s = '()'",
                "output": "true"
            },
            "example2": {
                "input": "s = '(]'",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function validParentheses(s) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// solution 1\nfunction validParentheses(s) {\n    const stack = [];\n    const characters = { ')': '(', '}': '{', ']': '[' };\n    for (const char of s) {\n        if (!characters[char]) stack.push(char);\n        else if (stack.pop() !== characters[char]) {\n            return false;\n        }\n    }\n    return stack.length === 0;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["()"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["()[]{}"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["(]"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "romanToInteger": {
        "refName": "romanToInteger",
        "refNumber": 18,
        "category": "String",
        "difficulty": "Easy",
        "title": "Roman To Integer",
        "tags": ["Easy", "String"],
        "description": "<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000</p><p>For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9.</li><li>X can be placed before L (50) and C (100) to make 40 and 90.</li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul><p>Given a roman numeral, convert it to an integer.</p><p>Constraints:</p><p>1 <= s.length <= 15 s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M'). It is guaranteed that s is a valid roman numeral in the range [1, 3999].</p>",
        "examples": {
            "example1": {
                "input": "III",
                "output": "3"
            },
            "example2": {
                "input": "LVIII",
                "output": "58"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function romanToInteger(s) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// solution 1\nfunction romanToInteger(s) {\n    const sym = { \n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    let result = 0;\n    for (i=0; i < s.length; i++){\n        const cur = sym[s[i]];\n        const next = sym[s[i+1]];\n        if (cur < next){\n            result += next - cur // IV -> 5 - 1 = 4\n            i++\n        } else {\n            result += cur\n        }\n    }\n    return result; \n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["III"],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["LVIII"],
                "test_expected": 58,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["MCMXCIV"],
                "test_expected": 1994,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["IV"],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "longestWord": {
        "refName": "longestWord",
        "refNumber": 19,
        "category": "String",
        "difficulty": "Easy",
        "title": "Longest Word",
        "tags": ["Easy", "String"],
        "description": "<p>Find the Longest Word in a String Return the length of the longest word in the provided sentence. Your response should be a number.</p>",
        "examples": {
            "example1": {
                "input": "str = 'This is an example';",
                "output": "'example'"
            },
            "example2": {
                "input": "str = 'the longest word';",
                "output": "'longest'"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function longestWord(str) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// EXAMPLE 1 BAD\nfunction longestWord(str) {\n  return str.split(' ').reduce((c, v) => (c.length > v.length ? c : v)).length;\n}\n// EXAMPLE 2 BAD\nfunction longestWord(str) {\n  return str.split(' ').sort((a, b) => b.length - a.length)[0].length;\n}\n// EXAMPLE 3\nfunction longestWord(str) {\n   let result = '';\n   let currWord = '';\n   for (const char of str) {\n      if (char === ' ') {\n         currWord = '';\n      } else {\n         currWord += char;\n         result = result.length > currWord.length ? result : currWord;\n      }\n   }\n   return result;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["this is an example"],
                "test_expected": "example",
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["an apple"],
                "test_expected": "apple",
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["Tokyo is widely considered the world's largest city"],
                "test_expected": "considered",
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "lengthOfLongestSubString": {
        "refName": "lengthOfLongestSubString",
        "refNumber": 20,
        "category": "String",
        "difficulty": "Medium",
        "title": "length Of Longest SubString",
        "tags": ["Medium", "String"],
        "description": "<p>Given a string s, find the length of the longest substring without repeating characters.</p>",
        "examples": {
            "example1": {
                "input": "str = 'abcabcbb';",
                "output": "3\nExplanation: The answer is 'abc', with the length of 3."
            },
            "example2": {
                "input": "str = 'bbbbb';",
                "output": "1\nExplanation: The answer is 'b', with the length of 1."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function lengthOfLongestSubString(str) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// O(n) time | O(min(n, a)) space\nfunction lengthOfLongestSubString(string) {\n    const lastSeen = {};\n    let longest = [0, 1];\n    let startIdx = 0;\n    for (let i = 0; i < string.length; i++) {\n        const char = string[i];\n        if (char in lastSeen) {\n            startIdx = Math.max(startIdx, lastSeen[char] + 1);\n        }\n        if (longest[1] - longest[0] < i + 1 - startIdx) {\n            longest = [startIdx, i + 1];\n        }\n        lastSeen[char] = i;\n    }\n    return string.slice(longest[0], longest[1]);\n}",
                "// O(n) time | O(n) space\nfunction lengthOfLongestSubString(str) {\n    let maxLength = 0,\n        windowStart = 0,\n        charIndexMap = {}\n    for (let windowEnd = 0; windowEnd < str.length; windowEnd++) {\n        const rightChar = str[windowEnd]\n        if (rightChar in charIndexMap) {\n            windowStart = Math.max(windowStart, charIndexMap[rightChar] + 1)\n        }\n        charIndexMap[rightChar] = windowEnd\n        maxLength = Math.max(maxLength, windowEnd - windowStart + 1)\n    }\n    return maxLength\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["abcabcbb"],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["bbbbb"],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["pwwkew"],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [""],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "longestPalindromicSubstring": {
        "refName": "longestPalindromicSubstring",
        "refNumber": 21,
        "category": "String",
        "difficulty": "Medium",
        "title": "Longest Palindromic Substring",
        "tags": ["Medium", "String"],
        "description": "<p>Given a string s, return the longest palindromic substring in s.</p><p>Constraints</p><ul><li>1 <= s.length <= 1000</li><li>s consist of only digits and English letters (lower-case and/or upper-case).</li></ul>",
        "examples": {
            "example1": {
                "input": "str = 'babad';",
                "output": "'bab'\n// 'aba' is also a valid answer."
            },
            "example2": {
                "input": "str = 'cbbd';",
                "output": "'bb'"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function longestPalindromicSubstring(string) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Manacher's Algorithm\n// Time complexity O(n)\n// Space complexity O(n)\nfunction longestPalindromicSubstring(s) {\n    let updatedString = '#' + s.split('').join('#') + '#';\n    const length = 2 * s.length + 1; // Length of the array that will store the window of palindromic substring\n    let p = new Array(length).fill(0); // Array to store the length of each palindrome centered at each element\n    let center = 0; // Current center of the longest palindromic string\n    let right = 0; // Right boundary of the longest palindromic string\n    let maxLength = 0; // Maximum length of the substring\n    let position = -1; // Position index\n    for (let i = 0; i < length; i++) {\n        let mirror = 2 * center - i; // Mirror of the current index\n        if (i < right) p[i] = Math.min(right - i, p[mirror]); // Check if the mirror is outside the left boundary of current longest palindrome\n        // Indices of the characters to be compared\n        let a = i + (1 + p[i]);\n        let b = i - (1 + p[i]);\n        // Expand the window\n        while (a < length && b >= 0 && updatedString[a] === updatedString[b]) {\n            p[i]++;\n            a++;\n            b--;\n        }\n        // If the expanded palindrome is expanding beyond the right boundary of\n        // the current longest palindrome, then update c and r\n        if (i + p[i] > right) {\n            center = i;\n            right = i + p[i];\n        }\n        if (maxLength < p[i]) {\n            maxLength = p[i];\n            position = i;\n        }\n    }\n    return s.substring((position - maxLength) / 2, (position + maxLength) / 2);\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["book"],
                "test_expected": "oo",
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["cbbd"],
                "test_expected": "bb",
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["a"],
                "test_expected": "a",
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["forgeeksskeegfor"],
                "test_expected": "geeksskeeg",
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["bananas"],
                "test_expected": "anana",
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "stringToInteger": {
        "refName": "stringToInteger",
        "refNumber": 22,
        "category": "String",
        "difficulty": "Medium",
        "title": "String To Integer",
        "tags": ["Medium", "String"],
        "description": "<p>Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function). The algorithm for myAtoi(string s) is as follows:</p><ul><li>Read in and ignore any leading whitespace.</li><li>Check if the next character (if not already at the end of the string) is '-' or '+'.</li><li>Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.</li><li>Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.</li><li>Convert these digits into an integer (i.e. '123' -> 123, '0032' -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).</li><li>If the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.</li><li>Return the integer as the final result.</li></ul><p>Note:</p><ul><li>Only the space character ' ' is considered a whitespace character.</li><li>Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.</li></ul>",
        "examples": {
            "example1": {
                "input": "str = 42;",
                "output": "42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: '42' (no characters read because there is no leading whitespace).\nStep 2: '42' (no characters read because there is neither a '-' nor '+')\nStep 3: '42' ('42' is read in)\nThe parsed integer is 42. Since 42 is in the range [-231, 231 - 1], the final result is 42."
            },
            "example2": {
                "input": "str = '4193 with words';",
                "output": "4193\nExplanation: Conversion stops at digit '3' as the next character is not a numerical digit."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function stringToInteger(str) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time complexity : O(n).\n// Space complexity : O(1).\nfunction stringToInteger(str) {\n    var i = 0;\n    var sign = 1;\n    var res = 0;\n    var len = str.length;\n    var INT_MAX = 2147483647;\n    var INT_MIN = - INT_MAX - 1;\n    while (str[i] === ' ') i++;\n    if (str[i] === '+' || str[i] === '-') {\n        sign = str[i] === '+' ? 1 : -1;\n        i++;\n    }\n    while (str[i] >= '0' && str[i] <= '9') {\n        res = (res * 10) + (str[i] - 0);\n        if (sign === 1 && res > INT_MAX) return INT_MAX;\n        if (sign === -1 && res > INT_MAX + 1) return INT_MIN;\n        i++;\n    }\n    return res * sign;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["42"],
                "test_expected": 42,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["   -42"],
                "test_expected": -42,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["4193 with words"],
                "test_expected": 4193,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["words and 987"],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["-91283472332"],
                "test_expected": -2147483648,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "letterCombinations": {
        "refName": "letterCombinations",
        "refNumber": 23,
        "category": "String",
        "difficulty": "Medium",
        "title": "Letter Combinations",
        "tags": ["Medium", "String"],
        "description": "<p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p>Constraints:</p><ul><li>0 <= digits.length <= 4</li><li>digits[i] is a digit in the range ['2', '9'].</li</ul>",
        "examples": {
            "example1": {
                "input": "str = '23';",
                "output": "['ad','ae','af','bd','be','bf','cd','ce','cf']"
            },
            "example2": {
                "input": "str = '2';",
                "output": "['a','b','c']"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function letterCombinations(D) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "const L = {\n    '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n    '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n}\nfunction letterCombinations(D) {\n    let len = D.length, ans = []\n    if (!len) return []\n    const bfs = (pos, str) => {\n        if (pos === len) ans.push(str)\n        else {\n            let letters = L[D[pos]]\n            for (let i = 0; i < letters.length; i++)\n                bfs(pos + 1, str + letters[i])\n        }\n    }\n    bfs(0, '')\n    return ans\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [""],
                "test_expected": [],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["23"],
                "test_expected": ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["2"],
                "test_expected": ["a", "b", "c"],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "generateParentheses": {
        "refName": "generateParentheses",
        "refNumber": 24,
        "category": "String",
        "difficulty": "Medium",
        "title": "Generate Parentheses",
        "tags": ["Medium", "String"],
        "description": "<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>",
        "examples": {
            "example1": {
                "input": "num = 3;",
                "output": "['((()))','(()())','(())()','()(())','()()()']"
            },
            "example2": {
                "input": "num = 1;",
                "output": "['()']"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function generateParentheses(n) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function generateParentheses(n) {\n    // Resultant list\n    const result = [];\n    // Recursively generate parentheses\n    generate(result, '', 0, 0, n);\n    return result;\n};\nfunction generate(result, s, open, close, n) {\n    // Base condition\n    if (open === n && close === n) {\n        result.push(s);\n        return;\n    }\n    // If the number of _open parentheses is less than the given n\n    if (open < n) {\n        generate(result, s + '(', open + 1, close, n);\n    }\n    // If we need more close parentheses to balance\n    if (close < open) {\n        generate(result, s + ')', open, close + 1, n);\n    }\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [3],
                "test_expected": ["((()))", "(()())", "(())()", "()(())", "()()()"],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [1],
                "test_expected": ["()"],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "countAndSay": {
        "refName": "countAndSay",
        "refNumber": 25,
        "category": "String",
        "difficulty": "Medium",
        "title": "Count And Say",
        "tags": ["Medium", "String"],
        "description": "<p>Find the n’th term in Look-and-say (Or Count and Say) Sequence. The look-and-say sequence is the sequence of below integers:</p><p>1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, …</p><p>How is above sequence generated? n’th term in generated by reading (n-1)’th term.</p><ul><li>The first term is '1'</li><li>Second term is '11', generated by reading first term as 'One 1' (There is one 1 in previous term)</li><li>Third term is '21', generated by reading second term as 'Two 1'</li><li>Fourth term is '1211', generated by reading third term as 'One 2 One 1'</li></ul><p>and so on...</p>",
        "examples": {
            "example1": {
                "input": "num = 3;",
                "output": "21"
            },
            "example2": {
                "input": "num = 5;",
                "output": "111221"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function countAndSay(n) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function countAndSay(n) {\n    var s = '1';\n    for (var i = 1; i < n; i++) {\n        s = getStr(s);\n    }\n    return s;\n};\nfunction getStr(s) {\n    var curr = s.charAt(0);\n    var count = 1;\n    var res = '';\n    for (var i = 1; i < s.length; i++) {\n        if (s.charAt(i) == curr) {\n            count++;\n        } else {\n            //Same as the previous characters, install the characters collected in front of RES.            \n            res = res + count + curr;\n            //Current characters are deposited in CURR\n            curr = s.charAt(i);\n            count = 1;\n        }\n    }\n    res = res + count + curr;\n    return res + '';\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [1],
                "test_expected": "1",
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [4],
                "test_expected": "1211",
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [6],
                "test_expected": "312211",
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "groupAnagrams": {
        "refName": "groupAnagrams",
        "refNumber": 26,
        "category": "String",
        "difficulty": "Medium",
        "title": "Group Anagrams",
        "tags": ["Medium", "String"],
        "description": "<p>Given an array of strings strs, group the anagrams together. You can return the answer in any order.</p><p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p>Constraints:</p><ul><li>1 <= strs.length <= 104</li><li>0 <= strs[i].length <= 100</li><li>strs[i] consists of lowercase English letters.</li></ul>",
        "examples": {
            "example1": {
                "input": "strs = ['eat','tea','tan','ate','nat','bat']",
                "output": "[['bat'],['nat','tan'],['ate','eat','tea']]"
            },
            "example2": {
                "input": "strs = ['']",
                "output": "[['']]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function groupAnagrams(input) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function groupAnagrams(input) {\n    const map = new Map();\n    let key;\n    for (let i = 0; i < input.length; ++i) {\n        if (map.has(key = [...input[i]].sort().join('')))\n            map.get(key).push(input[i]);\n        else map.set(key, [input[i]]);\n    }\n    return [...map.values()];\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [["eat", "tea", "tan", "ate", "nat", "bat"]],
                "test_expected": [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[""]],
                "test_expected": [[""]],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "decodeWays": {
        "refName": "decodeWays",
        "refNumber": 27,
        "category": "String",
        "difficulty": "Medium",
        "title": "Decode Ways",
        "tags": ["Medium", "String"],
        "description": "<p>A message containing letters from A-Z can be encoded into numbers using the following mapping:</p><p>'A' -> '1' 'B' -> '2' ... 'Z' -> '26'</p><p>To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, '11106' can be mapped into:</p><ul><li>'AAJF' with the grouping (1 1 10 6)</li><li>'KJF' with the grouping (11 10 6)</li></ul><p>Note that the grouping (1 11 06) is invalid because '06' cannot be mapped into 'F' since '6' is different from '06'.</p><p>Given a string s containing only digits, return the number of ways to decode it.<p/><p>The test cases are generated so that the answer fits in a 32-bit integer.</p>",
        "examples": {
            "example1": {
                "input": "strs = '12'",
                "output": "2\nExplanation: '12' could be decoded as 'AB' (1 2) or 'L' (12)."
            },
            "example2": {
                "input": "strs = '226'",
                "output": "3\nExplanation: '226' could be decoded as 'BZ' (2 26), 'VF' (22 6), or 'BBF' (2 2 6)."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function decodeWays(s) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function decodeWays(s) {\n    var len = s.length;\n    var tmp = 0;\n    var tmp1 = 1;\n    var tmp2 = 0;\n    var num1 = 0;\n    var num2 = 0;\n    if (s === '' || s[0] === '0') return 0;\n    for (var i = 1; i <= len; i++) {\n        num1 = Number(s.substr(i - 1, 1));\n        num2 = Number(s.substr(i - 2, 2));\n        if (num1 !== 0) tmp += tmp1;\n        if (10 <= num2 && num2 <= 26) tmp += tmp2;\n        tmp2 = tmp1;\n        tmp1 = tmp;\n        tmp = 0;\n    }\n    return tmp1;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["12"],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["226"],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["06"],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "palindromePartitioning": {
        "refName": "palindromePartitioning",
        "refNumber": 28,
        "category": "String",
        "difficulty": "Medium",
        "title": "Palindrome Partitioning",
        "tags": ["Medium", "String"],
        "description": "<p>Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.</p><p>A palindrome string is a string that reads the same backward as forward.</p><p>Constraints:</p><ul><li>1 <= s.length <= 16</li><li>s contains only lowercase English letters.</li></ul>",
        "examples": {
            "example1": {
                "input": "strs = 'abb'",
                "output": "[['a','a','b'],['aa','b']]"
            },
            "example2": {
                "input": "strs = 'a'",
                "output": "[['a']]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function palindromePartitioning(s) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function palindromePartitioning(s) {\n    var dp = getDp(s);\n    var res = [];\n    var now = [];\n    dfs(dp, res, now, s, 0);\n    return res;\n};\nvar dfs = function (dp, res, now, s, index) {\n    var len = s.length;\n    if (index === len) {\n        res.push(Array.from(now));\n        return;\n    }\n    for (var i = index; i < len; i++) {\n        if (dp[index][i]) {\n            now.push(s.substring(index, i + 1));\n            dfs(dp, res, now, s, i + 1);\n            now.pop();\n        }\n    }\n};\nvar getDp = function (s) {\n    var len = s.length;\n    var dp = Array(len);\n    for (var i = 0; i < len; i++) {\n        for (var j = 0; j <= i; j++) {\n            if (!dp[j]) dp[j] = Array(len);\n            dp[j][i] = (s[i] === s[j]) && (i - j <= 2 || dp[j + 1][i - 1]);\n        }\n    }\n    return dp;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["aab"],
                "test_expected": [
                    ["a", "a", "b"],
                    ["aa", "b"]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["a"],
                "test_expected": [["a"]],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "rotateMatrix": {
        "refName": "rotateMatrix",
        "refNumber": 29,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Rotate Matrix",
        "tags": ["Easy", "Array"],
        "description": "<p>Given a matrix, clockwise rotate elements in it.</p>",
        "examples": {
            "example1": {
                "input": "const testMatrix = [\n    [1, 2, 3, 4],\n    [0, 1, 2, 3],\n    [0, 0, 1, 2],\n    [1, 0, 0, 1],\n];",
                "output": "const testMatrix = [\n    [1, 0, 0, 1],\n    [0, 0, 1, 2],\n    [0, 1, 2, 3],\n    [1, 2, 3, 4],\n];"
            },
            "example2": {
                "input": "const testMatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9],\n]",
                "output": "const testMatrix = [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3],\n]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function rotateMatrix(matrix) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\nfunction rotateMatrix(matrix) {\n    return matrix[0].map((val, index) =>\n        matrix.map((row) => row[index]).reverse()\n    );\n}\n// Solution 2\nfunction rotateMatrix(matrix) {\n    const result = [];\n    for (let i=0; i< matrix[0].length; i++) {\n        const arr = [];\n        for (let y=0; y< matrix.length; y++) {\n            arr.push(matrix[y][i]);\n        }\n        result.push(arr.reverse())\n    }\n    return result;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        [1, 2, 3, 4],
                        [0, 1, 2, 3],
                        [0, 0, 1, 2],
                        [1, 0, 0, 1]
                    ]
                ],
                "test_expected": [
                    [1, 0, 0, 1],
                    [0, 0, 1, 2],
                    [0, 1, 2, 3],
                    [1, 2, 3, 4]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        [1, 2, 3],
                        [4, 5, 6],
                        [7, 8, 9]
                    ]
                ],
                "test_expected": [
                    [7, 4, 1],
                    [8, 5, 2],
                    [9, 6, 3]
                ],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "zeroMatrix": {
        "refName": "zeroMatrix",
        "refNumber": 30,
        "category": "Array",
        "difficulty": "Medium",
        "title": "Zero Matrix",
        "tags": ["Medium", "Array"],
        "description": "<p>Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0.</p>",
        "examples": {
            "example1": {
                "input": "const testMatrix = [\n    [1, 2, 3, 4],\n    [0, 1, 2, 3],\n    [0, 0, 1, 2],\n    [1, 0, 0, 1],\n];",
                "output": "const testMatrix = [\n    [0, 0, 0, 4],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n    [0, 0, 0, 0],\n];"
            },
            "example2": {
                "input": "const testMatrix = [\n    [1, 2, 3, 4],\n    [0, 1, 2, 3],\n    [0, 5, 1, 2],\n    [1, 3, 0, 1],\n];",
                "output": "const testMatrix = [ [0, 2, 0, 4], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], ];"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function zeroMatrix(array) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function zeroMatrix(array) {\n    const matrix = JSON.parse(JSON.stringify(array));\n    let rows = new Array(matrix.length).fill(false);\n    let cols = new Array(matrix[0].length).fill(false);\n    for (let y = 0; y < rows.length; ++y) {\n        for (let x = 0; x < cols.length; ++x) {\n            if (matrix[y][x] === 0) {\n                rows[y] = true;\n                cols[x] = true;\n            }\n        }\n    }\n    for (let y = 0; y < rows.length; ++y) {\n        for (let x = 0; x < cols.length; ++x) {\n            if (rows[y] || cols[x]) {\n                matrix[y][x] = 0;\n            }\n        }\n    }\n    return matrix;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        [1, 2, 3, 4],
                        [0, 1, 2, 3],
                        [0, 5, 1, 2],
                        [1, 3, 0, 1]
                    ]
                ],
                "test_expected": [
                    [0, 2, 0, 4],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        [1, 2, 3, 4],
                        [0, 1, 2, 3],
                        [0, 0, 1, 2],
                        [1, 0, 0, 1]
                    ]
                ],
                "test_expected": [
                    [0, 0, 0, 4],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "searchEntryEqualToItsIndex": {
        "refName": "searchEntryEqualToItsIndex",
        "refNumber": 31,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Search Entry Equal To Its Index",
        "tags": ["Easy", "Array"],
        "description": "<p>Given an array of n distinct integers sorted in ascending order, write a function that returns a Fixed Point in the array, if there is any Fixed Point present in array, else returns -1.</p><p>Fixed Point in an array is an index i such that arr[i] is equal to i. Note that integers in array can be negative.</p>",
        "examples": {
            "example1": {
                "input": "arr[] = [-10, -5, 0, 3, 7]",
                "output": "3 // arr[3] == 3"
            },
            "example2": {
                "input": "arr[] = [0, 2, 5, 8, 17]",
                "output": "0 // arr[0] == 0"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function searchEntryEqualToItsIndex(array) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function searchEntryEqualToItsIndex(array) {\n    for (let i = 0; i<array.length; i++) {\n        if (array[i] === i) return i;\n    }\n    return -1;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[-2, 0, 2, 3, 6, 7, 9]],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[-2, -1, 0, 0, 2, 5, 3]],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[-10, -5, 0, 3, 7]],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[-10, -5, 3, 4, 7, 9]],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "mergeSortedArray": {
        "refName": "mergeSortedArray",
        "refNumber": 32,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Merge Sorted Array",
        "tags": ["Easy", "Array"],
        "description": "<p>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.</p><p>Merge nums1 and nums2 into a single array sorted in non-decreasing order.</p><p>The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.</p>",
        "examples": {
            "example1": {
                "input": "nums1 = [1,2,3,0,0,0];\nm = 3;\nnums2 = [2,5,6], n = 3;",
                "output": "[1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6]."
            },
            "example2": {
                "input": "nums1 = [1];\nm = 1;\nnums2 = [];\nn = 0;",
                "output": "[1]\nExplanation: The arrays we are merging are [1] and []. The result of the merge is [1]."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function mergeSortedArray(nums1, m, nums2, n) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\nfunction mergeSortedArray(nums1, m, nums2, n) {\n    let first = m - 1;\n    let second = n - 1;\n    let i = m + n - 1;\n    while (second >= 0) {\n        let fVal = nums1[first];\n        let sVal = nums2[second];\n        if (fVal > sVal) {\n            nums1[i] = fVal;\n            i--;\n            first--;\n        } else {\n            nums1[i] = sVal;\n            i--;\n            second--;\n        }\n    }\n    return nums1;\n}\n// Solution 2\nfunction mergeSortedArray(nums1, m, nums2, n) {\n    let p1 = m - 1;\n    let p2 = n - 1;\n    let p3 = m + n - 1;\n    while (p2 >= 0) {\n        nums1[p3--] = p1 >= 0 && nums1[p1] > nums2[p2] ? nums1[p1--] : nums2[p2--];\n    }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3],
                "test_expected": [1, 2, 2, 3, 5, 6],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[1], 1, [], 0],
                "test_expected": [1],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[0], 0, [1], 1],
                "test_expected": [1],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[2, 5, 6], 3, [1, 2, 3, 0, 0, 0], 3],
                "test_expected": [1, 2, 2, 3, 5, 6],
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [[1, 2, 3, 4, 5], 3, [4, 5, 6, 7, 8], 3],
                "test_expected": [1, 2, 3, 4, 5, 6],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "removeDuplicates": {
        "refName": "removeDuplicates",
        "refNumber": 33,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Remove Duplicates",
        "tags": ["Easy", "Array"],
        "description": "<p>Given an integer array, create a function removeDuplicates that remove the duplicate numbers and return the number of elements removed. The relative order of the elements should be kept the same.</p><p>Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.</p>",
        "examples": {
            "example1": {
                "input": "nums = [1,1,2]",
                "output": "2"
            },
            "example2": {
                "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
                "output": "5"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function removeDuplicates(nums) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\n// Time: O(n^2)\nfunction removeDuplicates(nums) {\n   return nums.filter((item, pos, self) => {\n      return self.indexOf(item) == pos;\n   }).length\n};\n// Solution 2\nfunction removeDuplicates(nums) {\n   return [...new Set(nums)].length\n}\n// Solution 3\nfunction removeDuplicates(arr) {\n   if (nums.length == 0) return 0;\n   let p1 = 0;\n   let p2 = 1;\n   while (p2 < nums.length) {\n      if (nums[p2] !== nums[p1]) {\n         p1++;\n         nums[p1] = nums[p2];\n      }\n      p2++;\n   }\n   return i + 1\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 1, 2]],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[0, 0, 1, 1, 1, 2, 2, 3, 3, 4]],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[0, 0, 1, 1, 1, 2, 2, 3, 3, 4, 5, 2, 2, 5, 6]],
                "test_expected": 7,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[1, 2, 3, 1, 4, 6, 2, 2, 5, 6, 1, 8, 9, 8, 11, 12, 13, 14, 15, 16]],
                "test_expected": 14,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "countingFrequenciesOfArray": {
        "refName": "countingFrequenciesOfArray",
        "refNumber": 34,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Counting Frequencies Of Array",
        "tags": ["Easy", "Array"],
        "description": "<p>Given an array which may contain duplicates, return an object with all elements and their frequencies.</p>",
        "examples": {
            "example1": {
                "input": "arr = [10, 20, 20, 10, 10, 20, 5, 20]",
                "output": "{10: 3, 20: 4, 5: 1}"
            },
            "example2": {
                "input": "arr = [10, 20, 20]",
                "output": "{10: 1, 20: 1}"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function countingFrequenciesOfArray(arr, size) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function countingFrequenciesOfArray(arr, size) {\n    let freqMap = new Map();\n    for (let i = 0; i < size; i++) {\n        if (freqMap.has(arr[i])) {\n            freqMap.set(arr[i], freqMap.get(arr[i]) + 1);\n        } else {\n            freqMap.set(arr[i], 1);\n        }\n    }\n    \n     return Object.fromEntries(freqMap);\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[10, 20, 20, 10, 10, 20, 5, 20], 8],
                "test_expected": {
                    "5": 1,
                    "10": 3,
                    "20": 4
                },
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[10, 20, 20], 3],
                "test_expected": {
                    "10": 1,
                    "20": 2
                },
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[10, 20, 20], 3],
                "test_expected": {
                    "10": 1,
                    "20": 2
                },
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "twoSum": {
        "refName": "twoSum",
        "refNumber": 35,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Two Sum",
        "tags": ["Easy", "Array"],
        "description": "<p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.</p><p>Constraints:</p><ul><li>2 <= nums.length <= 104</li><li>-109 <= nums[i] <= 109</li><li>-109 <= target <= 109</li><li>Only one valid answer exists.</li></ul><p>Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?</p>",
        "examples": {
            "example1": {
                "input": "nums = [2,7,11,15], target = 9",
                "output": "[0,1]"
            },
            "example2": {
                "input": "nums = [3,2,4], target = 6",
                "output": "[1,2]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function twoSum(array, target) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function twoSum(array, goal) {\n    let indexes = [];\n    for (let i = 0; i < array.length; i++) {\n        for (let j = i + 1; j < array.length; j++) {\n            if (array[i] + array[j] === goal) {\n                indexes.push(i);\n                indexes.push(j);\n            }\n        }\n    }\n    return indexes;\n}\n// Optimal solution\nfunction twoSum(array, target) {\n    const list = new Map();\n    for ( let i = 0; i < array.length; i++) {\n        const complement = target - array[i];\n        if (list.has(complement)) return [list.get(complement), i]\n        list.set(array[i], i);\n    }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[2, 7, 11, 15], 9],
                "test_expected": [0, 1],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[3, 2, 4], 6],
                "test_expected": [1, 2],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[3, 3], 6],
                "test_expected": [0, 1],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "singleNumber": {
        "refName": "singleNumber",
        "refNumber": 36,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Single Number",
        "tags": ["Easy", "Array"],
        "description": "<p>Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.</p><p>You must implement a solution with a linear runtime complexity and use only constant extra space.</p>",
        "examples": {
            "example1": {
                "input": "nums = [2,2,1]",
                "output": "1"
            },
            "example2": {
                "input": "nums = [4,1,2,1,2]",
                "output": "4"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function singleNumber(nums2) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\n// Time = O(n^2)  BAD!\nfunction singleNumber(nums2) {\n    return nums2.filter((v, i) => nums2.indexOf(v) === nums2.lastIndexOf(v))[0];\n}\n// Solution 2\n// HashMap O(n) time and O(n) space.\nfunction singleNumber(nums) {\n    const list = new Map();\n    for (const num of nums) {\n        if (list.has(num)) {\n            const val = list.get(num);\n            list.set(num, val + 1);\n        } else {\n            list.set(num, 1);\n        }\n    }\n    for (let [key, value] of list) {\n        if (value === 1) return key;\n    }\n    return -1;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[2, 2, 1]],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[4, 1, 2, 1, 2]],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[1]],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[1, 1, 3, 4, 5, 3, 4, 8, 8]],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [[1, 1, 2, 2, 3, 3]],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "thirdMaximumNumber": {
        "refName": "thirdMaximumNumber",
        "refNumber": 37,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Third Maximum Number",
        "tags": ["Easy", "Array"],
        "description": "<p>Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.</p>",
        "examples": {
            "example1": {
                "input": "nums = [3,2,1]",
                "output": "3"
            },
            "example2": {
                "input": "nums = [1,2]",
                "output": "2"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function thirdMaximumNumber(nums) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time O(n)\n// Space O(1)\nfunction thirdMaximumNumber(nums) {\n    let min = -Infinity;\n    let mid = -Infinity;\n    let max = -Infinity;\n    for (const num of nums) {\n        if (num > max) {\n            min = mid;\n            mid = max;\n            max = num;\n        }\n        if (num < max && num > mid) {\n            min = mid;\n            mid = num;\n        }\n        if (num < mid && num > min) {\n            min = num;\n        }\n    }\n    return min > -Infinity ? min : max;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[3, 2, 1]],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[1, 2]],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[2, 2, 3, 1]],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[1, 14, 2, 16, 10, 20]],
                "test_expected": 14,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "repitedNumbers": {
        "refName": "repitedNumbers",
        "refNumber": 38,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Repited Numbers",
        "tags": ["Easy", "Array"],
        "description": "<p>Write a function, repitedNumbers, that takes in two arrays, a,b, as arguments. The function should return a new array containing elements that are in both of the two arrays.</p><p>You may assume that each input array does not contain duplicate elements.</p>",
        "examples": {
            "example1": {
                "input": "arr1 = [4,2,1,6]\narr2 = [3,6,9,2,10]",
                "output": "[2,6]"
            },
            "example2": {
                "input": "arr1 = [2,4,6]\narr2 = [4,2]",
                "output": "[2,4]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function repitedNumbers(a, b) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// brute force (timeout)\n// n = length of array a, m = length of array b\n// Time: O(n*m)\n// Space: O(min(n,m))\nfunction repitedNumbers(a, b) {\n  const result = [];\n  for (let item of b) {\n    if (a.includes(item)) {\n      result.push(item);\n    }\n  }\n  return result;\n};\n// n = length of array a, m = length of array b\n// Time: O(n+m)\n// Space: O(n)\nfunction repitedNumbers(a, b) {\n  const result = [];\n  const setA = new Set(a);\n  for (let item of b) {\n    if (setA.has(item)) {\n      result.push(item);\n    }\n  }\n  return result;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [4, 2, 1, 6],
                    [3, 6, 9, 2, 10]
                ],
                "test_expected": [2, 6],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [2, 4, 6],
                    [4, 2]
                ],
                "test_expected": [2, 4],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [4, 2, 1],
                    [1, 2, 4, 6]
                ],
                "test_expected": [1, 2, 4],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [0, 1, 2],
                    [10, 11]
                ],
                "test_expected": [],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "sortByName": {
        "refName": "sortByName",
        "refNumber": 39,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Sort By Name",
        "tags": ["Easy", "Array"],
        "description": "<p>Giving an array of lastname and first name, order the arry by first name.</p>",
        "examples": {
            "example1": {
                "input": "arr1 = [\n  'Beck, Glenn',\n  'Becker, Carl',\n  'Beckett, Samuel',\n  'Beddoes, Mick',\n  'Beecher, Henry',\n  'Beethoven, Ludwig',\n  'Begin, Menachem',\n];",
                "output": "[\n  'Becker, Carl',\n  'Beck, Glenn',\n  'Beecher, Henry',\n  'Beethoven, Ludwig',\n  'Begin, Menachem',\n  'Beddoes, Mick',\n  'Beckett, Samuel',\n];"
            },
            "example2": {
                "input": "arr1 = ['Beck, Glenn', 'Adam, Carl', 'Adam, Samuel', 'Wally, Mick', 'Beck, Henry'];",
                "output": "['Adam, Carl', 'Adam, Samuel', 'Beck, Glenn', 'Beck, Henry', 'Wally, Mick'];"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function sortByName(arr) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\nfunction sortByName(arr) {\n  let unique_array = arr.filter((elem, index, self) => {\n    return index !== self.indexOf(elem);\n  });\n  return new Set(unique_array);\n}\n// Solution 2\nfunction sortByName(arr) {\n  return arr.filter((elem, index, self) => {\n    return self.lastIndexOf(elem) === index && self.indexOf(elem) !== index;\n  });\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [["Beck, Glenn", "Adam, Carl", "Adam, Samuel", "Wally, Mick", "Beck, Henry"]],
                "test_expected": [
                    "Becker, Carl",
                    "Beck, Glenn",
                    "Beecher, Henry",
                    "Beethoven, Ludwig",
                    "Begin, Menachem",
                    "Beddoes, Mick",
                    "Beckett, Samuel"
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [["Beck, Glenn", "Adam, Carl", "Adam, Samuel", "Wally, Mick", "Beck, Henry"]],
                "test_expected": ["Adam, Carl", "Adam, Samuel", "Beck, Glenn", "Beck, Henry", "Wally, Mick"],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "MaxSumConsecutiveElements": {
        "refName": "MaxSumConsecutiveElements",
        "refNumber": 40,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Max Sum Consecutive Elements",
        "tags": ["Easy", "Array"],
        "description": "<p>Given an array of N positive integers, find the maximum sum of 3 consecutive elements.</p>",
        "examples": {
            "example1": {
                "input": "arr1 = [1, 1, 1, 2, 2, 2, 3, 3, 3];",
                "output": "9\nbeacuse 3 + 3 + 3 = 9 the maximum value;"
            },
            "example2": {
                "input": "arr1 = [1, 3, 2, 5, 9, 3, 12, 0, 1];",
                "output": "24"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function MaxSumConsecutiveElements(arr) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time O(N)\nfunction MaxSumConsecutiveElements(arr) {\n    let maxSum = 0;\n    let windowSize = 0;\n    let windowSum = 0;\n    for (let i = 0; i <= arr.length; i++) {\n        if (windowSize === 3) {\n            maxSum = Math.max(maxSum, windowSum);\n            windowSum = windowSum - arr[i - 3];\n            windowSize--;\n        }\n        windowSum += arr[i];\n        windowSize++;\n    }\n    return maxSum;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 1, 1, 2, 2, 2, 3, 3, 3]],
                "test_expected": 9,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[1, 3, 2, 5, 9, 3, 12, 0, 1]],
                "test_expected": 24,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[90, 3, 2, 5, 9, 3, 12, 0, 1]],
                "test_expected": 95,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "insertAtAllPositions": {
        "refName": "insertAtAllPositions",
        "refNumber": 41,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Insert At All Positions",
        "tags": ["Easy", "Array"],
        "description": "<p>Write a function, InsertAtAllPositions, that takes in an array of elements and a value. The function should return a 2D array where each subarray represents one of the possible permutations of the value in the array.</p><p>The subarrays may be returned in any order.</p><p>You may assume that the input array contains unique elements.</p>",
        "examples": {
            "example1": {
                "input": "arr1 = [1, 2, 3]\ntarget = 4;",
                "output": "[[4, 1, 2, 3], [1, 4, 2, 3], [1, 2, 4, 3], [1, 2, 3, 4]];"
            },
            "example2": {
                "input": "arr1 = ['a', 'b', 'c']\ntarget = 'd';",
                "output": "[['d', 'a', 'b', 'c'], ['a', 'd', 'b', 'c'], ['a', 'b', 'd', 'c'], ['a', 'b', 'c', 'd']];"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function insertAtAllPositions(arr, target) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function insertAtAllPositions(arr, target) {\n    const fullPermutations = [];\n    for (let i = 0; i <= arr.length; i += 1) {\n        const newPerm = [...arr];\n        newPerm.splice(i, 0, target);\n        fullPermutations.push(newPerm);\n    }\n    return fullPermutations;\n}\nfunction insertAtAllPositions(arr, target) {\n    const fullPermutations = [];\n    for (let i = 0; i <= arr.length; i += 1) {\n        fullPermutations.push([...arr.slice(0, i), target, ...arr.slice(i)]);\n    }\n    return fullPermutations;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 2, 3], 4],
                "test_expected": [
                    [4, 1, 2, 3],
                    [1, 4, 2, 3],
                    [1, 2, 4, 3],
                    [1, 2, 3, 4]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [["a", "b", "c"], "d"],
                "test_expected": [
                    ["d", "a", "b", "c"],
                    ["a", "d", "b", "c"],
                    ["a", "b", "d", "c"],
                    ["a", "b", "c", "d"]
                ],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "rotateArray": {
        "refName": "rotateArray",
        "refNumber": 42,
        "category": "Array",
        "difficulty": "Medium",
        "title": "Rotate Array",
        "tags": ["Medium", "Array"],
        "description": "<p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p><p>Follow up:</p><ul><li>Try to come up with as many solutions as you can.</li><li>There are at least three different ways to solve this problem.</li></ul><p>Could you do it in-place with O(1) extra space?</p>",
        "examples": {
            "example1": {
                "input": "nums = [1,2,3,4,5,6,7];\nk = 3",
                "output": "[5,6,7,1,2,3,4]\nExplanation:\n- rotate 1 steps to the right: [7,1,2,3,4,5,6]\n rotate 2 steps to the right: [6,7,1,2,3,4,5]\n- rotate 3 steps to the right: [5,6,7,1,2,3,4]"
            },
            "example2": {
                "input": "nums = [-1,-100,3,99];\nk = 2",
                "output": "[3,99,-1,-100]\nExplanation:\n- rotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function rotateArray(nums, k) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function rotateArray(nums, k) {\n    for (var i = 0; i < k; i++) {\n        var popedElement = nums.pop();\n        nums.unshift(popedElement);\n    }\n};\nfunction rotateArray(nums, k) {\n    var leftItem = nums.slice(0, nums.length - k);\n    var rightItem = nums.slice(nums.length - k);\n    for (var i = 0; i < rightItem.length; i++) {\n        nums[i] = rightItem[i];\n    }\n    for (var i = 0; i < leftItem.length; i++) {\n        nums[rightItem.length + i] = leftItem[i];\n    }\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 2, 3, 4, 5, 6, 7], 3],
                "test_expected": [5, 6, 7, 1, 2, 3, 4],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[-1, -100, 3, 99], 2],
                "test_expected": [3, 99, -1, -100],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "productOfArrayExceptSelf": {
        "refName": "productOfArrayExceptSelf",
        "refNumber": 43,
        "category": "Array",
        "difficulty": "Medium",
        "title": "Product Of Array Except Self",
        "tags": ["Medium", "Array"],
        "description": "<p>Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].</p><p>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.</p><p>You must write an algorithm that runs in O(n) time and without using the division operation.</p>",
        "examples": {
            "example1": {
                "input": "nums = [1,2,3,4]",
                "output": "[24,12,8,6]"
            },
            "example2": {
                "input": "nums = [-1,1,0,-3,3]",
                "output": "[0,0,9,0,0]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function productOfArrayExceptSelf(nums) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function productOfArrayExceptSelf(nums) {\n    let res = [];\n    let left = 1;\n    let right = 1;\n    for (let i = 0; i < nums.length; i++) {\n        res[i] = left;\n        left = left * nums[i];\n    }\n    for (let i = nums.length - 1; i >= 0; i--) {\n        res[i] = right * res[i];\n        right = right * nums[i];\n    }\n    return res;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 2, 3, 4]],
                "test_expected": [24, 12, 8, 6],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[-1, 1, 0, -3, 3]],
                "test_expected": [0, 0, 9, 0, 0],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "threeSum": {
        "refName": "threeSum",
        "refNumber": 44,
        "category": "Array",
        "difficulty": "Medium",
        "title": "Three Sum",
        "tags": ["Medium", "Array"],
        "description": "<p>Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.</p><p>Notice that the solution set must not contain duplicate triplets.</p>",
        "examples": {
            "example1": {
                "input": "nums = [-1,0,1,2,-1,-4]",
                "output": "[[-1,-1,2],[-1,0,1]]"
            },
            "example2": {
                "input": "nums = []",
                "output": "[]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function threeSum (nums) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function threeSum (nums) {\n    var len = nums.length;\n    var res = [];\n    var l = 0;\n    var r = 0;\n    nums.sort((a, b) => (a - b));\n    for (var i = 0; i < len; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        l = i + 1;\n        r = len - 1;\n        while (l < r) {\n            if (nums[i] + nums[l] + nums[r] < 0) {\n                l++;\n            } else if (nums[i] + nums[l] + nums[r] > 0) {\n                r--;\n            } else {\n                res.push([nums[i], nums[l], nums[r]]);\n                while (l < r && nums[l] === nums[l + 1]) l++;\n                while (l < r && nums[r] === nums[r - 1]) r--;\n                l++;\n                r--;\n            }\n        }\n    }\n    return res;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[-1, 0, 1, 2, -1, -4]],
                "test_expected": [
                    [-1, -1, 2],
                    [-1, 0, 1]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[]],
                "test_expected": [],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[0]],
                "test_expected": [],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "containerWithMostWater": {
        "refName": "containerWithMostWater",
        "refNumber": 45,
        "category": "Array",
        "difficulty": "Medium",
        "title": "Container With Most Water",
        "tags": ["Medium", "Array"],
        "description": "<p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p>Note: You may not slant the container and n is at least 2.</p>",
        "examples": {
            "example1": {
                "input": "height = [1,8,6,2,5,4,8,3,7]",
                "output": "49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49."
            },
            "example2": {
                "input": "Input: height = [1,1]",
                "output": "1"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function containerWithMostWater(height) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time complexity : O(n).\n// Space complexity : O(1).\nfunction containerWithMostWater(height) {\n  var max = 0;\n  var l = 0;\n  var r = height.length - 1;\n  while (l < r) {\n    max = Math.max(max, Math.min(height[l], height[r]) * (r - l));\n    if (height[l] < height[r]) {\n      l++;\n    } else {\n      r--;\n    }\n  }\n  return max;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 8, 6, 2, 5, 4, 8, 3, 7]],
                "test_expected": 49,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[1, 1]],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "findSmallestDifference": {
        "refName": "findSmallestDifference",
        "refNumber": 46,
        "category": "Array",
        "difficulty": "Medium",
        "title": "Find Smallest Difference",
        "tags": ["Medium", "Array"],
        "description": "<p>Given two arrays of integers, compute the pair of values (one value in each array) with the smallest (non-negative) difference.</p><p>Return the difference.</p>",
        "examples": {
            "example1": {
                "input": "arr1 = [l, 3, 15, 11, 2];\narr2 = [23, 127, 235, 19, 8]",
                "output": "3"
            },
            "example2": {
                "input": "arr1 = [1, 2, 11, 5];\narr2B = [4, 12, 19, 23, 127, 235]",
                "output": "1"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function findSmallestDifference(A, B) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function findSmallestDifference(A, B) {\n    A.sort((a, b) => a - b);\n    B.sort((a, b) => a - b);\n    let a = 0, b = 0;\n    let result = Number.MAX_SAFE_INTEGER;\n    while (a < A.length && b < B.length) {\n        if (Math.abs(A[a] - B[b]) < result) {\n            result = Math.abs(A[a] - B[b]);\n        }\n        A[a] < B[b] ? a++ : b++;\n    }\n    return result;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [1, 2, 11, 5],
                    [4, 12, 19, 23, 127, 235]
                ],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [1, 3, 15, 11, 2],
                    [23, 127, 235, 19, 8]
                ],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "spiralMatrix": {
        "refName": "spiralMatrix",
        "refNumber": 47,
        "category": "Array",
        "difficulty": "Medium",
        "title": "Spiral Matrix",
        "tags": ["Medium", "Array"],
        "description": "<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>",
        "examples": {
            "example1": {
                "input": "Input: [  [ 1, 2, 3 ],  [ 4, 5, 6 ],  [ 7, 8, 9 ] ]",
                "output": "Output: [1,2,3,6,9,8,7,4,5]"
            },
            "example2": {
                "input": "Input: [   [1, 2, 3, 4],   [5, 6, 7, 8],   [9,10,11,12] ]",
                "output": "Output: [1,2,3,4,8,12,11,10,9,5,6,7]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function spiralMatrix(matrix) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function spiralMatrix(matrix) {\n  var n = matrix.length;\n  var m = (matrix[0] || []).length;\n  var res = [];\n  var x1 = 0;\n  var x2 = m - 1;\n  var y1 = 0;\n  var y2 = n - 1;\n  while (x1 <= x2 && y1 <= y2) {\n    for (var x = x1; x <= x2; x++) res.push(matrix[y1][x]);\n    for (var y = y1 + 1; y <= y2; y++) res.push(matrix[y][x2]);\n    if (x1 < x2 && y1 < y2) {\n      for (var x = x2 - 1; x > x1; x--) res.push(matrix[y2][x]);\n      for (var y = y2; y > y1; y--) res.push(matrix[y][x1]);\n    }\n    x1++;\n    x2--;\n    y1++;\n    y2--;\n  }\n  return res;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        [1, 2, 3],
                        [4, 5, 6],
                        [7, 8, 9]
                    ]
                ],
                "test_expected": [1, 2, 3, 6, 9, 8, 7, 4, 5],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        [1, 2, 3, 4],
                        [5, 6, 7, 8],
                        [9, 10, 11, 12]
                    ]
                ],
                "test_expected": [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "searchForRange": {
        "refName": "searchForRange",
        "refNumber": 48,
        "category": "Array",
        "difficulty": "Medium",
        "title": "Search For Range",
        "tags": ["Medium", "Array"],
        "description": "<p>Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</p><p>If target is not found in the array, return [-1, -1].</p><p>You must write an algorithm with O(log n) runtime complexity.</p>",
        "examples": {
            "example1": {
                "input": "nums = [5,7,7,8,8,10]\ntarget = 8",
                "output": "[3,4]"
            },
            "example2": {
                "input": "nums = [5,7,7,8,8,10]\ntarget = 6",
                "output": "[-1,-1]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function searchForRange(nums, target) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function searchForRange(nums, target) {\n  var res = [-1, -1];\n  var left = find(nums, target, true);\n  var right = find(nums, target, false);\n  if (!nums.length) return res;\n  if (left > right) return res;\n  return [left, right];\n};\nvar find = function (nums, target, findLeft) {\n  var left = 0;\n  var right = nums.length - 1;\n  var mid = 0;\n  while (left <= right) {\n    mid = Math.floor((left + right) / 2);\n    if (nums[mid] > target || (findLeft && nums[mid] === target)) {\n      right = mid - 1;\n    } else {\n      left = mid + 1;\n    }\n  }\n  return findLeft ? left : right;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[5, 7, 7, 8, 8, 10], 8],
                "test_expected": [3, 4],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[5, 7, 7, 8, 8, 10], 6],
                "test_expected": [-1, -1],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[], 0],
                "test_expected": [-1, -1],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "combinationSum": {
        "refName": "combinationSum",
        "refNumber": 49,
        "category": "Array",
        "difficulty": "Medium",
        "title": "Combination Sum",
        "tags": ["Medium", "Array"],
        "description": "<p>Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.</p><p>The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p><p>It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p>",
        "examples": {
            "example1": {
                "input": "candidates = [2,3,6,7]\ntarget = 7",
                "output": "[[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations."
            },
            "example2": {
                "input": "candidates = [2,3,5]\ntarget = 8",
                "output": "[[2,2,2,2],[2,3,3],[3,5]]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function combinationSum(candidates, target) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function combinationSum(nums, target) {\n    let combinations = [];\n    nums.sort((a, b) => a - b);\n    function backtrack(tempList, remaining, start) {\n        for (let i = start; i < nums.length && nums[i] <= remaining; i++) {\n            if (nums[i] === remaining) {\n                combinations.push([...tempList, nums[i]]);\n            } else {\n                backtrack([...tempList, nums[i]], remaining - nums[i], i);\n            }\n        }\n    }\n    backtrack([], target, 0);\n    return combinations;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[2, 3, 6, 7], 7],
                "test_expected": [[2, 2, 3], [7]],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[2, 3, 5], 8],
                "test_expected": [
                    [2, 2, 2, 2],
                    [2, 3, 3],
                    [3, 5]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[2]],
                "test_expected": [],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "combinationSum2": {
        "refName": "combinationSum2",
        "refNumber": 50,
        "category": "Array",
        "difficulty": "Medium",
        "title": "Combination Sum 2",
        "tags": ["Medium", "Array"],
        "description": "<p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.</p><p>Each number in candidates may only be used once in the combination.</p><p>Note: The solution set must not contain duplicate combinations.</p>",
        "examples": {
            "example1": {
                "input": "candidates = [10,1,2,7,6,1,5]\ntarget = 8",
                "output": "[ [1,1,6], [1,2,5], [1,7], [2,6] ]"
            },
            "example2": {
                "input": "candidates = [2,5,2,1,2]\ntarget = 5",
                "output": "[ [1,2,2], [5] ]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function combinationSum2(candidates, target) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time complexity : O(n^2).\n// Space complexity : O(n^2).\nfunction combinationSum2(candidates, target) {\n  var res = [];\n  var len = candidates.length;\n  candidates.sort((a, b) => (a - b));\n  dfs(res, [], 0, len, candidates, target);\n  return res;\n};\nvar dfs = function (res, stack, index, len, candidates, target) {\n  var tmp = null;\n  if (target < 0) return;\n  if (target === 0) return res.push(stack);\n  for (var i = index; i < len; i++) {\n    if (candidates[i] > target) break;\n    if (i > index && candidates[i] === candidates[i - 1]) continue;\n    tmp = Array.from(stack);\n    tmp.push(candidates[i]);\n    dfs(res, tmp, i + 1, len, candidates, target - candidates[i]);\n  }\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[10, 1, 2, 7, 6, 1, 5], 8],
                "test_expected": [
                    [1, 1, 6],
                    [1, 2, 5],
                    [1, 7],
                    [2, 6]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[2, 5, 2, 1, 2], 5],
                "test_expected": [[1, 2, 2], [5]],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "productExceptSelf": {
        "refName": "productExceptSelf",
        "refNumber": 51,
        "category": "Array",
        "difficulty": "Hard",
        "title": "Product Except Self",
        "tags": ["Hard", "Array"],
        "description": "<p>Given an array nums of n integers where n > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>",
        "examples": {
            "example1": {
                "input": "input = [1,2,3,4]",
                "output": "Output = [24,12,8,6]"
            },
            "example2": {
                "input": "input = [1,2,3,4]",
                "output": "Output = [24,12,8,6]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function productExceptSelf(nums) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\n// Time complexity : O(n).\n// Space complexity : O(n).\nfunction productExceptSelf(nums) {\n  var len = nums.length;\n  var left = Array(len + 1);\n  var right = Array(len + 1);\n  var res = Array(len);\n  left[0] = 1;\n  right[0] = 1;\n  for (var i = 0; i < len; i++) {\n    left[i + 1] = left[i] * nums[i];\n  }\n  for (var j = 0; j < len; j++) {\n    right[j + 1] = right[j] * nums[len - 1 - j];\n  }\n  for (var k = 0; k < len; k++) {\n    res[k] = left[k] * right[len - k - 1];\n  }\n  return res;\n};\n// Solution 2\n// Time complexity : O(n).\n// Space complexity : O(1).\nfunction productExceptSelf(nums) {\n  var len = nums.length;\n  var res = Array(len);\n  var right = 1;\n  res[0] = 1;\n  for (var i = 1; i < len; i++) {\n    res[i] = res[i - 1] * nums[i - 1];\n  }\n  for (var j = len - 1; j >= 0; j--) {\n    res[j] *= right;\n    right *= nums[j];\n  }\n  return res;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 2, 3, 4]],
                "test_expected": [24, 12, 8, 6],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[1]],
                "test_expected": [1],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[2, 2, 8, 8]],
                "test_expected": [128, 128, 32, 32],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "maximumSubArray": {
        "refName": "maximumSubArray",
        "refNumber": 52,
        "category": "Array",
        "difficulty": "Medium",
        "title": "Maximum SubArray",
        "tags": ["Medium", "Array"],
        "description": "<p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>A subarray is a contiguous part of an array.</p>Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>",
        "examples": {
            "example1": {
                "input": "Input = [-2,1,-3,4,-1,2,1,-5,4]",
                "output": "6\nExplanation: [4,-1,2,1] has the largest sum = 6."
            },
            "example2": {
                "input": "Input = [5,4,-1,7,8]",
                "output": "23"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function maximumSubArray(nums) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time: O(n)\n// Space: O(1)\nfunction maximumSubArray(nums) {\n    let currSum = -Infinity;\n    let maxSum = -Infinity;\n    for(let i = 0; i < nums.length; i++) {\n        currSum = Math.max(0, currSum);\n        currSum += nums[i];\n        maxSum = Math.max(maxSum, currSum);\n    }\n    return maxSum;\n};\n// Kadane’s Algorithm\n// Time Complexity: O(n) \nfunction maximumSubArray(nums) {\n    var maxint = Math.pow(2, 53)\n    var max_so_far = -maxint - 1\n    var max_ending_here = 0\n    for (var i = 0; i < nums.length; i++) {\n        max_ending_here = max_ending_here + nums[i]\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here\n        if (max_ending_here < 0)\n            max_ending_here = 0\n    }\n    return max_so_far\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[-2, 1, -3, 4, -1, 2, 1, -5, 4]],
                "test_expected": 6,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[1]],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[5, 4, -1, 7, 8]],
                "test_expected": 23,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[-2, -3, 4, -1, -2, 1, 5, -3]],
                "test_expected": 7,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "subArraySumEqualsToK": {
        "refName": "subArraySumEqualsToK",
        "refNumber": 53,
        "category": "Array",
        "difficulty": "Medium",
        "title": "SubArray Sum Equals To K",
        "tags": ["Medium", "Array"],
        "description": "<p>Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.</p>",
        "examples": {
            "example1": {
                "input": "Input = [1,1,1]\nk = 2",
                "output": "2"
            },
            "example2": {
                "input": "Input = [1,2,3]\nk = 3",
                "output": "2"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function subArraySumEqualsToK(nums, k) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time Complexity : O(n)\n// Space Complexity: O(n)\nfunction subArraySumEqualsToK(nums, k) {\n    let count = 0;\n    let sum = 0;\n    const map = new Map();\n    // Add 0 to map as a sum that we have seen and 1 as its value which will be he amount of times we have seen this sum so far\n    map.set(0, 1);\n    for (let i = 0; i < nums.length; i++) {\n        // Get the current sum\n        sum += nums[i];\n        // Increase the count if we have seen a sum that equals sum - k\n        if (map.has(sum - k))\n            count += map.get(sum - k);\n        // Set a new value in the map or increase the amount of times this sum has been seen by 1\n        map.set(sum, (map.get(sum) || 0) + 1);\n    }\n    return count;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 2, 3], 3],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[1, 1, 1], 2],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[1, 3, 4, 7, 8, 9], 5],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[1, 3, 5, 7, 8, 9], 5],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [[0, 3, 5, 7, 2, 10], 8],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [[11, 5, 1, 1, 1, 10], 7],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "threeInOne": {
        "refName": "threeInOne",
        "refNumber": 54,
        "category": "Stacks & Queues",
        "difficulty": "Easy",
        "title": "Three In One",
        "tags": ["Easy", "Stacks & Queues"],
        "description": "<p>ThreeInOne is a data structure that holds 3 stacks in one array.</p><p>Write a class ThreeInOne that mimics three stacks. You can only use a single array as the underlying data structure.</p>",
        "examples": {
            "example1": {
                "input": "",
                "output": ""
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "class ThreeInOne {\n    // Write your solution...\n}"
        },
        "solutionCode": {
            "javaScript": [
                "class ThreeInOne {\n    constructor() {\n        this._array = [];\n        this.length = [0, 0, 0];\n    }\n    push(stack, value) {\n        let index = 0;\n        for (let i = 0; i < stack - 1; i++) {\n            index += this.length[i];\n        }\n        this._array.splice(index, 0, value);\n        ++this.length[stack - 1];\n    }\n    pop(stack) {\n        let index = 0;\n        for (let i = 0; i < stack - 1; i++) {\n            index += this.length[i];\n        }\n        this._array.splice(index, 1);\n        --this.length[stack - 1];\n    }\n    peek(stack) {\n        let index = 0;\n        for (let i = 0; i < stack - 1; i++) {\n            index += this.length[i];\n        }\n        return this._array[index];\n    }\n    isEmpty(stack) {\n        return this.length[stack - 1] === 0;\n    }\n    getStack() {\n        return this._array;\n    }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["geeks", "geek"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["book", "books"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["demon", "dem"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "stackMin": {
        "refName": "stackMin",
        "refNumber": 55,
        "category": "Stacks & Queues",
        "difficulty": "Easy",
        "title": "Stack Min",
        "tags": ["Easy", "Stacks & Queues"],
        "description": "<p>How would you design a stack which, in addition to push and pop, has a function min which returns the minimum element?</p><p>Push, pop and min should all operate in 0(1) time.</p>",
        "examples": {
            "example1": {
                "input": "",
                "output": ""
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "class StackMin {\n    // Write your solution...\n}"
        },
        "solutionCode": {
            "javaScript": [
                "class StackMin {\n    constructor() {\n        this.stack = [];\n    }\n    push(value) {\n        this.stack.push({\n            value: value,\n            minVal: this.isEmpty() ? value : Math.min(this.minVal(), value),\n        });\n    }\n    pop() {\n        if (this.isEmpty()) return;\n        const item = this.stack.pop();\n        return item.value;\n    }\n    peek() {\n        if (this.isEmpty()) return;\n        return this.stack[this._stack.length - 1].value;\n    }\n    minVal() {\n        if (this.isEmpty()) return;\n        return this.stack[this.stack.length - 1].minVal;\n    }\n    isEmpty() {\n        return this.stack.length === 0;\n    }\n    getVal() {\n        return this.stack\n    }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { const stack = new StackMin(); stack.push(8); stack.push(21); stack.push(3); stack.push(12); const minVal = stack.minVal(); return minVal;}",
                "test_expected": 3,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { const stack = new StackMin(); stack.push(5); stack.push(21); stack.push(4); stack.push(1); stack.pop(); const minVal = stack.minVal(); return minVal;}",
                "test_expected": 4,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { const stack = new StackMin(); stack.push(1); stack.push(21); stack.push(4); stack.push(2); stack.pop(); const minVal = stack.minVal(); return minVal;}",
                "test_expected": 1,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "setOfStacks": {
        "refName": "setOfStacks",
        "refNumber": 56,
        "category": "Stacks & Queues",
        "difficulty": "Easy",
        "title": "Set Of Stacks",
        "tags": ["Easy", "Stacks & Queues"],
        "description": "<p>Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold.</p><p>Implement a data structure SetOfStacks that mimics this. SetO-fStacks should be composed of several stacks and should create a new stack once the previous one exceeds capacity.</p><p>SetOfStacks.push() and SetOfStacks.pop() should behave identically to a single stack (that is, pop () should return the same values as it would if there were just a single stack).</p><p>Implement a function popAt ( int index) which performs a pop operation on a specific sub-stack</p>",
        "examples": {
            "example1": {
                "input": "",
                "output": ""
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "class SetOfStacks {\n    // Write your solution...\n}"
        },
        "solutionCode": {
            "javaScript": [
                "class SetOfStacks {\n    constructor(threshold) {\n        this.stacks = [];\n        this.threshold = threshold;\n    }\n    push(value) {\n        if (!this.stacks.length) {\n            this.stacks.push([]);\n        }\n        if (this.stacks[this.stacks.length - 1].length === this.threshold) {\n            this.stacks.push([]);\n        }\n        this.stacks[this.stacks.length - 1].push(value);\n    }\n    pop() {\n        this.stacks[this.stacks.length - 1].pop();\n        if (this.stacks.length > 1 && !this.stacks[this.stacks.length - 1].length) {\n            this.stacks.pop();\n        }\n    }\n    popAt(i) {\n        const index = i - 1;\n        this.stacks[index].pop();\n        for (let i = index + 1; i < this.stacks.length - 1; i++) {\n            // we could use shift to do this simpler but \n            // that would be cheating.\n            // const val = this.stacks[i + 1].shift();\n            // this.stacks[i].push(val);\n            // -----\n            while (this.stacks[i].length > 0) {\n                tempStack.push(this.stacks[i].pop());\n            }\n            this.stacks[i - 1].push(tempStack.pop());\n            while (tempStack.length > 0) {\n                this.stacks[i].push(tempStack.pop());\n            }\n        }\n    }\n    getStack() {\n        return this.stacks;\n    }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["geeks", "geek"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["book", "books"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["demon", "dem"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "sortStack": {
        "refName": "sortStack",
        "refNumber": 57,
        "category": "Stacks & Queues",
        "difficulty": "Easy",
        "title": "Sort Stack",
        "tags": ["Easy", "Stacks & Queues"],
        "description": "<p>Write a program to sort a stack such that the smallest items are on the top.</p><p>You can use an additional temporary stack, but you may not copy the elements into any other data structure (such as an array).</p><p>The stack supports the following operations: push, pop, peek, and is Empty.</p>",
        "examples": {
            "example1": {
                "input": "list = 1, 4, 34, 3, 9, 4, 7, 5, 12, 8",
                "output": "1, 3, 4, 4, 5, 7, 8, 9, 12, 34"
            },
            "example2": {
                "input": "list = 1, 4, 34, 3, 9, 4, 2, 3, 4, 5",
                "output": "1,2,3,3,4,4,4,5,9,34"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function sortStack(stack) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function sortStack(stack) {\n    const orderStack = [];\n    while (stack.length > 0) {\n        let temp = stack.pop();\n        while (orderStack.length > 0 && temp > orderStack[orderStack.length - 1]) {\n            stack.push(orderStack.pop());\n        }\n        orderStack.push(temp);\n    }\n    while (orderStack.length > 0) stack.push(orderStack.pop());\n    return stack;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[1, 4, 34, 3, 9, 4, 7, 5, 12, 8]],
                "test_expected": [1, 3, 4, 4, 5, 7, 8, 9, 12, 34],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[1, 9, 9, 9, 9, 9, 1, 1, 1]],
                "test_expected": [1, 1, 1, 1, 9, 9, 9, 9, 9],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[1, 4, 34, 3, 9, 4, 2, 3, 4, 5]],
                "test_expected": [1, 2, 3, 3, 4, 4, 4, 5, 9, 34],
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "animalShelter": {
        "refName": "animalShelter",
        "refNumber": 58,
        "category": "Stacks & Queues",
        "difficulty": "Easy",
        "title": "Animal Shelter",
        "tags": ["Easy", "Stacks & Queues"],
        "description": "<p>An animal shelter, which holds only dogs and cats, operates on a strictly 'first in, first out' basis.</p><p>People must adopt either the 'oldest' (based on arrival time) of all animals at the shelter, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type).</p><p>They cannot select which specific animal they would like. Create the data structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog, and dequeueCat. You may use the built-in Linked list data structure.</p>",
        "examples": {
            "example1": {
                "input": "str1 = 'geeks'\nstr2 = 'geek'",
                "output": "true"
            },
            "example2": {
                "input": "str1 = 'peaks'\nstr2 = 'geeks'",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "class AnimalShelter {\n  // Write your solution...\n}"
        },
        "solutionCode": {
            "javaScript": [
                "class AnimalShelter  {\n    constructor() {\n        this.dogs = [];\n        this.cats = [];\n        this._id = 0;\n    }\n    enqueueCat(value) {\n        this.cats.push({\n            name: value,\n            id: ++this._id,\n        })\n    }\n    encueueDog(value) {\n        this.dogs.push({\n            name: value,\n            id: ++this._id,\n        })\n    }\n    dequeue() {\n        const idDog = this.dogs.length > 0 ? this.dogs[0].id : Number.POSITIVE_INFINITY;\n        const idCat = this.cats.length > 0 ? this.cats[0].id : Number.POSITIVE_INFINITY;\n        if (idDog !== undefined && idCat !== undefined) {\n            return idCat < idDog ? this.cats.shift().name : this.dogs.shift().name\n        }\n    }\n    dequeueDog() {\n        return this.dogs.shift().name;\n    }\n    dequeueCat() {\n        return this.cats.shift().name;\n    }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["geeks", "geek"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["book", "books"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["demon", "dem"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "RemoveDuplicatesInLinkedList": {
        "refName": "RemoveDuplicatesInLinkedList",
        "refNumber": 59,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Remove Duplicates In Linked List",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Write a removeDuplicatesLinkedList() function that takes the Head of a likned list and deletes any duplicate nodes from the list.</p>",
        "examples": {
            "example1": {
                "input": "1 -> 2 -> 3 -> 2 -> 4 -> 1 -> 5",
                "output": "1 -> 2 -> 3 -> 4 -> 5"
            },
            "example2": {
                "input": "5 -> 2 -> 3 -> 3 -> 4 -> 1 -> 5",
                "output": "5 -> 2 -> 3 -> 4 -> 1 -> 5"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function removeDuplicatesLinkedList(head) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function removeDuplicatesLinkedList(head) {\n    const list = new Set();\n    let currentList = head;\n    let prevList = null;\n    while (currentList) {\n        if (!list.has(currentList.data)) {\n            list.add(currentList.data);\n            prevList = currentList;\n            currentList = currentList.next;\n        } else {\n            let elem = currentList;\n            prevList.next = currentList.next;\n            currentList = currentList.next;\n            elem.next = null;\n        }\n    }\n    return head;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(2); const c = new Node(3); const d = new Node(2); const e = new Node(4); const f = new Node(1); const g = new Node(5); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; f.next = g; const val = window.removeDuplicatesLinkedList(a); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return arr; }",
                "test_expected": [1, 2, 3, 4, 5],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(3); const c = new Node(4); const d = new Node(7); const e = new Node(7); const f = new Node(2); const g = new Node(1); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; f.next = g; const val = window.removeDuplicatesLinkedList(a); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return arr; }",
                "test_expected": [1, 3, 4, 7, 2],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(1); const c = new Node(1); const d = new Node(2); const e = new Node(2); const f = new Node(2); const g = new Node(2); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; f.next = g; const val = window.removeDuplicatesLinkedList(a); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return arr; }",
                "test_expected": [1, 2],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(1); const c = new Node(4); const d = new Node(8); const e = new Node(9); const f = new Node(24); const g = new Node(4); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; f.next = g; const val = window.removeDuplicatesLinkedList(a); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return arr; }",
                "test_expected": [1, 4, 8, 9, 24],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const val = window.removeDuplicatesLinkedList(a); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return arr; }",
                "test_expected": [1],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_6": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(1); a.next = b; const val = window.removeDuplicatesLinkedList(a); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return arr; }",
                "test_expected": [1],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "findKTH": {
        "refName": "findKTH",
        "refNumber": 60,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Find KTH",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Write a findKTH() function that takes a linked list and an integer index and returns the data value stored in the node at that index position.</p>",
        "examples": {
            "example1": {
                "input": "Input: 1->10->30->14\nindex = 2",
                "output": "Output: 30\nThe node at index 2 is 30"
            },
            "example2": {
                "input": "Input: 1 -> 7 -> 230 -> 134\nindex = 3",
                "output": "Output: 7\nThe node at index 3 is 7"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function findKTH(linkedList, n) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function findKTH(head, index) {\n    let currentNode = head;\n    let counter = 0;\n    while (currentNode !== null) {\n        counter++;\n        currentNode = currentNode.next;\n    }\n    let nodeIndex = counter - index;\n    currentNode = head;\n    for (let i =0; i<nodeIndex; i++) {\n        currentNode = currentNode.next;\n    }\n    return currentNode.data;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(10); const c = new Node(30); const d = new Node(14); a.next = b; b.next = c; c.next = d; const val = window.findKTH(a, 2); return val }",
                "test_expected": 30,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(1); const c = new Node(4); const d = new Node(8); const e = new Node(9); const f = new Node(24); const g = new Node(4); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; f.next = g; const val = window.findKTH(a, 5); return val; }",
                "test_expected": 4,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(1); const c = new Node(4); const d = new Node(8); const e = new Node(9); const f = new Node(24); const g = new Node(4); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; f.next = g; const val = window.findKTH(a, 1); return val }",
                "test_expected": 4,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "partition": {
        "refName": "partition",
        "refNumber": 61,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Partition",
        "tags": ["medium", "Linked List"],
        "description": "<p>Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater than or equal to x.</p><p>If x is contained within the list, the values of x only need to be after the elements less than x. The partition element x can appear anywhere in the 'right partition'; it does not need to appear between the left and right partitions.</p>",
        "examples": {
            "example1": {
                "input": "list = 5 -> 3 -> 34 -> 1 -> 32 -> 7 -> 99\nX = 10",
                "output": "34 -> 32 -> 99 -> 5 -> 3 -> 1 -> 7 5 -> 3 -> 34 -> 1 -> 32 -> 7 -> 99"
            },
            "example2": {
                "input": "list = 5 -> 3 -> 94 -> 1 -> 82 -> 7 -> 59, X = 50",
                "output": "94 -> 82 -> 59 -> 5 -> 3 -> 1 -> 7"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function partition(linkedList, num) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time complexity : O(n).\n// Space complexity : O(1).\nfunction partition(head, num) {\n    class Node {\n        constructor(data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    const l1 = new Node(0);\n    const l2 = new Node(0);\n    let currentNodeL1 = l1;\n    let currentNodeL2 = l2;\n    let currentNode = head;\n    while (currentNode !== null) {\n        if (currentNode.data < num) {\n            currentNodeL1.next = currentNode;\n            currentNodeL1 = currentNodeL1.next;\n        } else {\n            currentNodeL2.next = currentNode;\n            currentNodeL2 = currentNodeL2.next;\n        }\n        currentNode = currentNode.next;\n    }\n    currentNodeL1.next = l2.next;\n    currentNodeL2.next = null;\n    return l1.next;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(5); const b = new Node(3); const c = new Node(34); const d = new Node(1); const e = new Node(32); const f = new Node(7); const g = new Node(99); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; f.next = g; window.partition(a, 10); let arr = []; let cur = a; while (cur) { arr.push(cur.data); cur = cur.next; } return arr }",
                "test_expected": [5, 3, 1, 7, 34, 32, 99],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "sumLinkedLists": {
        "refName": "sumLinkedLists",
        "refNumber": 62,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Sum LinkedLists",
        "tags": ["Medium", "Linked List"],
        "description": "<p>Write a function, sumLinkedLists, that takes in the head of two linked lists, each representing a number. The nodes of the linked lists contain digits as values. The nodes in the input lists are reversed; this means that the least significant digit of the number is the head. The function should return the head of a new linked listed representing the sum of the input lists. The output list should have its digits reversed as well.</p>",
        "examples": {
            "example1": {
                "input": "L1 = 5->6->3\nL2 = 8->4->2",
                "output": "1->4->0->5"
            },
            "example2": {
                "input": "L1 = 0\nL2 = 0",
                "output": "0"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function sumLinkedLists(l1, l2) {\n  // Write your solution...\n  function ListNode(data, next) {\n    this.data = data;\n    this.next = next;\n  }\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time complexity : O(max(m,n)).\n// Space complexity : O(max(m,n)).\nfunction sumLinkedLists(l1, l2) {\n  function ListNode(data, next) {\n    this.data = data;\n    this.next = next;\n  }\n  let rootNode = new ListNode(0);\n  let node = rootNode;\n  let sum = 0;\n  let carry = 0;\n  while (l1 || l2 || sum > 0) {\n    if (l1) {\n      sum += l1.data;\n      l1 = l1.next;\n    }\n    if (l2) {\n      sum += l2.data;\n      l2 = l2.next;\n    }\n    carry = Math.floor(sum / 10);\n    sum = Math.floor(sum) % 10;\n    node.next = new ListNode(sum);\n    node = node.next;\n    sum = carry;\n    carry = 0;\n  }\n  return rootNode.next;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(3); const b = new Node(6); const c = new Node(5); a.next = b; b.next = c; const d = new Node(2); const e = new Node(4); const f = new Node(8); d.next = e; e.next = f; const val = window.sumLinkedLists(a, d); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' L1 = 5->6->3 L2 = 8->4->2 ', arr] }",
                "test_expected": [5, 0, 4, 1],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(2); const b = new Node(4); const c = new Node(3); a.next = b; b.next = c; const d = new Node(5); const e = new Node(6); const f = new Node(4); d.next = e; e.next = f; const val = window.sumLinkedLists(a, d); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return ['', arr] }",
                "test_expected": [7, 0, 8],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a1 = new Node(1); const a2 = new Node(2); const a3 = new Node(6); a1.next = a2; a2.next = a3; const b1 = new Node(4); const b2 = new Node(5); const b3 = new Node(3); b1.next = b2; b2.next = b3; const val = window.sumLinkedLists(a1, b1); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' l1 = 1 -> 2 -> 6; l2 = 4 -> 5 -> 3', arr]; }",
                "test_expected": [5, 7, 9],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "findBeginning": {
        "refName": "findBeginning",
        "refNumber": 63,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Find Beginning",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Floyd's cycle-finding algorithm</p><p>Given a circular linked list, implement an algorithm that returns the node at the beginning of the loop.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. If there is no cycle, return null.</p><p>Note: Do not modify the linked list.</p><p>Follow up: Can you solve it without using extra space?</p>",
        "examples": {
            "example1": {
                "input": "",
                "output": ""
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function findBeginning(head) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time complexity : O(n).\n// Space complexity : O(n).\nfunction findBeginning(head) {\n    const list = new Set();\n    let node = head;\n    while (node) {\n        if (!list.has(node)) {\n            list.add(node);\n            node = node.next;\n        } else {\n            return node;\n        }\n    }\n}\n// Floyd's cycle-finding algorithm\n// Time complexity : O(n).\n// Space complexity : O(1).\nfunction findBeginning(head) {\n  var slow = head;\n  var fast = head;\n  var entry = head;\n  while (slow && fast) {\n    slow = slow.next;\n    fast = fast.next ? fast.next.next : undefined;\n    if (slow === fast) {\n      while (entry !== slow) {\n        entry = entry.next;\n        slow = slow.next;\n      }\n      return entry;\n    }\n  }\n  return null;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(2); const b = new Node(4); const c = new Node(3); const d = new Node(5); const e = new Node(6); const f = new Node(23); const g = new Node(12); const h = new Node(9); const i = new Node(8); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; f.next = g; g.next = h; h.next = i; i.next = e; const val = window.findBeginning(a); return ['a>b>c>d>e>f>g>h>i>e', val.data] }",
                "test_expected": 6,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "reverseLinkedList": {
        "refName": "reverseLinkedList",
        "refNumber": 64,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Reverse Linked List",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>",
        "examples": {
            "example1": {
                "input": "head = [1,2,3,4,5]",
                "output": "[5,4,3,2,1]"
            },
            "example2": {
                "input": "head = [1,2]",
                "output": "[2,1]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function reverseLinkedList(head) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time complexity : O(n).\n// Space complexity : O(1).\nfunction reverseLinkedList(head) {\n    let currentNode = head;\n    let prevNode = null;\n    while (currentNode !== null) {\n        const temp = currentNode.next;\n        currentNode.next = prevNode;\n        prevNode = currentNode;\n        currentNode = temp;\n    }\n    return prevNode;\n}\n// Time complexity : O(n).\n// Space complexity : O(n).\nfunction reverseLinkedList(head) {\n  return reverse(null, head);\n};\nvar reverse = function (newHead, head) {\n  if (!head) return newHead;\n  var tmp = head.next;\n  head.next = newHead;\n  return reverse(head, tmp);\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(2); const b = new Node(4); const c = new Node(3); const d = new Node(5); const e = new Node(6); a.next = b; b.next = c; c.next = d; d.next = e; const val = window.reverseLinkedList(a); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return ['2>4>3>5>6', arr]; }",
                "test_expected": [6, 5, 3, 4, 2],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "swapNodesInPairs": {
        "refName": "swapNodesInPairs",
        "refNumber": 65,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Swap Nodes In Pairs",
        "tags": ["Medium", "Linked List"],
        "description": "<p>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)</p>",
        "examples": {
            "example1": {
                "input": "1->2->3->4",
                "output": "[2->1->4->3"
            },
            "example2": {
                "input": "head = []",
                "output": "[]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function swapNodesInPairs(head) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time complexity : O(n).\n// Space complexity : O(1).\nfunction swapNodesInPairs(head) {\n    class Node {\n        constructor(data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    var out = new Node(0);\n    var now = out;\n    out.next = head;\n    while (now.next && now.next.next) {\n        now = swap(now, now.next, now.next.next);\n    }\n    return out.next;\n};\nvar swap = function (a, b, c) {\n    a.next = c;\n    b.next = c.next;\n    c.next = b;\n    return b;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(2); const c = new Node(6); const d = new Node(4); const e = new Node(5); const f = new Node(3); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; const val = window.swapNodesInPairs(a); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' 1>2>6>4>5>3', arr]; }",
                "test_expected": [2, 1, 4, 6, 3, 5],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "rotateList": {
        "refName": "rotateList",
        "refNumber": 66,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Rotate List",
        "tags": ["Medium", "Linked List"],
        "description": "<p>Given the head of a linked list, rotate the list to the right by k places.</p>",
        "examples": {
            "example1": {
                "input": "head = [1,2,3,4,5]\nk = 2",
                "output": "4->5->1->2->3"
            },
            "example2": {
                "input": "head = [0,1,2]\nk = 4",
                "output": "2->0->1"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function rotateList(head, k) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time complexity : O(n).\n// Space complexity : O(1).\nfunction rotateList(head, k) {\n    var count = 1;\n    var last = head;\n    var now = head;\n    if (!head || !head.next) return head;\n    while (last.next) {\n        last = last.next;\n        count++;\n    }\n    k %= count;\n    if (k === 0) return head;\n    while (k < count - 1) {\n        now = now.next;\n        k++;\n    }\n    last.next = head;\n    head = now.next;\n    now.next = null;\n    return head;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(2); const c = new Node(3); const d = new Node(4); const e = new Node(5); const f = new Node(6); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; const val = window.rotateList(a, 2); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' 1>2>3>4>5>6', arr]; }",
                "test_expected": [5, 6, 1, 2, 3, 4],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "RemoveDuplicatesInLinkedList2": {
        "refName": "RemoveDuplicatesInLinkedList2",
        "refNumber": 67,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Remove Duplicates In Linked List 2",
        "tags": ["Medium", "Linked List"],
        "description": "<p>Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.</p>",
        "examples": {
            "example1": {
                "input": "head = [1,2,3,3,4,4,5]",
                "output": "1->2->5"
            },
            "example2": {
                "input": "head = [1,1,1,2,3]",
                "output": "2->3"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function removeDuplicatesInLinkedList2(head) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function removeDuplicatesInLinkedList2(head) {\n    class Node {\n        constructor(data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    var newHead = new Node(0);\n    var now = newHead;\n    var tmp = head;\n    var val = 0;\n    while (tmp) {\n        val = tmp.data;\n        if (tmp.next && tmp.next.data === val) {\n            tmp = tmp.next;\n            while (tmp && tmp.data === val) tmp = tmp.next;\n        } else {\n            now.next = tmp;\n            now = tmp;\n            tmp = tmp.next;\n            now.next = null;\n        }\n    }\n    return newHead.next;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(2); const c = new Node(3); const d = new Node(3); const e = new Node(4); const f = new Node(4); const g = new Node(5); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; f.next = g; const val = window.removeDuplicatesInLinkedList2(a); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' 1>2>2>3>4>4>5', arr]; }",
                "test_expected": [1, 2, 5],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "partitionList": {
        "refName": "partitionList",
        "refNumber": 68,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Partition List",
        "tags": ["Medium", "Linked List"],
        "description": "<p>Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p>",
        "examples": {
            "example1": {
                "input": "head = [1,4,3,2,5,2]\nx = 3",
                "output": "[1,2,2,4,3,5]"
            },
            "example2": {
                "input": "head = [2,1]\nx = 2",
                "output": "[1, 2]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function partitionList(head, x) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function partitionList(head, x) {\n    class Node {\n        constructor(data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    var l1 = new Node(0);\n    var l2 = new Node(0);\n    var now1 = l1;\n    var now2 = l2;\n    var now = head;\n    while (now) {\n        if (now.data < x) {\n            now1.next = now;\n            now1 = now1.next;\n        } else {\n            now2.next = now;\n            now2 = now2.next;\n        }\n        now = now.next;\n    }\n    now1.next = l2.next;\n    now2.next = null;\n    return l1.next;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(4); const c = new Node(3); const d = new Node(2); const e = new Node(5); const f = new Node(2); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; const val = window.partitionList(a, 3); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' 1>4>3>2>5>2', arr]; }",
                "test_expected": [1, 2, 2, 4, 3, 5],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "ReverseLinkedList2": {
        "refName": "ReverseLinkedList2",
        "refNumber": 69,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Reverse Linked List 2",
        "tags": ["Medium", "Linked List"],
        "description": "<p>Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.</p>",
        "examples": {
            "example1": {
                "input": "head = [1,2,3,4,5]\nleft = 2\nright = 4",
                "output": "[1,4,3,2,5]"
            },
            "example2": {
                "input": "head = [5]\nleft = 1\nright = 1",
                "output": "[5]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function reverseLinkedList2(head, m, n) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time complexity : O(n).\n// Space complexity : O(1).\nfunction reverseLinkedList2(head, m, n) {\n    class Node {\n        constructor(data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    var newHead = new Node(0);\n    var now = newHead;\n    var tmp = null;\n    var reverseLast = null;\n    var reverseHead = null;\n    var reverseNow = null;\n    var i = 0;\n    newHead.next = head;\n    while (now) {\n        tmp = now.next;\n        if (i === m - 1) {\n            reverseHead = now;\n        }\n        if (i === m) {\n            reverseLast = now;\n            reverseNow = now;\n        }\n        if (i > m && i <= n) {\n            now.next = reverseNow;\n            reverseNow = now;\n        }\n        if (i === n) {\n            reverseLast.next = tmp;\n            reverseHead.next = reverseNow;\n        }\n        now = tmp;\n        i++;\n    }\n    return newHead.next;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(2); const c = new Node(3); const d = new Node(4); const e = new Node(5); a.next = b; b.next = c; c.next = d; d.next = e; const val = window.reverseLinkedList2(a, 2, 4); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' 1>2>3>4>5', arr]; }",
                "test_expected": [1, 4, 3, 2, 5],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "ConvertListToBinarySearchTree": {
        "refName": "ConvertListToBinarySearchTree",
        "refNumber": 70,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Convert List To Binary Search Tree",
        "tags": ["Medium", "Linked List"],
        "description": "<p>Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>",
        "examples": {
            "example1": {
                "input": "hhead = [-10,-3,0,5,9]",
                "output": "[0,-3,9,-10,null,5]\nExplanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.\n      0\n     / \\n   -3   9\n   /   /\n -10  5"
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function convertListToBinarySearchTree(head) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nfunction convertListToBinarySearchTree(head) {\n  return helper(head, null);\n};\nvar helper = function (head, foot) {\n  var fast = head;\n  var slow = head;\n  var node = null;\n  if (head === foot) return null;\n  while (fast !== foot && fast.next !== foot) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  node = new TreeNode(slow.val);\n  node.left = helper(head, slow);\n  node.right = helper(slow.next, foot);\n  return node;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["geeks", "geek"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["book", "books"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["demon", "dem"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "reorderList": {
        "refName": "reorderList",
        "refNumber": 71,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Reorder List",
        "tags": ["Medium", "Linked List"],
        "description": "<p>You are given the head of a singly linked-list. The list can be represented as:</p><p>L0 → L1 → … → Ln - 1 → Ln</p><p>Reorder the list to be on the following form:</p><p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</p><p>You may not modify the values in the list's nodes. Only nodes themselves may be changed.</p>",
        "examples": {
            "example1": {
                "input": "head = [1,2,3,4]",
                "output": "[1,4,2,3]"
            },
            "example2": {
                "input": "head = [1,2,3,4,5]",
                "output": "[1,5,2,4,3]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function reorderList(head) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {void} Do not return anything, modify head in-place instead.\n */\n// Time complexity : O(n).\n// Space complexity : O(1).\nfunction reorderList(head) {\n  if (!head || !head.next || !head.next.next) return;\n  // find mid\n  var mid = null;\n  var fast = head;\n  var slow = head;\n  while (fast.next && fast.next.next && slow.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  mid = slow;\n  // reverse the later part\n  var now = mid.next.next;\n  var second = mid.next;\n  var tmp = null;\n  second.next = null;\n  while (now) {\n    tmp = now.next;\n    now.next = second;\n    second = now;\n    now = tmp;\n  }\n  mid.next = second;\n  // insert one after another\n  var before = head;\n  var after = mid.next;\n  mid.next = null;\n  while (after) {\n    tmp = before.next;\n    before.next = after;\n    before = tmp;\n    tmp = after.next;\n    after.next = before;\n    after = tmp\n  }\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["geeks", "geek"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["book", "books"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["demon", "dem"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "InsertionSortList": {
        "refName": "InsertionSortList",
        "refNumber": 72,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Insertion Sort List",
        "tags": ["Medium", "Linked List"],
        "description": "<p>Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.</p><p>The steps of the insertion sort algorithm:</p><p>Insertion sort iterates, consuming one input element each repetition and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there. It repeats until no input elements remain. The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.</p><img src='https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif' alt='Image'>",
        "examples": {
            "example1": {
                "input": "head = [4,2,1,3]",
                "output": "[1,2,3,4]"
            },
            "example2": {
                "input": "head = [-1,5,3,4,0]",
                "output": "[-1,0,3,4,5]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function insertionSortList(head) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n// Time complexity : O(n^2).\n// Space complexity : O(1).\nfunction insertionSortList(head) {\n  var newHead = new ListNode(0);\n  var now = head;\n  var next = null;\n  var tmp = null;\n  while (now) {\n    next = now.next;\n    tmp = newHead;\n    while (tmp.next && tmp.next.val < now.val) {\n      tmp = tmp.next;\n    }\n    now.next = tmp.next;\n    tmp.next = now;\n    now = next;\n  }\n  return newHead.next;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["geeks", "geek"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["book", "books"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["demon", "dem"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "sortList": {
        "refName": "sortList",
        "refNumber": 73,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Sort List",
        "tags": ["Medium", "Linked List"],
        "description": "<p>Given the head of a linked list, return the list after sorting it in ascending order.</p><p>Sort a linked list in O(n log n) time using constant space complexity.</p>",
        "examples": {
            "example1": {
                "input": "4->2->1->3",
                "output": "1->2->3->4"
            },
            "example2": {
                "input": "-1->5->3->4->0",
                "output": "-1->0->3->4->5"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function sortList(head) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nfunction sortList(head) {\n  if (!head || !head.next) return head;\n  var slow = head;\n  var fast = head;\n  var prev = null;\n  while (fast && fast.next) {\n    prev = slow;\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  prev.next = null;\n  return merge(sortList(head), sortList(slow));\n};\nvar merge = function (list1, list2) {\n  var p1 = list1;\n  var p2 = list2;\n  var newHead = new ListNode(0);\n  var now = newHead;\n  while (p1 || p2) {\n    if (!p1 || !p2) {\n      now.next = p1 || p2;\n      break;\n    } else if (p1.val < p2.val) {\n      now.next = p1;\n      p1 = p1.next;\n    } else {\n      now.next = p2;\n      p2 = p2.next;\n    }\n    now = now.next;\n    now.next = null;\n  }\n  return newHead.next;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["geeks", "geek"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["book", "books"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["demon", "dem"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "CreateLinkedList": {
        "refName": "CreateLinkedList",
        "refNumber": 74,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Create Linked List",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Write a function, createLinkedList, that takes in an array of values as an argument. The function should create a linked list containing each element of the array as the values of the nodes. The function should return the head of the linked list.</p>",
        "examples": {
            "example1": {
                "input": "arr = ['h', 'e', 'y']",
                "output": "h -> e -> y"
            },
            "example2": {
                "input": "arr = [1, 7, 1, 8]",
                "output": "1 -> 7 -> 1 -> 8"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "class Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\nfunction createLinkedList(values) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// ITERATIVE\n// n = length of values\n// Time: O(n)\n// Space: O(n)\nfunction createLinkedList(values) {\n  const dummyHead = new Node(null);\n  let tail = dummyHead;\n  for (let val of values) {\n    tail.next = new Node(val);\n    tail = tail.next;\n  }\n  return dummyHead.next;\n};\n// RECURSIVE\n// n = length of values\n// Time: O(n)\n// Space: O(n)\nfunction createLinkedList(values, i = 0) {\n  if (i === values.length) return null;\n  const head = new Node(values[i]);\n  head.next = createLinkedList(values, i + 1);\n  return head;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { const val = window.createLinkedList(['h', 'e', 'y']); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [ `['h', 'e','y']`, arr]; }",
                "test_expected": ["h", "e", "y"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { const val = window.createLinkedList([1, 7, 1, 8]); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' [1, 7, 1, 8]', arr]; }",
                "test_expected": [1, 7, 1, 8],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { const val = window.createLinkedList(['a']); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [` ['a']`, arr]; }",
                "test_expected": ["a"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { const val = window.createLinkedList([]); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' []', arr]; }",
                "test_expected": [],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "deleteMiddleNode": {
        "refName": "deleteMiddleNode",
        "refNumber": 75,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Delete Middle Node",
        "tags": ["Medium", "Linked List"],
        "description": "<p>You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.</p><p>The middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.</p><p>For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.</p>",
        "examples": {
            "example1": {
                "input": "head = [1,3,4,7,1,2,6]",
                "output": "Output: [1,3,4,1,2,6]\nn = 7, node 3 with value 7 is the middle node. We return the new list after removing this node."
            },
            "example2": {
                "input": "head = [1,2,3,4]",
                "output": "Output: [1,2,4]\nThe above figure represents the given linked list. For n = 4, node 2 with value 3 is the middle node."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function deleteMiddleNode(head) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time Complexity: O(n)\n// Space: O(1)\nfunction deleteMiddleNode(head) {\n    if (head == null) return null;\n    if (head.next == null) return null;\n    // Initialize slow and fast pointers\n    // to reach middle of linked list\n    var slow_ptr = head;\n    var fast_ptr = head;\n    // Find the middle and previous of \n    // middle.\n    var prev = null;\n    // To store previous of slow_ptr\n    while (fast_ptr != null && fast_ptr.next != null) {\n        fast_ptr = fast_ptr.next.next;\n        prev = slow_ptr;\n        slow_ptr = slow_ptr.next;\n    }\n    // Delete the middle node\n    prev.next = slow_ptr.next;\n    return head;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(1); const b = new Node(3); const c = new Node(4); const d = new Node(7); const e = new Node(1); const f = new Node(2); const g = new Node(6); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; f.next = g; const val = window.deleteMiddleNode(a); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return ['1>3>4>7>1>2>6', arr]; }",
                "test_expected": [1, 3, 4, 1, 2, 6],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        }
    },
    "wordBreak": {
        "refName": "wordBreak",
        "refNumber": 76,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Word Break",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.</p><p>Note that the same word in the dictionary may be reused multiple times in the segmentation.</p>",
        "examples": {
            "example1": {
                "input": "s = 'leetcode'\nwordDict = ['leet','code']",
                "output": "true\nExplanation: Return true because 'leetcode' can be segmented as 'leet code'."
            },
            "example2": {
                "input": "s = 'applepenapple', wordDict = ['apple','pen']",
                "output": "true\nExplanation: Return true because 'applepenapple' can be segmented as 'apple pen apple'. Note that you are allowed to reuse a dictionary word."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function wordBreak(s, wordDict) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Time complexity : O(n^2).\n// Space complexity : O(n^2).\nfunction wordBreak(s, wordDict) {\n    var len = wordDict.length;\n    var dp = Array(len);\n    var map = {};\n    for (var i = 0; i < len; i++) {\n        map[wordDict[i]] = true;\n    }\n    return find(s, map, dp, 0);\n};\nvar find = function (s, map, dp, index) {\n    if (dp[index] !== undefined) return dp[index];\n    var str = '';\n    var res = false;\n    var len = s.length;\n    if (index === len) return true;\n    for (var i = index; i < len; i++) {\n        str = s.substring(index, i + 1);\n        if (map[str] && find(s, map, dp, i + 1)) {\n        res = true;\n        break;\n        }\n    }\n    dp[index] = res;\n    return res;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["leetcode", ["leet", "code"]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["applepenapple", ["apple", "pen"]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["demon", "dem"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["leetcodeleet", ["leet"]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["catsandog", ["cats", "dog", "sand", "and", "cat"]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["cars", ["car", "ca", "rs"]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "fibonacci": {
        "refName": "fibonacci",
        "refNumber": 77,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Fibonacci",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function fibonacci that takes in a number argument, n, and returns the n-th number of the Fibonacci sequence.</p><ul><li>The 0-th number of the sequence is 0.</li><li>The 1-st number of the sequence is 1.</li></ul><p>To generate further numbers of the sequence, calculate the sum of previous two numbers.</p>",
        "examples": {
            "example1": {
                "input": "1",
                "output": "1"
            },
            "example2": {
                "input": "35",
                "output": "9227465"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function fibonacci(n) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// BRUTE-FORCE\n// Time: O(2^n)\n// Space: O(n)\nfunction fibonacci(n) {\n  if (n === 0 || n === 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n// memoized (pass)\n// Time: O(n)\n// Space: O(n)\nfunction fibonacci(n, memo = {}) {\n  if (n === 0 || n === 1) return n;\n  if (n in memo) return memo[n];\n  memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n  return memo[n];\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [0],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [1],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [2],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [3],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [4],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [5],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [35],
                "test_expected": 9227465,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [46],
                "test_expected": 1836311903,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "nonAdjacentSum": {
        "refName": "nonAdjacentSum",
        "refNumber": 78,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Non Adjacent Sum",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function, nonAdjacentSum, that takes in an array of numbers as an argument. The function should return the maximum sum of non-adjacent elements in the array. There is no limit on how many elements can be taken into the sum as long as they are not adjacent.</p>",
        "examples": {
            "example1": {
                "input": "nums = [2, 4, 5, 12, 7]",
                "output": "16\nThe maximum non-adjacent sum is 16, because 4 + 12. 4 and 12 are not adjacent in the array."
            },
            "example2": {
                "input": "nums = [7, 5, 5, 12];",
                "output": "19"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function nonAdjacentSum(nums, i = 0, memo = {}) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of nums\n// Time: O(n)\n// Space: O(n)\nfunction nonAdjacentSum(nums, i = 0, memo = {}) {\n  if (i in memo) return memo[i];\n  if (i >= nums.length) return 0;\n  const include = nums[i] + nonAdjacentSum(nums, i + 2, memo);\n  const exclude = nonAdjacentSum(nums, i + 1, memo);\n  memo[i] = Math.max(include, exclude);\n  return memo[i];\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[2, 4, 5, 12, 7]],
                "test_expected": 16,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[7, 5, 5, 12]],
                "test_expected": 19,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[7, 5, 5, 12, 17, 29]],
                "test_expected": 48,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        72, 62, 10, 6, 20, 19, 42, 46, 24, 78, 30, 41, 75, 38, 23, 28, 66, 55, 12, 17, 9, 12, 3, 1, 19,
                        30, 50, 20
                    ]
                ],
                "test_expected": 488,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    [
                        72, 62, 10, 6, 20, 19, 42, 46, 24, 78, 30, 41, 75, 38, 23, 28, 66, 55, 12, 17, 83, 80, 56, 68,
                        6, 22, 56, 96, 77, 98, 61, 20, 0, 76, 53, 74, 8, 22, 92, 37, 30, 41, 75, 38, 23, 28, 66, 55, 12,
                        17, 72, 62, 10, 6, 20, 19, 42, 46, 24, 78, 42
                    ]
                ],
                "test_expected": 1465,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "deepEquals": {
        "refName": "deepEquals",
        "refNumber": 79,
        "category": "Recursion",
        "difficulty": "Easy",
        "title": "deepEquals",
        "tags": ["Easy", "Recursion"],
        "description": "<p>Write a function, deepEqual, that takes two values and returns true only if they are the same value or are objects with the same properties whose values are also equal when compared with a recursive call to deepEqual.</p>",
        "examples": {
            "example1": {
                "input": "val1 = 2\n val2 = 2",
                "output": "true"
            },
            "example2": {
                "input": "val1 = 'df'\n val2 = 2",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function deepEquals(val1, val2) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function deepEquals(valueOne, valueTwo) {\n   if (typeof valueOne !== 'object' && typeof valueTwo !== 'object') {\n      const isValueOneNaN = isNaN(valueOne) && typeof valueOne === 'number';\n      const isValueTwoNaN = isNaN(valueTwo) && typeof valueTwo === 'number';\n      if (isValueOneNaN && isValueTwoNaN) return true;\n      return valueOne === valueTwo;\n   }\n   if (typeof valueOne !== typeof valueTwo) return false;\n   if (valueOne === null && valueTwo === null) return true;\n   if (valueOne === null || valueTwo === null) return false;\n   if (valueOne === valueTwo) return true;\n   if (Array.isArray(valueOne) && Array.isArray(valueTwo)) {\n      if (valueOne.length !== valueTwo.length) return false;\n      for (let i = 0; i < valueOne.length; i++) {\n         if (!deepEquals(valueOne[i], valueTwo[i])) return false;\n      }\n      return true;\n   }\n   if (Array.isArray(valueOne) || Array.isArray(valueTwo)) return false;\n   const valueOneKeys = Object.keys(valueOne);\n   const valueTwoKeys = Object.keys(valueTwo);\n   if (valueOneKeys.length !== valueTwoKeys.length) return false;\n   for (let i = 0; i < valueOneKeys.length; i++) {\n      const key = valueOneKeys[i];\n      const valueOneValue = valueOne[key];\n      const valueTwoValue = valueTwo[key];\n      if (!deepEquals(valueOneValue, valueTwoValue)) return false;\n   }\n   return true;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [1, 1],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["a", "a"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["NaN", "NaN"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[], []],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [[1], [1]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    [
                        [1, 2],
                        [3, 4]
                    ],
                    [
                        [1, 2],
                        [3, 4]
                    ]
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [{}, {}],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [
                    {
                        "a": 1
                    },
                    {
                        "a": 1
                    }
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_9": {
                "test_input": [
                    {
                        "a": 1,
                        "obj": {
                            "b": 2
                        }
                    },
                    {
                        "a": 1,
                        "obj": {
                            "b": 2
                        }
                    }
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_10": {
                "test_input": [null, null],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_11": {
                "test_input": ["undefined", "undefined"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_12": {
                "test_input": [1, 0],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_13": {
                "test_input": ["a", "b"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_14": {
                "test_input": ["NaN", 10],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_15": {
                "test_input": ["str", "NaN"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_16": {
                "test_input": [[], [1]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_17": {
                "test_input": [[10], [1]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_18": {
                "test_input": [
                    [
                        [1, 2, 3],
                        [4, 5]
                    ],
                    [
                        [1, 2, 3],
                        [6, 7]
                    ]
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_19": {
                "test_input": [
                    {
                        "a": 1
                    },
                    {}
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_20": {
                "test_input": [
                    {
                        "a": 1
                    },
                    {
                        "b": 2
                    }
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_21": {
                "test_input": [
                    {
                        "a": "undefined",
                        "b": 2
                    },
                    {
                        "b": 2,
                        "c": 3
                    }
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "deepCloneObject": {
        "refName": "deepCloneObject",
        "refNumber": 80,
        "category": "Recursion",
        "difficulty": "Easy",
        "title": "Deep Clone Object",
        "tags": ["Easy", "Recursion"],
        "description": "<p>Creates a deep clone of an object. Clones primitives, arrays and objects, excluding class instances.</p><ul><li>Use recursion.</li><li>Check if the passed object is null and, if so, return null.</li><li>Use Object.assign() and an empty object ({}) to create a shallow clone of the original.</li><li>Use Object.keys() and Array.prototype.forEach() to determine which key-value pairs need to be deep cloned.</li><li>If the object is an Array, set the clone's length to that of the original and use Array.from() to create a clone.</li></ul>",
        "examples": {
            "example1": {
                "input": "a = { foo: 'bar', obj: { a: 1, b: 2 } }",
                "output": "{ foo: 'bar', obj: { a: 1, b: 2 } }"
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function deepCloneObject(obj) {\n   // Write your solution...\n   return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function deepCloneObject(obj) {\n   if (obj === null) return null;\n   let clone = Object.assign({}, obj);\n   Object.keys(clone).forEach(\n      key =>\n      (clone[key] =\n         typeof obj[key] === 'object' ? deepCloneObject(obj[key]) : obj[key])\n   );\n   if (Array.isArray(obj)) {\n      clone.length = obj.length;\n      return Array.from(clone);\n   }\n   return clone;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "foo": "bar",
                        "obj": {
                            "a": 1,
                            "b": 2
                        }
                    }
                ],
                "test_expected": {
                    "foo": "bar",
                    "obj": {
                        "a": 1,
                        "b": 2
                    }
                },
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "updateObject": {
        "refName": "updateObject",
        "refNumber": 81,
        "category": "Stacks & Queues",
        "difficulty": "Easy",
        "title": "Update Object",
        "tags": ["Easy", "Stacks & Queues"],
        "description": "<p>Giving an object a value and a path, return the input object with the passed value at the passed path</p>",
        "examples": {
            "example1": {
                "input": "obj = { foo: 'bar', obj: { a: 1, b: 2 } }\nnewVal = 25\npath = 'obj.b'",
                "output": "{ foo: 'bar', obj: { a: 1, b: 25 } }"
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function updateObject(obj, newValue, path) {\n   // Write your solution...\n   return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function updateObject(object, newValue, path) {\n   const stack = path.split('.')\n   while (stack.length > 1) {\n      object = object[stack.shift()]\n   }\n   object[stack.shift()] = newValue\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "foo": "bar",
                        "obj": {
                            "a": 1,
                            "b": 2
                        }
                    },
                    25,
                    "obj.b"
                ],
                "test_expected": {
                    "foo": "bar",
                    "obj": {
                        "a": 1,
                        "b": 25
                    }
                },
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "arrayMethods": {
        "refName": "arrayMethods",
        "refNumber": 82,
        "category": "javascript",
        "difficulty": "Easy",
        "title": "Array Methods",
        "tags": ["Easy", "javascript"],
        "description": "<p>Without calling Array.prototype.map(), Array.prototype.filter(), Array.prototype.reduce(), or Array.prototype.forEach(), implement the following three similar functions on the Array prototype:</p> <p>1. myMap(callback)</p> <p>Without mutating the original array, this function should call the passed callback function on every element of the array and return a new array containing the results of all these calls, in the corresponding order.</p> <p>The callback function can take in up to three parameters:</p> <ol> <li>The current value in the array.</li> <li>The current index in the array.</li> <li>The array itself.</li> </ol> <p>2. myFilter(callback)</p> <p>Without mutating the original array, this function should call the passed callback function on every element of the array and return a new array containing the values of the original array that, when passed to the callback function, returned true. These values should maintain their original order.</p> <p>The callback function takes in the same arguments as the ones that the callback function in myMap takes in.</p> <p>3. myReduce(callback, initialValue)</p> <p>Without mutating the original array, this function should call the passed callback function on every element of the array and return the result of the last call to the callback.</p> <p>The callback function can take in up to four parameters: The accumulator, which is the return value of the previous call to the callback. On the first call to the callback, the accumulator should be set to the initialValue. If the initialValue is undefined, then it should be set to the first value of the array, and the callback should skip the first element in the array and be called directly on the second element.</p> <ol> <li>The current value in the array.</li> <li>The current index in the array.</li> <li>The array itself.</li> </ol>    <p>If the array contains no elements, the initialValue should be returned. Note that this differs slightly from the Array.prototype.reduce function.</p>",
        "examples": {
            "example1": {
                "input": "const array = [1, 2, 3];\nconst mappedArray = array.myMap((value, i, arr) => {\n  return value + i + arr[1];\n});\nconst filteredArray = array.myFilter((value, i, arr) => {\n  return (value + i + arr[1]) > 5;\n});\nconst reducedValue = array.myReduce((accumulator, value, i, arr) => {\n  return accumulator + value + i + arr[1];\n}, 3);\nconsole.log(mappedArray);\nconsole.log(filteredArray);\nconsole.log(reducedValue);",
                "output": "// Console logs:\n[3, 5, 7] // From myMap.\n[3] // From myFilter.\n18 // From myReduce."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "Array.prototype.myMap = function (callback) {\n  // Write your code here.\n};\nArray.prototype.myFilter = function (callback) {\n  // Write your code here.\n};\nArray.prototype.myReduce = function (callback, initialValue) {\n  // Write your code here.\n};"
        },
        "solutionCode": {
            "javaScript": [
                "// Implementación de la función map\nfunction map(array, callback) {\n  var newArray = [];\n  for (var i = 0; i < array.length; i++) {\n    newArray.push(callback(array[i], i, array));\n  }\n  return newArray;\n}\n// Implementación de la función filter\nfunction filter(array, callback) {\n  var newArray = [];\n  for (var i = 0; i < array.length; i++) {\n    if (callback(array[i], i, array)) {\n      newArray.push(array[i]);\n    }\n  }\n  return newArray;\n}\n// Implementación de la función reduce\nfunction reduce(array, callback, initialValue) {\n  var accumulator = initialValue !== undefined ? initialValue : array[0];\n  var i = initialValue !== undefined ? 0 : 1;\n  while (i < array.length) {\n    accumulator = callback(accumulator, array[i], i, array);\n    i++;\n  }\n  return accumulator;\n}\n// Implementación de la función forEach\nfunction forEach(array, callback) {\n  for (var i = 0; i < array.length; i++) {\n    callback(array[i], i, array);\n  }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "foo": "bar",
                        "obj": {
                            "a": 1,
                            "b": 2
                        }
                    },
                    25,
                    "obj.b"
                ],
                "test_expected": {
                    "foo": "bar",
                    "obj": {
                        "a": 1,
                        "b": 25
                    }
                },
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "eventTarget": {
        "refName": "eventTarget",
        "refNumber": 83,
        "category": "javascript",
        "difficulty": "Easy",
        "title": "Event Target",
        "tags": ["Easy", "javascript"],
        "description": "<p>Implement an EventTarget class that has the following methods:</p>\n  <p>addEventListener(type, callback): Adds an EventListener for the specified event type.</p>\n    <p>removeEventListener(type, callback): Removes an EventListener for the specified event type.</p>\n    <p>dispatchEvent(event): Dispatches the specified event and executes all EventListeners associated with it.</p>",
        "examples": {
            "example1": {
                "input": "const array = [1, 2, 3];\nconst mappedArray = array.myMap((value, i, arr) => {\n  return value + i + arr[1];\n});\nconst filteredArray = array.myFilter((value, i, arr) => {\n  return (value + i + arr[1]) > 5;\n});\nconst reducedValue = array.myReduce((accumulator, value, i, arr) => {\n  return accumulator + value + i + arr[1];\n}, 3);\nconsole.log(mappedArray);\nconsole.log(filteredArray);\nconsole.log(reducedValue);",
                "output": "// Console logs:\n[3, 5, 7] // From myMap.\n[3] // From myFilter.\n18 // From myReduce."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "class EventTarget {\n  addEventListener(type, callback) {\n  }\n  removeEventListener(type, callback) {\n  }\n  dispatchEvent(event) {\n  }\n}"
        },
        "solutionCode": {
            "javaScript": [
                "class EventTarget {\n  constructor() {\n    this.listeners = new Map();\n  }\n  addEventListener(type, callback) {\n    if (!this.listeners.has(type)) {\n      this.listeners.set(type, []);\n    }\n    this.listeners.get(type).push(callback);\n  }\n  removeEventListener(type, callback) {\n    if (this.listeners.has(type)) {\n      const callbacks = this.listeners.get(type);\n      const index = callbacks.indexOf(callback);\n      if (index !== -1) {\n        callbacks.splice(index, 1);\n      }\n    }\n  }\n  dispatchEvent(event) {\n    if (this.listeners.has(event.type)) {\n      const callbacks = this.listeners.get(event.type);\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](event);\n      }\n    }\n  }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "foo": "bar",
                        "obj": {
                            "a": 1,
                            "b": 2
                        }
                    },
                    25,
                    "obj.b"
                ],
                "test_expected": {
                    "foo": "bar",
                    "obj": {
                        "a": 1,
                        "b": 25
                    }
                },
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "thisBainding": {
        "refName": "thisBainding",
        "refNumber": 84,
        "category": "javascript",
        "difficulty": "Easy",
        "title": "this Bainding",
        "tags": ["Easy", "javascript"],
        "description": "<div class='html'><p> Without calling <span>Function.prototype.call</span>, <span>Function.prototype.apply</span> or <span>Function.prototype.bind</span>, implement the following three similar functions on the <span>Function</span> prototype: </p> <ol> <li> <p><span>myCall(thisContext, ...args)</span></p> <p> <span>myCall</span> should call the original function with <span>thisContext</span> bound to the function's <span>this</span> keyword, passing all of the remaining <span>args</span> as individual arguments to the function. </p> <p> The return value of the original function should be returned by <span>myCall</span>. </p> </li> <li> <p><span>myApply(thisContext, args)</span></p> <p> <span>myApply</span> should call the original function with <span>thisContext</span> bound to the function's <span>this</span> keyword, passing all of the values in the <span>args</span> array as individual arguments to the function. </p> <p> The return value of the original function should be returned by <span>myApply</span>. </p> </li> <li> <p><span>myBind(thisContext, ...args)</span></p> <p> <span>myBind</span> should return a new function that calls the original function with <span>thisContext</span> bound to the function's <span>this</span> keyword, passing all of the remaining <span>args</span> as individual arguments to the function. The new function should accept optional arguments, which should also be passed to the original function, after the <span>args</span> originally passed to <span>myBind</span>. </p> <p> The new function should return the return value of the original function. </p> </li> </ol> <p> You can assume that the <span>thisContext</span> argument passed to each function will always be an object. When binding this object to the <span>this</span> keyword, the original object should be bound, not a clone. You can also assume that the original function will be declared using standard function syntax (i.e., it won't be an arrow function). </p> <p> You should minimize side-effects as much as possible, ensuring that <span>thisContext</span> remains unchanged after calls to these functions and ensuring that standard iteration through properties on <span>thisContext</span> works normally. </p> <p></p> <h3>Sample Usage</h3> </div>",
        "examples": {
            "example1": {
                "input": "const obj = {num: 0};\nfunction logNums(x, y) {\nconsole.log(this.num, x, y);\n}\nlogNums.myCall(obj, 1, 2);\nlogNums.myApply(obj, [1, 2]);\nconst boundFunction = logNums.myBind(obj, 1);\nboundFunction(2);",
                "output": "// Console logs:\n0 1 2 // From myCall.\n0 1 2 // From myApply.\n0 1 2 // From myBind."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "Function.prototype.myCall = function (thisContext, ...args) {\n// Write your code here.\n};\nFunction.prototype.myApply = function (thisContext, args = []) {\n// Write your code here.\n};\nFunction.prototype.myBind = function (thisContext, ...args) {\n// Write your code here.\n};"
        },
        "solutionCode": {
            "javaScript": [
                "// Define myCall on Function.prototype\nFunction.prototype.myCall = function(thisContext, ...args) {\n// Save the original function to a variable\nconst originalFunction = this;\n\n// Call the original function with thisContext bound to the function's this keyword, passing all of the remaining args as individual arguments to the function\nreturn originalFunction.apply(thisContext, args);\n};\n// Define myApply on Function.prototype\nFunction.prototype.myApply = function(thisContext, args) {\n// Save the original function to a variable\nconst originalFunction = this;\n// Call the original function with thisContext bound to the function's this keyword, passing all of the values in the args array as individual arguments to the function\nreturn originalFunction.apply(thisContext, args);\n};\n// Define myBind on Function.prototype\nFunction.prototype.myBind = function(thisContext, ...args) {\n// Save the original function to a variable\nconst originalFunction = this;\n// Return a new function that calls the original function with thisContext bound to the function's this keyword, passing all of the remaining args as individual arguments to the function. The new function should accept optional arguments, which should also be passed to the original function, after the args originally passed to myBind.\nreturn function(...newArgs) {\nreturn originalFunction.apply(thisContext, args.concat(newArgs));\n};\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "foo": "bar",
                        "obj": {
                            "a": 1,
                            "b": 2
                        }
                    },
                    25,
                    "obj.b"
                ],
                "test_expected": {
                    "foo": "bar",
                    "obj": {
                        "a": 1,
                        "b": 25
                    }
                },
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "throttle": {
        "refName": "throttle",
        "refNumber": 85,
        "category": "javascript",
        "difficulty": "Easy",
        "title": "throttle",
        "tags": ["Easy", "javascript"],
        "description": "<p>You are tasked with implementing a throttle function that takes a function as its first argument and a delay time (in milliseconds) as its second argument. The throttle function should return a new function that can be called repeatedly, but ensures that the original function is only executed once per delay time interval.</p>  <p>Requirements</p> <ol><li>The <code>throttle</code> function should return a new function that can be called repeatedly.</li><li>The new function should call the original function at most once per delay time interval.</li><li>If the new function is called again before the delay time interval has passed, it should not call the original function again.</li><li>The new function should pass any arguments it receives to the original function when it is called.</li></ol> <p>Tips</p> <p>Here are some tips that may help you implement the throttle function:</p> <ol><li>You will need to use the <code>setTimeout</code> function to delay the execution of the original function.</li><li>You will need to use closure to store the state of the throttle function between calls.</li><li>You may find it helpful to use the <code>Date.now()</code> function to keep track of the time since the last call to the original function.</li></ol>",
        "examples": {
            "example1": {
                "input": "function logMessage() {\nconsole.log('Message logged!');\n}\nconst throttledLogMessage = throttle(logMessage, 1000);\n// Call the throttled function repeatedly\nsetInterval(throttledLogMessage, 500);",
                "output": "In this example, the logMessage function is throttled to only execute once per second, even though it is called every half-second in the setInterval loop."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function throttle(func, delay) {\n// Implementation goes here\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function throttle(func, delay) {\nlet lastCallTime = 0;\nlet timerId = null;\nreturn function(...args) {\nconst now = Date.now();\nif (now - lastCallTime >= delay) {\nlastCallTime = now;\nfunc.apply(this, args);\n} else if (!timerId) {\ntimerId = setTimeout(() => {\nlastCallTime = Date.now();\nfunc.apply(this, args);\ntimerId = null;\n}, delay - (now - lastCallTime));\n}\n};\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "foo": "bar",
                        "obj": {
                            "a": 1,
                            "b": 2
                        }
                    },
                    25,
                    "obj.b"
                ],
                "test_expected": {
                    "foo": "bar",
                    "obj": {
                        "a": 1,
                        "b": 25
                    }
                },
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "promiseMethods": {
        "refName": "promiseMethods",
        "refNumber": 86,
        "category": "javascript",
        "difficulty": "Easy",
        "title": "Promise Methods",
        "tags": ["Easy", "javascript"],
        "description": "<div> <p> Without calling <span>Promise.race()</span>, <span>Promise.any()</span>, <span>Promise.all()</span>, <span>Promise.allSettled()</span>, implement the following four similar functions on the native <span>Promise</span> object: </p> <ol> <li> <span>myRace(promises)</span>: Takes in an array of Promises and returns a new Promise. This new Promise should resolve or reject as soon as any Promise in the array resolves or rejects, with the value from that settled Promise. </li> <li> <span>myAny(promises)</span>: Takes in an array of Promises and returns a new Promise. This new Promise should resolve as soon as any Promise in the array resolves, with the value from that resolved Promise. If every Promise in the array rejects, the new Promise should reject with the string 'all promises rejected'. </li> <li> <span>myAll(promises)</span>: Takes in an array of Promises and returns a new Promise. This new Promise should resolve as soon as every Promise in the array resolves, with an array of the values from those resolved Promises. This array should be in the same order as they were passed to <span>myAll</span> (not in the order they resolved). If any Promise in the array rejects, the new Promise should immediately be rejected with that value. </li> <li> <span>myAllSettled(promises)</span>: Takes in an array of Promises and returns a new Promise. This new Promise should resolve as soon as every Promise in the array settles, with an array of objects detailing the results of each Promise. Each of these objects should have a 'status' key set to either 'fulfilled' or 'rejected', based on the state of the Promise. If the Promise was fulfilled, there should also be a 'value' key set to the value from that resolved Promise. If the Promise was rejected, there should be an 'error' key set to the error the Promise was rejected with. This array should be in the same order as they were passed to <span>myAllSettled</span> (not in the order they resolved). </li> </ol> <p> For simplicity, you can assume the arrays of Promises passed to these functions will never be empty. </p></div>",
        "examples": {
            "example1": {
                "input": "Promise.myRace([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.resolve(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log).catch((error) => console.log('error: ' + error));\nPromise.myRace([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.reject(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log).catch((error) => console.log('error: ' + error));\nPromise.myAny([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.resolve(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log);\nPromise.myAny([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.reject(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log).catch((error) => console.log('error: ' + error));\nPromise.myAll([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.resolve(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log);\nPromise.myAll([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.reject(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log).catch((error) => console.log('error: ' + error));\nPromise.myAllSettled([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.resolve(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log);\nPromise.myAllSettled([\n  new Promise(res => setTimeout(() => res(0), 500)),\n  Promise.reject(5),\n  new Promise(res => setTimeout(() => res(10), 1000)),\n]).then(console.log).catch((error) => console.log('error: ' + error));",
                "output": "// Console logs:\n5 // From myRace.\nerror: 5 // From myRace.\n5 // From myAny.\n0 // From myAny.\n[0, 5, 10] // From myAll after 1 second.\nerror: 5 // From myAll.\n[\n  {status: 'fulfilled', value: 0},\n  {status: 'fulfilled', value: 5},\n  {status: 'fulfilled', value: 10,\n] // From myAllSettled after 1 second.\n[\n  {status: 'fulfilled', value: 0},\n  {status: 'rejected', error: 5}, \n  {status: 'fulfilled', value: 10,\n] // From myAllSettled after 1 second."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "Promise.myRace = function (promises) {\n  // Write your code here.\n};\nPromise.myAny = function (promises) {\n  // Write your code here.\n};\nPromise.myAll = function (promises) {\n  // Write your code here.\n};\nPromise.myAllSettled = function (promises) {\n  // Write your code here.\n};"
        },
        "solutionCode": {
            "javaScript": [
                "Promise.myRace = function (promises) {\n  return new Promise((resolve, reject) => {\n    for (const promise of promises) {\n      promise.then(resolve).catch(reject);\n    }\n  });\n}\nPromise.myAny = function (promises) {\n  return new Promise((resolve, reject) => {\n    let rejectedCount = 0;\n    for (const promise of promises) {\n      promise.then(resolve).catch(() => {\n        rejectedCount++;\n        if (rejectedCount === promises.length) {\n          reject('all promises rejected');\n        }\n      });\n    }\n  });\n}\nPromise.myAll = function (promises) {\n  return new Promise((resolve, reject) => {\n    const result = new Array(promises.length);\n    let resolvedCount = 0;\n    for (let i = 0; i < promises.length; i++) {\n      promises[i]\n        .then(value => {\n          result[i] = value;\n          resolvedCount++;\n          if (resolvedCount === promises.length) {\n            resolve(result);\n          }\n        })\n        .catch(reject);\n    }\n  });\n}\nPromise.myAllSettled = function (promises) {\n  return new Promise(resolve => {\n    const result = new Array(promises.length);\n    let settledCount = 0;\n    for (let i = 0; i < promises.length; i++) {\n      promises[i]\n        .then(value => {\n          result[i] = { status: 'fulfilled', value };\n          settledCount++;\n          if (settledCount === promises.length) {\n            resolve(result);\n          }\n        })\n        .catch(error => {\n          result[i] = { status: 'rejected', error };\n          settledCount++;\n          if (settledCount === promises.length) {\n            resolve(result);\n          }\n        });\n    }\n  });\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "foo": "bar",
                        "obj": {
                            "a": 1,
                            "b": 2
                        }
                    },
                    25,
                    "obj.b"
                ],
                "test_expected": {
                    "foo": "bar",
                    "obj": {
                        "a": 1,
                        "b": 25
                    }
                },
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "promises": {
        "refName": "promises",
        "refNumber": 87,
        "category": "javascript",
        "difficulty": "Easy",
        "title": "Promises",
        "tags": ["Easy", "javascript"],
        "description": "<div> <p> Write a <span>MyPromise</span> class based on the native <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise'>Promise</a> built-in class. </p> <p> An instance of the <span>MyPromise</span> class will always have one of three states: <span>'pending'</span>, <span>'fulfilled'</span>, or <span>'rejected'</span>. This state should be accessible through the <span>state</span> getter method. </p> <p> When a <span>MyPromise</span> is in the fulfilled or rejected state, it will have a value which should be accessible through the <span>value</span> getter method. A pending promise should always have the value of <span>null</span>. </p> <p> The <span>MyPromise</span> constructor takes in an executor function, which takes two callbacks: <span>resolve</span> and <span>reject</span>. This executor function should run immediately. Both of the callbacks passed to the executor function take in a value, which when called will set the value of the <span>MyPromise</span> as well as update the state based on which callback was called (<span>resolve</span> sets it to fulfilled, while <span>reject</span> sets it to rejected). If the executor function throws an error, the <span>MyPromise</span> should be rejected with the error value. For simplicity, you can assume only one of these callbacks will ever be called, and it will never be called more than once. </p> <p> An instance of the <span>MyPromise</span> class should have two public methods: <span>then</span> and <span>catch</span> with the following functionality: </p> <ul> <li> <span>then(onFulfilled, onRejected)</span>: Runs one of the callbacks after the <span>MyPromise</span> has settled. If the <span>MyPromise</span> is fulfilled, the value should be passed to the <span>onFulfilled</span> callback. If the <span>MyPromise</span> is rejected, the value should be passed to the <span>onRejected</span> callback. The <span>then</span> method should return a new <span>MyPromise</span> that resolves to the value as returned by either <span>onFulfilled</span> or <span>onRejected</span>. If either <span>onFulfilled</span> or <span>onRejected</span> throws an error, the returned <span>MyPromise</span> should be rejected with that error value. </li> <li> <span>catch(onRejected)</span>: Runs the <span>onRejected</span> callback after the <span>MyPromise</span> has been rejected. The value should be passed to the <span>onRejected</span> callback. The <span>catch</span> method should return a new <span>MyPromise</span> that resolves to the value returned by <span>onRejected</span>. If <span>onRejected</span> throws an error, the returned <span>MyPromise</span> should be rejected with that error value. </li> </ul> <p> Both <span>then</span> and <span>catch</span> return new <span>MyPromise</span> objects, meaning these methods should be chainable with the next call in the chain not running until the previous call completes. None of these callbacks should run until all other code in the call stack completes (i.e. they should be treated as microtasks by the event loop). </p> <p> If multiple calls to <span>then</span> and/or <span>catch</span> are made on the same <span>MyPromise</span>, their callback functions should be invoked in the order that <span>then</span> and <span>catch</span> were called (see sample usage #2). </p> <p> All of the callback functions to <span>then</span> and <span>catch</span> are optional. If the required callback is not passed, a new <span>MyPromise</span> should be returned with the previous value and state. </p> <p> Your code should not use the native <span>Promise</span> object in any way. </p> <h3>Sample Usage #1</h3> </div>",
        "examples": {
            "example1": {
                "input": "const promise = new MyPromise((res, rej) => {\n  res(10);\n});\npromise.then(val => {\n  console.log(val);\n  return val + 10;\n}).then(val => {\n  console.log(val);\n  throw val + 10;\n}).then(val => {\n  console.log(val);\n  return val + 10;\n}, val => {\n  console.log('error: ' + val);\n  return val + 20;\n}).then(val => {\n  console.log(val);\n  throw val + 10;\n}).catch(val => {\n  console.log('error: ' + val);\n  return val + 10;\n}).then(val => {\n  console.log(val);\n});\nconsole.log('end'); // this line runs before the then/catch chain.",
                "output": "// Console logs:\nend\n10\n20 error: 30\n50\nerror: 60\n70"
            },
            "example2": {
                "input": "const promise = new MyPromise((res, rej) => {\nres(10);\n});\npromise.then(val => {\nconsole.log(val + 10);\nreturn val + 10;\n});\npromise.then(val => {\nconsole.log(val + 5);\nreturn val + 5;\n});\nconsole.log('end'); // this line runs before the then/catch chain.",
                "output": "// Console logs:\nend\n20\n15"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "class MyPromise {\n  // Write your code here.\n  constructor(executorFunc) {\n    // Write your code here.\n  }\n  then(onFulfilled, onRejected) {\n    // Write your code here.\n  }\n  catch(onRejected) {\n    // Write your code here.\n  }\n  get state() {\n    // Write your code here.\n  }\n  get value() {\n    // Write your code here.\n  }\n}\n// Do not edit the line below.\nexports.MyPromise = MyPromise;"
        },
        "solutionCode": {
            "javaScript": [
                "class MyPromise {\n  constructor(executor) {\n    this.state = 'pending';\n    this.value = null;\n    this.onFulfilledCallbacks = [];\n    this.onRejectedCallbacks = [];\n    const resolve = (value) => {\n      if (this.state !== 'pending') return;\n      this.state = 'fulfilled';\n      this.value = value;\n      this.onFulfilledCallbacks.forEach(cb => cb(value));\n    };\n    const reject = (reason) => {\n      if (this.state !== 'pending') return;\n      this.state = 'rejected';\n      this.value = reason;\n      this.onRejectedCallbacks.forEach(cb => cb(reason));\n    };\n    try {\n      executor(resolve, reject);\n    } catch (error) {\n      reject(error);\n    }\n  }\n  then(onFulfilled, onRejected) {\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };\n    const promise = new MyPromise((resolve, reject) => {\n      const fulfilledCallback = (value) => {\n        try {\n          const newValue = onFulfilled(value);\n          resolve(newValue);\n        } catch (error) {\n          reject(error);\n        }\n      };\n      const rejectedCallback = (reason) => {\n        try {\n          const newValue = onRejected(reason);\n          resolve(newValue);\n        } catch (error) {\n          reject(error);\n        }\n      };\n      if (this.state === 'pending') {\n        this.onFulfilledCallbacks.push(fulfilledCallback);\n        this.onRejectedCallbacks.push(rejectedCallback);\n      } else if (this.state === 'fulfilled') {\n        setTimeout(() => {\n          fulfilledCallback(this.value);\n        }, 0);\n      } else if (this.state === 'rejected') {\n        setTimeout(() => {\n          rejectedCallback(this.value);\n        }, 0);\n      }\n    });\n    return promise;\n  }\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n  get state() {\n    return this._state;\n  }\n  set state(newState) {\n    if (newState !== 'pending' && newState !== 'fulfilled' && newState !== 'rejected') {\n      throw new Error('Invalid state');\n    }\n    this._state = newState;\n  }\n  get value() {\n    return this._value;\n  }\n  set value(newValue) {\n    this._value = newValue;\n  }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "foo": "bar",
                        "obj": {
                            "a": 1,
                            "b": 2
                        }
                    },
                    25,
                    "obj.b"
                ],
                "test_expected": {
                    "foo": "bar",
                    "obj": {
                        "a": 1,
                        "b": 25
                    }
                },
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "memoize": {
        "refName": "memoize",
        "refNumber": 88,
        "category": "javascript",
        "difficulty": "Easy",
        "title": "Memoize",
        "tags": ["Easy", "javascript"],
        "description": "<div> <p> Write a <span>memoize</span> function that takes in a required <span>callback</span> function and an optional <span>resolver</span> function. The <span>memoize</span> function returns a memoized version of the <span>callback</span> function, which is defined as follows: </p> <ul> <li> All of the return values of the memoized function are cached. If the memoized callback is called with an existing cache key (defined below), then that cached value is returned without invoking the <span>callback</span> again. </li> <li> The cache key is defined based on the optional <span>resolver</span> function. If a <span>resolver</span> function is not provided, then the cache key is the result of passing the memoized function arguments to <span>JSON.stringify</span> as an array. If a custom <span>resolver</span> function is provided, then the arguments should be individually passed to that function instead, and its return value will be the cache key (note that this can be of any type). </li> <li> The memoized function should also have three methods: <ul> <li><span>clear()</span>: Clears out the cache.</li> <li> <span>delete(...args)</span>: Deletes the cache entry corresponding to the passed arguments if one exists. </li> <li> <span>has(...args)</span>: Returns a boolean of true if the cache has an entry corresponding to the passed arguments, otherwise false. </li> </ul> </li> </ul> <p> For simplicity, you don't need to worry about binding a <span>this</span> context (i.e., you can assume that the <span>callback</span> doesn't reference <span>this</span>). </p> </div>",
        "examples": {
            "example1": {
                "input": "const callback = (...args) => args;\nconst memoized = memoize(callback);\nmemoized(123); // calls callback, returns 123\nmemoized(123); // returns 123\nmemoized(123, 'abc'); // calls callback, returns [123, 'abc']\nconst memoized2 = memoize(callback, args => args[0]);\nmemoized2(123); // calls callback, returns 123\nmemoized2(123); // returns 123\nmemoized2(123, 'abc'); // returns 123\nmemoized2('abc', 123); // calls callback, returns ['abc', 123]\nmemoized2('abc'); // returns ['abc', 123]",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function memoize(callback, resolver) {\n  // Write your code here.\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function memoize(callback, resolver = JSON.stringify) {\n  const cache = new Map();\n  const memoized = function (...args) {\n    const key = resolver(...args);\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    const result = callback.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n  memoized.clear = function () {\n    cache.clear();\n  };\n  memoized.delete = function (...args) {\n    const key = resolver(...args);\n    return cache.delete(key);\n  };\n  memoized.has = function (...args) {\n    const key = resolver(...args);\n    return cache.has(key);\n  };\n  return memoized;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "foo": "bar",
                        "obj": {
                            "a": 1,
                            "b": 2
                        }
                    },
                    25,
                    "obj.b"
                ],
                "test_expected": {
                    "foo": "bar",
                    "obj": {
                        "a": 1,
                        "b": 25
                    }
                },
                "code_output": null,
                "passed_test": false
            }
        }
    },
    "createDOM": {
        "refName": "createDOM",
        "refNumber": 89,
        "category": "javascript",
        "difficulty": "Easy",
        "title": "create DOM",
        "tags": ["Easy", "javascript"],
        "description": "<div> <p> Write a <span>createDom</span> function that takes in a required root parameter, which is an object representation of a DOM tree's root node or a string representation of a text node. </p> <p> If the root parameter is an object, then a DOM <a href='https://developer.mozilla.org/en-US/docs/Web/API/Element'> Element node </a> is returned. This object will have one required property: <span>type</span>, which corresponds to the tag name of the element being created (e.g. 'div'), as well as two optional properties: <span>children</span> and <span>attributes</span>. If <span>children</span> exists, it will be an array of objects in the same format as the root parameter. Each value in this array will be a child of the returned node, in the order of the array. Additionally, if a child is a string instead of an object, then that string should be used as text content. If <span>attributes</span> exists, it will be an object, with each key corresponding to an attribute name and each value corresponding to an attribute value. These attributes are each attributes of the node. </p> <h3>Sample Usage</h3> </div>",
        "examples": {
            "example1": {
                "input": "createDom({\n  type: 'input',\n  attributes: {\n    class: 'my-input',\n    type: 'password',\n    placeholder: 'type your password',\n  },\n}); // <input class='my-input' type='password' placeholder='type your password' />\ncreateDom({\n  type: 'p',\n  children: [\n    'Hello ',\n    {\n      type: 'strong',\n      children: ['World']\n    },\n  ]\n}); // <p>Hello <strong>World</strong></p>",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function createDom(root) {\n  // Write your code here.\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function createDom(root) {\n  if (typeof root === 'string') {\n    return document.createTextNode(root);\n  }\n  const element = document.createElement(root.type);\n  if (root.children && root.children.length > 0) {\n    root.children.forEach(child => {\n      if (typeof child === 'string') {\n        element.appendChild(document.createTextNode(child));\n      } else {\n        element.appendChild(createDom(child));\n      }\n    });\n  }\n  if (root.attributes) {\n    Object.keys(root.attributes).forEach(key => {\n      element.setAttribute(key, root.attributes[key]);\n    });\n  }\n  return element;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "foo": "bar",
                        "obj": {
                            "a": 1,
                            "b": 2
                        }
                    },
                    25,
                    "obj.b"
                ],
                "test_expected": {
                    "foo": "bar",
                    "obj": {
                        "a": 1,
                        "b": 25
                    }
                },
                "code_output": null,
                "passed_test": false
            }
        }
    }
}
