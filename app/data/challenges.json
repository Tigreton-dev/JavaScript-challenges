{
    "uncompress": {
        "refName": "uncompress",
        "refNumber": 1,
        "category": "String",
        "difficulty": "Easy",
        "title": "Uncompress",
        "tags": ["Easy", "String"],
        "description": "<p>Write a function, uncompress, that takes in a string as an argument. The input string will be formatted into multiple groups according to the following pattern:</p><p><number><char></p><p>for example, '2c' or '3a'.</p><p>The function should return an uncompressed version of the string where each 'char' of a group is repeated 'number' times consecutively. You may assume that the input string is well-formed according to the previously mentioned pattern.</p>",
        "examples": {
            "example1": {
                "input": "str = '2c3a1t';",
                "output": "'ccaaat'"
            },
            "example2": {
                "input": "str = '4s2b';",
                "output": "'ssssbb'"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function uncompress(s) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// solution 1\nfunction uncompress(s) {\n    const numbers = '0123456789';\n    const result = [];\n    let p1 = 0;\n    let p2 = 0;\n    while (p2 <= s.length) {\n        if (numbers.includes(s[p2])) {\n            p2++;\n        } else {\n            const val = Number(s.slice(p1, p2));\n            for (let x = 0; x < val; x++) {\n                result.push(s[p2]);\n            }\n            p2++;\n            p1 = p2;\n        }\n    }\n    return result.join('')\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["2c3a1t"],
                "test_expected": "ccaaat",
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["4s2b"],
                "test_expected": "ssssbb",
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["2p1o5p"],
                "test_expected": "ppoppppp",
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["3n12e2z"],
                "test_expected": "nnneeeeeeeeeeeezz",
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["127y"],
                "test_expected": "yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy",
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "mostFrequentChar": {
        "refName": "mostFrequentChar",
        "refNumber": 2,
        "category": "String",
        "difficulty": "Easy",
        "title": "Most Frequent Char",
        "tags": ["Easy", "String"],
        "description": "<p>Write a function, mostFrequentChar, that takes in a string as an argument. The function should return the most frequent character of the string. If there are ties, return the character that appears earlier in the string.</p><p>You can assume that the input string is non-empty.</p>",
        "examples": {
            "example1": {
                "input": "str = 'bookeeper';",
                "output": "'e'"
            },
            "example2": {
                "input": "str = 'david';",
                "output": "'d'"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function mostFrequentChar(s) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// solution 1\n// n = length of string\n// Time: O(n)\n// Space: O(n)\nfunction mostFrequentChar(s) {\n    const list = new Map();\n    for (const char of s) {\n        if (list.has(char)) {\n            const val = list.get(char);\n            list.set(char, val + 1);\n        } else {\n            list.set(char, 1);\n        }\n    }\n    let best = null;\n    for (const char of s) {\n        if (best === null || list.get(char) > list.get(best)) {\n            best = char;\n        }\n    }\n    return best;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["bookeeper"],
                "test_expected": "e",
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["david"],
                "test_expected": "d",
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["abby"],
                "test_expected": "b",
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["mississippi"],
                "test_expected": "i",
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["potato"],
                "test_expected": "o",
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["eleventennine"],
                "test_expected": "e",
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": ["riverbed"],
                "test_expected": "r",
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "pairSum": {
        "refName": "pairSum",
        "refNumber": 3,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Pair Sum",
        "tags": ["Easy", "Array"],
        "description": "<p>Write a function, pairSum, that takes in an array and a target sum as arguments. The function should return an array containing a pair of indices whose elements sum to the given target. The indices returned must be unique.</p><p>Be sure to return the indices, not the elements themselves.</p><p>There is guaranteed to be one such pair that sums to the target.</p>",
        "examples": {
            "example1": {
                "input": "numbers = [3, 2, 5, 4, 1]\ntargetSum = 8",
                "output": "[0, 2]"
            },
            "example2": {
                "input": "numbers = [4, 7, 9, 2, 5, 1]\ntargetSum = 5",
                "output": "[0, 5]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function pairSum(numbers, targetSum) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of array\n// Time: O(n)\n// Space: O(n)\nfunction pairSum(numbers, targetSum) {\n   const previousNums = {};\n   for (let i = 0; i < numbers.length; i += 1) {\n      const num = numbers[i];\n      const complement = targetSum - num;\n      if (complement in previousNums) return [i, previousNums[complement]];\n      previousNums[num] = i;\n   }\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[3, 2, 5, 4, 1], 8],
                "test_expected": [0, 2],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[4, 7, 9, 2, 5, 1], 5],
                "test_expected": [0, 5],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[4, 7, 9, 2, 5, 1], 3],
                "test_expected": [3, 5],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[1, 6, 7, 2], 13],
                "test_expected": [1, 2],
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [[9, 9], 18],
                "test_expected": [0, 1],
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [[6, 4, 2, 8], 12],
                "test_expected": [1, 3],
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "intersection": {
        "refName": "intersection",
        "refNumber": 4,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Intersection",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Given two (singly) linked lists, determine if the two lists intersect.</p><p>Return the intersecting node. Note that the intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact same node (by reference) as the jth node of the second linked list, then they are intersecting.</p>",
        "examples": {
            "example1": {
                "input": "listA = [4,1,8,4,5]\nlistB = [5,6,1,8,4,5]",
                "output": "8"
            },
            "example2": {
                "input": "listA = [1,9,1,2,4]\nlistB = [3,2,4]",
                "output": "2"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function intersection(l1, l2) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function intersection(headA, headB) {\n  if (!headA || !headB) return null;  \n  var nowA = headA;\n  var nowB = headB;\n  while (nowA !== nowB) {\n    nowA = nowA ? nowA.next : headB;\n    nowB = nowB ? nowB.next : headA;\n  }\n  return nowA;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; }}var a = new Node('a');var b = new Node('b');var c = new Node('c');var d = new Node('d');var e = new Node('e');var f = new Node('f');var g = new Node('g');var h = new Node('h');a.next = b;b.next = c;c.next = d;d.next = e;e.next = f;f.next = g;g.next = h;var a1 = new Node('a1');var b1 = new Node('b1');var c1 = new Node('c1');a1.next = b1;b1.next = c1;c1.next = d; const val = window.intersection(a, a1); return ['l1= a->b->c->d->f->g->h  l2= a1->b1->c1->d', val.data];}",
                "test_expected": "d",
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "fiveSort": {
        "refName": "fiveSort",
        "refNumber": 5,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Five Sort",
        "tags": ["Easy", "Array"],
        "description": "<p>Write a function, fiveSort, that takes in an array of numbers as an argument. The function should rearrange elements of the array such that all 5s appear at the end. Your function should perform this operation in-place by mutating the original array. The function should return the array.</p><p>Elements that are not 5 can appear in any order in the output, as long as all 5s are at the end of the array.</p>",
        "examples": {
            "example1": {
                "input": "arr1 = [12, 5, 1, 5, 12, 7]",
                "output": "[12, 7, 1, 12, 5, 5]"
            },
            "example2": {
                "input": "arr1 = [5, 2, 5, 6, 5, 1, 10, 2, 5, 5]",
                "output": "[2, 2, 10, 6, 1, 5, 5, 5, 5, 5]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function fiveSort(nums) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = array size\n// Time: O(n)\n// Space: O(1)\nfunction fiveSort(nums) {\n  let p1 = 0;\n  let p2 = nums.length - 1;\n  while(p1 < p2) {\n    if (nums[p2] === 5) {\n      p2--;\n    } else if(nums[p1] === 5) {\n      [nums[p1], nums[p2]] = [nums[p2], nums[p1]];\n      p1++;\n    }else {\n      p1++;\n    }\n  }\n  \n  return nums\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[12, 5, 1, 5, 12, 7]],
                "test_expected": [12, 7, 1, 12, 5, 5],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[5, 5, 6, 5, 5, 5, 5]],
                "test_expected": [6, 5, 5, 5, 5, 5, 5],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[5, 1, 2, 5, 5, 3, 2, 5, 1, 5, 5, 5, 4, 5]],
                "test_expected": [4, 1, 2, 1, 2, 3, 5, 5, 5, 5, 5, 5, 5, 5],
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "zipperLists": {
        "refName": "zipperLists",
        "refNumber": 6,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Zipper Lists",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Write a function, zipperLists, that takes in the head of two linked lists as arguments. The function should zipper the two lists together into single linked list by alternating nodes. If one of the linked lists is longer than the other, the resulting list should terminate with the remaining nodes. The function should return the head of the zippered linked list.</p><p>Do this in-place, by mutating the original Nodes.</p><p>You may assume that both input lists are non-empty.</p>",
        "examples": {
            "example1": {
                "input": "l1 = a -> b -> c\nl2 = x -> y -> z",
                "output": "a -> x -> b -> y -> c -> z"
            },
            "example2": {
                "input": "l1 = a -> b -> c -> d -> e -> f\nl2 = x -> y -> z",
                "output": "a -> x -> b -> y -> c -> z -> d -> e -> f"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function zipperLists(head1, head2) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// ITERATIVE\n// n = length of list 1\n// m = length of list 2\n// Time: O(min(n, m))\n// Space: O(1)\nfunction zipperLists(head1, head2) {\n    let currentNode1 = head1.next;\n    let currentNode2 = head2;\n    let list = head1;\n    let listToggle = false;\n    while (currentNode1 !== null && currentNode2 !== null) {\n        if (listToggle) {\n            list.next = currentNode1;\n            currentNode1 = currentNode1.next;\n        } else {\n            list.next = currentNode2;\n            currentNode2 = currentNode2.next;\n        }\n        list = list.next;\n        listToggle = !listToggle;\n    }\n    if (currentNode1 !== null) list.next = currentNode1;\n    if (currentNode2 !== null) list.next = currentNode2\n    return head1;\n};\n// RECURSIVE\n// n = length of list 1\n// m = length of list 2\n// Time: O(min(n, m))\n// Space: O(min(n, m))\nfunction zipperLists(head1, head2) {\n  if (head1 === null && head2 === null) return null;\n  if (head1 === null) return head2;\n  if (head2 === null) return head1;\n  const next1 = head1.next;\n  const next2 = head2.next;\n  head1.next = head2;\n  head2.next = zipperLists(next1, next2);\n  return head1;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); a.next = b; b.next = c; const x = new Node('x'); const y = new Node('y'); const z = new Node('z'); x.next = y; y.next = z; const val = window.zipperLists(a, x); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' l1 = a -> b -> c; l2 = x -> y -> z', arr]; }",
                "test_expected": ["a", "x", "b", "y", "c", "z"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "mergeLists": {
        "refName": "mergeLists",
        "refNumber": 7,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Merge Lists",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Write a function, mergeLists, that takes in the head of two sorted linked lists as arguments. The function should merge the two lists together into single sorted linked list. The function should return the head of the merged linked list.</p><p>Do this in-place, by mutating the original Nodes.</p><p>You may assume that both input lists are non-empty and contain increasing sorted numbers.</p>",
        "examples": {
            "example1": {
                "input": "l1 = 5 -> 7 -> 10 -> 12 -> 20 -> 28\nl2 = 6 -> 8 -> 9 -> 25",
                "output": "5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 12 -> 20 -> 25 -> 28"
            },
            "example2": {
                "input": "l1 = 2 -> 4 -> 10 -> 12 -> 20 -> 28\nl2 = 1 -> 8 -> 9 -> 10 -> 45",
                "output": "1 -> 2 -> 4 -> 8 -> 9 -> 10 -> 10 -> 12 -> 20 -> 28 -> 45"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function mergeLists(head1, head2) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// ITERATIVE\n// n = length of list 1\n// m = length of list 2\n// Time: O(min(n, m))\n// Space: O(1)\nfunction mergeLists(head1, head2) {\n  let dummyHead = new Node(null);\n  let tail = dummyHead;\n  let current1 = head1;\n  let current2 = head2;\n  \n  while (current1 !== null && current2 !== null) {\n    if (current1.val < current2.val) {\n      tail.next = current1;\n      current1 = current1.next;\n    } else {\n      tail.next = current2;\n      current2 = current2.next;\n    }\n    tail = tail.next;\n  }\n  \n  if (current1 !== null) tail.next = current1;\n  if (current2 !== null) tail.next = current2;\n  \n  return dummyHead.next;\n};\n// RECURSIVE\n// n = length of list 1\n// m = length of list 2\n// Time: O(min(n, m))\n// Space: O(min(n, m))\nfunction mergeLists(head1, head2) {\n  if (head1 === null && head2 === null) return null;\n  if (head1 === null) return head2;\n  if (head2 === null) return head1;\n  if (head1.data < head2.data) {\n    const next1 = head1.next;\n    head1.next = mergeLists(next1, head2);\n    return head1;\n  } else {\n    const next2 = head2.next;\n    head2.next = mergeLists(head1, next2);\n    return head2;\n  }\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(5); const b = new Node(7); const c = new Node(10); const d = new Node(12); const e = new Node(20); const f = new Node(28); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; const q = new Node(6); const r = new Node(8); const s = new Node(9); const t = new Node(25); q.next = r; r.next = s; s.next = t; const val = window.mergeLists(a, q); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' l1 = 5 -> 7 -> 10 -> 12 -> 20 -> 28 l2 = 6 -> 8 -> 9 -> 25', arr]; }",
                "test_expected": [5, 6, 7, 8, 9, 10, 12, 20, 25, 28],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "isUnivalueList": {
        "refName": "isUnivalueList",
        "refNumber": 8,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Is Univalue List",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Write a function, isUnivalueList, that takes in the head of a linked list as an argument. The function should return a boolean indicating whether or not the linked list contains exactly one unique value.</p><p>You may assume that the input list is non-empty.</p>",
        "examples": {
            "example1": {
                "input": "7 -> 7 -> 7",
                "output": "true"
            },
            "example2": {
                "input": "7 -> 7 -> 4",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function isUnivalueList(head) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes\n// Time: O(n)\n// Space: O(1)\nfunction isUnivalueList(head) {\n  let current = head;\n  \n  while (current !== null) {\n    if (current.data !== head.data) return false;\n    current = current.next;\n  }\n  \n  return true;\n}\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction isUnivalueList(head, prevVal = null) {\n  if (head === null) return true;\n  if (prevVal === null || prevVal === head.data) {\n    return isUnivalueList(head.next, head.data);\n  } else {\n    return false;\n  }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(7); const b = new Node(7); const c = new Node(7); a.next = b; b.next = c; const val = window.isUnivalueList(a); return [' 7>7>7', val]; }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(7); const b = new Node(7); const c = new Node(4); a.next = b; b.next = c; const val = window.isUnivalueList(a); return [' 7 -> 7 -> 4', val]; }",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const u = new Node(2); const v = new Node(2); const w = new Node(2); const x = new Node(2); const y = new Node(2); u.next = v; v.next = w; w.next = x; x.next = y; const val = window.isUnivalueList(u); return [' 2 -> 2 -> 2 -> 2 -> 2', val]; }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const u = new Node(2); const v = new Node(2); const w = new Node(3); const x = new Node(3); const y = new Node(2); u.next = v; v.next = w; w.next = x; x.next = y; const val = window.isUnivalueList(u); return [' 2 -> 2 -> 3 -> 3 -> 2', val]; }",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "longestStreak": {
        "refName": "longestStreak",
        "refNumber": 9,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Longest Streak",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Write a function, longestStreak, that takes in the head of a linked list as an argument. The function should return the length of the longest consecutive streak of the same value within the list.</p>",
        "examples": {
            "example1": {
                "input": "5 -> 5 -> 7 -> 7 -> 7 -> 6",
                "output": "3"
            },
            "example2": {
                "input": "3 -> 3 -> 3 -> 3 -> 9 -> 9",
                "output": "4"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function longestStreak(head) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes\n// Time: O(n)\n// Space: O(1)\nfunction longestStreak(head) {\n    if (head === null) return 0;\n    let currentNode = head;\n    let counter = 0;\n    let maxVal = 0;\n    let currentVal = head.data;\n    while (currentNode !== null) {\n        if (currentVal === currentNode.data) {\n            counter++;\n            maxVal = Math.max(maxVal, counter);\n        } else {\n            counter = 1;\n            currentVal = currentNode.data;\n        }\n        currentNode = currentNode.next;\n    }\n    return maxVal;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(5); const b = new Node(5); const c = new Node(7); const d = new Node(7); const e = new Node(7); const f = new Node(6); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; const val = window.longestStreak(a); return [' 5 -> 5 -> 7 -> 7 -> 7 -> 6', val]; }",
                "test_expected": 3,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(3); const b = new Node(3); const c = new Node(3); const d = new Node(3); const e = new Node(9); const f = new Node(9); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; const val = window.longestStreak(a); return [' 3 -> 3 -> 3 -> 3 -> 9 -> 9', val]; }",
                "test_expected": 4,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(9); const b = new Node(9); const c = new Node(1); const d = new Node(9); const e = new Node(9); const f = new Node(9); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; const val = window.longestStreak(a); return [' 9 -> 9 -> 1 -> 9 -> 9 -> 9', val]; }",
                "test_expected": 3,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(5); const b = new Node(5); a.next = b; const val = window.longestStreak(a); return [' 5 -> 5', val]; }",
                "test_expected": 2,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(4); const val = window.longestStreak(a); return [' 5', val]; }",
                "test_expected": 1,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_6": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node(4); const val = window.longestStreak(null); return [' null', val]; }",
                "test_expected": 0,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "removeNode": {
        "refName": "removeNode",
        "refNumber": 10,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Remove Node",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Write a function, removeNode, that takes in the head of a linked list and a target value as arguments. The function should delete the node containing the target value from the linked list and return the head of the resulting linked list. If the target appears multiple times in the linked list, only remove the first instance of the target in the list. Do this in-place.</p><ul><li>You may assume that the input list is non-empty.</li><li>You may assume that the input list contains the target.</li></ul>",
        "examples": {
            "example1": {
                "input": "a -> b -> c -> d -> e -> f",
                "output": "a -> b -> d -> e -> f"
            },
            "example2": {
                "input": "x -> y -> z",
                "output": "x -> y"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function removeNode(head, targetVal) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// ITERATIVE\n// n = number of nodes\n// Time: O(n)\n// Space: O(1)\nfunction removeNode(head, targetVal) {\n  if (head.data === targetVal) return head.next;\n  \n  let current = head;\n  let prev = null;\n  while (current !== null) {\n    if (current.data === targetVal) {\n      prev.next = current.next;\n      break;\n    }\n    prev = current;\n    current = current.next;\n  }\n  \n  return head;\n};\n// RECURSIVE\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction removeNode(head, targetVal) {\n  if (head === null) return null;\n  if (head.data === targetVal) return head.next;\n  head.next = removeNode(head.next, targetVal);\n  return head;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; const val = window.removeNode(a, 'c'); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' a -> b -> c -> d -> e -> f target= c', arr]; }",
                "test_expected": ["a", "b", "d", "e", "f"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "insertNode": {
        "refName": "insertNode",
        "refNumber": 11,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Insert Node",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Write a function, insertNode, that takes in the head of a linked list, a value, and an index. The function should insert a new node with the value into the list at the specified index. Consider the head of the linked list as index 0. The function should return the head of the resulting linked list.</p><p>Do this in-place.</p><p>You may assume that the input list is non-empty and the index is not greater than the length of the input list.</p>",
        "examples": {
            "example1": {
                "input": "a -> b -> c -> d",
                "output": "a -> b -> x -> c -> d"
            },
            "example2": {
                "input": "a -> b -> c -> d",
                "output": "a -> b -> c -> v -> d"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function insertNode(head, value, index, count = 0) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "class Node {\n    constructor(data) {\n        this.data = data\n        this.next = null;\n    }\n}\n// ITERATIVE\n// n = number of nodes\n// Time: O(n)\n// Space: O(1)\nfunction insertNode(head, value, index) {\n  if (index === 0) {\n    const newHead = new Node(value);\n    newHead.next = head;\n    return newHead;\n  }\n  \n  let count = 0;\n  let current = head;\n  while (current !== null) {\n    if (count === index - 1) {\n      const next = current.next;\n      current.next = new Node(value);\n      current.next.next = next;\n    }\n    \n    count += 1;\n    current = current.next;\n  }\n  return head;\n};\n// RECURSIVE \n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction insertNode(head, value, index, count = 0) {\n  if (index === 0) {\n    const newHead = new Node(value);\n    newHead.next = head;\n    return newHead;\n  }\n  \n  if (count === index - 1) {\n    const next = head.next;\n    head.next = new Node(value);\n    head.next.next = next;\n    return head;\n  }\n  \n  insertNode(head.next, value, index, count + 1);\n  return head;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); a.next = b; b.next = c; c.next = d; const val = window.insertNode(a, 'x', 2); let arr = []; let cur = val; while (cur) { arr.push(cur.data); cur = cur.next; } return [' a -> b -> c -> d', arr]; }",
                "test_expected": ["a", "b", "x", "c", "d"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "depthFirstValues": {
        "refName": "depthFirstValues",
        "refNumber": 12,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Depth First Values",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, depthFirstValues, that takes in the root of a binary tree. The function should return an array containing all values of the tree in depth-first order.</p><p>Hey. This is our first binary tree problem, so you should be liberal with watching the Approach and Walkthrough. Be productive, not stubborn. -AZ</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "['a', 'b', 'd', 'e', 'c', 'f']"
            },
            "example2": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\nconst g = new Node('g');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\ne.left = g;",
                "output": "['a', 'b', 'd', 'e', 'g', 'c', 'f']"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function depthFirstValues(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Iterative\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction depthFirstValues(root) {\n  if (root === null) return [];\n  const values = [];\n  const stack = [root];\n  while (stack.length > 0) {\n    const node = stack.pop();\n    values.push(node.val);\n    if (node.right !== null) stack.push(node.right);\n    if (node.left !== null) stack.push(node.left);\n  }\n  return values;\n}\n// recursive\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction depthFirstValues(root) {\n  if (root === null) return [];\n  const leftValues = depthFirstValues(root.left);\n  const rightValues = depthFirstValues(root.right);\n  return [root.val, ...leftValues, ...rightValues];\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() {\n   function Node(val) {\n      this.val = val;\n      this.left = this.right = null;\n   }\n   const a = new Node('a');\n   const b = new Node('b');\n   const c = new Node('c');\n   const d = new Node('d');\n   const e = new Node('e');\n   const f = new Node('f');\n   const g = new Node('g');\n   a.left = b;\n   a.right = c;\n   b.left = d;\n   b.right = e;\n   c.right = f;\n   e.left = g;\n   return window.depthFirstValues(a);\n}",
                "test_expected": ["a", "b", "d", "e", "g", "c", "f"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input(){function Node(val){this.val=val;this.left=null;this.right=null;}const a=new Node('a');const b=new Node('b');const c=new Node('c');const d=new Node('d');const e=new Node('e');const f=new Node('f');const g=new Node('g');a.left=b;a.right=c;b.left=d;b.right=e;c.right=f;e.left=g; return window.depthFirstValues(a);}",
                "test_expected": ["a", "b", "d", "e", "g", "c", "f"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input(){function Node(val){this.val=val;this.left=null;this.right=null;}const a=new Node('a'); return window.depthFirstValues(a);}",
                "test_expected": ["a"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input(){function Node(val){this.val=val;this.left=null;this.right=null;}const a=new Node('a');const b=new Node('b');const c=new Node('c');const d=new Node('d');const e=new Node('e');a.right=b;b.left=c;c.right=d;d.right=e; return window.depthFirstValues(a);}",
                "test_expected": ["a", "b", "c", "d", "e"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input(){return window.depthFirstValues(null);}",
                "test_expected": [],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "breadthFirstValues": {
        "refName": "breadthFirstValues",
        "refNumber": 13,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Breadth First Values",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, breadthFirstValues, that takes in the root of a binary tree. The function should return an array containing all values of the tree in breadth-first order.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "['a', 'b', 'c', 'd', 'e', 'f']"
            },
            "example2": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\nconst g = new Node('g');\nconst h = new Node('h');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\ne.left = g;\nf.right = h",
                "output": "['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function breadthFirstValues(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "/*\nn = number of nodes\nTime: O(n)\nSpace: O(n)\nNote: this solution should really be considered O(n^2) runtime because the JavaScript shift() methods runs in O(n). JavaScript does not have a native queue data structure that is maximally efficient.\n*/\nfunction breadthFirstValues(root) {\n  if (root === null) return [];\n  const values = [];\n  const queue = [root];\n  while (queue.length > 0) {\n    const node = queue.shift();\n    values.push(node.val);\n    if (node.left !== null) queue.push(node.left);\n    if (node.right !== null) queue.push(node.right);\n  }\n  return values;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() {function Node(val) {this.val = val;this.left = null;this.right = null;} const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.breadthFirstValues(a)}",
                "test_expected": ["a", "b", "c", "d", "e", "f"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null;} const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); const g = new Node('g'); const h = new Node('h'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; f.right = h; return window.breadthFirstValues(a)}",
                "test_expected": ["a", "b", "c", "d", "e", "f", "g", "h"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() {function Node(val) {this.val = val;this.left = null;this.right = null;} const a = new Node('a'); return  window.breadthFirstValues(a)}",
                "test_expected": ["a"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null;} const a = new Node('a'); const b = new Node('b'); const c = new Node('c');    const d = new Node('d'); const e = new Node('e'); const x = new Node('x'); a.right = b; b.left = c; c.left = x; c.right = d; d.right = e; return  window.breadthFirstValues(a)}",
                "test_expected": ["a", "b", "c", "x", "d", "e"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() { return  window.breadthFirstValues(null)}",
                "test_expected": [],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "treeSum": {
        "refName": "treeSum",
        "refNumber": 14,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Tree Sum",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, treeSum, that takes in the root of a binary tree that contains number values. The function should return the total sum of all values in the tree.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node(3);\nconst b = new Node(11);\nconst c = new Node(4);\nconst d = new Node(4);\nconst e = new Node(-2);\nconst f = new Node(1);\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "21"
            },
            "example2": {
                "input": "const a = new Node(1);\nconst b = new Node(6);\nconst c = new Node(0);\nconst d = new Node(3);\nconst e = new Node(-6);\nconst f = new Node(2);\nconst g = new Node(2);\nconst h = new Node(2);\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\ne.left = g;\nf.right = h;",
                "output": "10"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function treeSum(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// depth first\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction treeSum(root) {\n  if (root === null) return 0;\n  return root.val + treeSum(root.left) + treeSum(root.right);\n};\n// breadth first\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\n/*\nNote: this solution should really be considered O(n^2) runtime because the JavaScript shift() methods runs in O(n). JavaScript does not have a native queue data structure that is maximally efficient.\n*/\nfunction treeSum(root, target) {\n  if (root === null) return 0;\n  const queue = [root];\n  let totalSum = 0;\n  while (queue.length > 0) {\n    const node = queue.shift();\n    totalSum += node.val;\n    if (node.left !== null) queue.push(node.left);\n    if (node.right !== null) queue.push(node.right);\n  }\n  return totalSum;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(3); const b = new Node(11); const c = new Node(4); const d = new Node(4); const e = new Node(-2); const f = new Node(1); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.treeSum(a) }",
                "test_expected": 21,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null;} const a = new Node(1); const b = new Node(6); const c = new Node(0); const d = new Node(3); const e = new Node(-6); const f = new Node(2); const g = new Node(2); const h = new Node(2); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; f.right = h; return  window.treeSum(a)}",
                "test_expected": 10,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { return  window.treeSum(null)}",
                "test_expected": 0,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "treeIncludes": {
        "refName": "treeIncludes",
        "refNumber": 15,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Tree Includes",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, treeIncludes, that takes in the root of a binary tree and a target value. The function should return a boolean indicating whether or not the value is contained in the tree.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\n const target = 'e'",
                "output": "true"
            },
            "example2": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\n const target = 'a'",
                "output": "true"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function treeIncludes(root, target) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// breadth first search\n/*\nn = number of nodes\nTime: O(n)\nSpace: O(n)\nNote: this solution should really be considered O(n^2) runtime because the JavaScript shift() methods runs in O(n). JavaScript does not have a native queue data structure that is maximally efficient.\n*/\nfunction treeIncludes(root, target) {\n  if (root === null) return false;\n  const queue = [root];\n  while (queue.length > 0) {\n    const node = queue.shift();\n    if (node.val === target) return true;\n    if (node.left !== null) queue.push(node.left);\n    if (node.right !== null) queue.push(node.right);\n  }\n  return false;\n}\n// depth first search\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction treeIncludes(root, target) {\n  if (root === null) return false;\n  if (root.val === target) return true;\n  return treeIncludes(root.left, target) || treeIncludes(root.right, target);\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.treeIncludes([a, 'e']); }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.treeIncludes([a, 'a']); }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c');const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.treeIncludes([a, 'n']);}",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e');const f = new Node('f'); const g = new Node('g'); const h = new Node('h'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; f.right = h; return window.treeIncludes([a, 'f']); }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); const g = new Node('g'); const h = new Node('h'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; f.right = h; return window.treeIncludes([a, 'p']);}",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_6": {
                "test_input": "function test_input() { return window.treeIncludes([null, 'b']);}",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "treeMinValue": {
        "refName": "treeMinValue",
        "refNumber": 16,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Tree Min Value",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, treeMinValue, that takes in the root of a binary tree that contains number values. The function should return the minimum value within the tree.</p><p>You may assume that the input tree is non-empty.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node(3);\nconst b = new Node(11);\nconst c = new Node(4);\nconst d = new Node(4);\nconst e = new Node(-2);\nconst f = new Node(1);\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "-2"
            },
            "example2": {
                "input": "const a = new Node(5);\nconst b = new Node(11);\nconst c = new Node(3);\nconst d = new Node(4);\nconst e = new Node(14);\nconst f = new Node(12);\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "3"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function treeMinValue(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// depth first (recursive)\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction treeMinValue(root) {\n  if (root === null) return Infinity;\n  const smallestLeftValue = treeMinValue(root.left);\n  const smallestRightValue = treeMinValue(root.right);\n  return Math.min(root.val, smallestLeftValue, smallestRightValue);\n};\n// depth first (iterative)\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction treeMinValue(root) {\n  const stack = [root];\n  let smallest = Infinity;\n  while (stack.length) {\n    const current = stack.pop();\n    if (current.val < smallest) smallest = current.val;\n    if (current.left !== null) stack.push(current.left);\n    if (current.right !== null) stack.push(current.right);\n  }\n  return smallest;\n};\n// breadth first (iterative)\n/*\nn = number of nodes\nTime: O(n)\nSpace: O(n)\nNote: this solution should really be considered O(n^2) runtime because the JavaScript shift() methods runs in O(n). JavaScript does not have a native queue data structure that is maximally efficient.\n*/\nfunction treeMinValue(root) {\n  const queue = [root];\n  let smallest = Infinity;\n  while (queue.length) {\n    const current = queue.shift();\n    if (current.val < smallest) smallest = current.val;\n    if (current.left !== null) queue.push(current.left);\n    if (current.right !== null) queue.push(current.right);\n  }\n  return smallest;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(3); const b = new Node(11); const c = new Node(4); const d = new Node(4); const e = new Node(-2); const f = new Node(1); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.treeMinValue(a); }",
                "test_expected": -2,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(5); const b = new Node(11); const c = new Node(3); const d = new Node(4); const e = new Node(14); const f = new Node(12); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.treeMinValue(a) }",
                "test_expected": 3,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(-1); const b = new Node(-6); const c = new Node(-5); const d = new Node(-3); const e = new Node(-4); const f = new Node(-13); const g = new Node(-2); const h = new Node(-2); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; f.right = h; return window.treeMinValue(a) }",
                "test_expected": -13,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(42); return window.treeMinValue(a) }",
                "test_expected": 42,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "maxRootToLeafPathSum": {
        "refName": "MaxRootToLeafPathSum",
        "refNumber": 17,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Max Root To Leaf Path Sum",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, MaxRootToLeafPathSum, that takes in the root of a binary tree that contains number values. The function should return the maximum sum of any root to leaf path within the tree.</p><p>You may assume that the input tree is non-empty.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node(3);\nconst b = new Node(11);\nconst c = new Node(4);\nconst d = new Node(4);\nconst e = new Node(-2);\nconst f = new Node(1);\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "18"
            },
            "example2": {
                "input": "const a = new Node(5);\nconst b = new Node(11);\nconst c = new Node(54);\nconst d = new Node(20);\nconst e = new Node(15);\nconst f = new Node(1);\nconst g = new Node(3);\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\ne.left = f;\ne.right = g;",
                "output": "59"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function maxRootToLeafPathSum(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// depth first (recursive)\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction maxRootToLeafPathSum(root) {\n  if (root === null) return -Infinity;\n  if (root.left === null && root.right === null) return root.val;\n  return root.val + Math.max(maxRootToLeafPathSum(root.left), maxRootToLeafPathSum(root.right));\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(3); const b = new Node(11); const c = new Node(4); const d = new Node(4); const e = new Node(-2); const f = new Node(1); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.maxRootToLeafPathSum(a)}",
                "test_expected": 18,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(5); const b = new Node(11); const c = new Node(54); const d = new Node(20); const e = new Node(15); const f = new Node(1); const g = new Node(3); a.left = b; a.right = c; b.left = d; b.right = e; e.left = f; e.right = g; return window.maxRootToLeafPathSum(a)}",
                "test_expected": 59,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(-1); const b = new Node(-6); const c = new Node(-5); const d = new Node(-3); const e = new Node(0); const f = new Node(-13); const g = new Node(-1); const h = new Node(-2); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; f.right = h; return window.maxRootToLeafPathSum(a)}",
                "test_expected": -8,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(42); return window.maxRootToLeafPathSum(a)}",
                "test_expected": 42,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "treePathFinder": {
        "refName": "treePathFinder",
        "refNumber": 18,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Tree Path Finder",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, treePathFinder, that takes in the root of a binary tree and a target value. The function should return an array representing a path to the target value. If the target value is not found in the tree, then return null.</p><p>You may assume that the tree contains unique values.</p>",
        "examples": {
            "example1": {
                "input": "const target = 'e'\nconst a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "[ 'a', 'b', 'e' ]"
            },
            "example2": {
                "input": "const target = 'p'\nconst a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "null"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function treePathFinder(root, target) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// depth first\n// n = number of nodes\n// Time: O(n^2)\n// Space: O(n)\nfunction treePathFinder(root, target) {\n  if (root === null) return null;\n  if (root.val === target) return [ root.val ];\n  \n  const leftPath = treePathFinder(root.left, target);\n  if (leftPath !== null) return [ root.val, ...leftPath];\n  \n  const rightPath = treePathFinder(root.right, target);\n  if (rightPath !== null) return [ root.val, ...rightPath];\n  \n  return null;\n};\n// depth first w/ push\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction treePathFinder(root, target) {\n  const result = pathFinderHelper(root, target);\n  if (result === null) {\n    return null;\n  } else {\n    return result.reverse();\n  }\n};\nconst pathFinderHelper = (root, target) => {\n  if (root === null) return null;\n  if (root.val === target) return [ root.val ];\n  \n  const leftPath = pathFinderHelper(root.left, target);\n  if (leftPath !== null) {\n    leftPath.push(root.val);\n    return leftPath;\n  }\n  \n  const rightPath = pathFinderHelper(root.right, target);\n  if (rightPath !== null) {\n    rightPath.push(root.val);\n    return rightPath;\n  }\n  \n  return null;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('a'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.treePathFinder(a, 'e');}",
                "test_expected": ["a", "a", "e"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.treePathFinder(a, 'p');}",
                "test_expected": null,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); const g = new Node('g'); const h = new Node('h'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; f.right = h; return window.treePathFinder(a, 'c'); }",
                "test_expected": ["a", "c"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); const g = new Node('g'); const h = new Node('h'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; f.right = h; return window.treePathFinder(a, 'h');}",
                "test_expected": ["a", "c", "f", "h"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const x = new Node('x'); return window.treePathFinder(x, 'x');}",
                "test_expected": ["x"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_6": {
                "test_input": "function test_input() { return window.treePathFinder(null, 'x'); }",
                "test_expected": null,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "treeValueCount": {
        "refName": "treeValueCount",
        "refNumber": 19,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Tree Value Count",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, treeValueCount, that takes in the root of a binary tree and a target value. The function should return the number of times that the target occurs in the tree.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node(12);\nconst b = new Node(6);\nconst c = new Node(6);\nconst d = new Node(4);\nconst e = new Node(6);\nconst f = new Node(12);\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "3"
            },
            "example2": {
                "input": "const a = new Node(12);\nconst b = new Node(6);\nconst c = new Node(6);\nconst d = new Node(4);\nconst e = new Node(6);\nconst f = new Node(12);\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "2"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function treeValueCount(root, target) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// depth first (recursive)\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction treeValueCount(root, target) {\n  if (root === null) return 0;\n  const match = root.val === target ? 1 : 0;\n  return match + treeValueCount(root.left, target) + treeValueCount(root.right, target);\n};\n// depth first (iterative)\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction treeValueCount(root, target) {\n  if (root === null) return 0;\n  \n  let count = 0;\n  const stack = [ root ];\n  while (stack.length > 0) {\n    const current = stack.pop();\n    if (current.val === target) count += 1;\n    \n    if (current.left) stack.push(current.left);\n    if (current.right) stack.push(current.right);\n  }\n  \n  return count;\n};\n// breadth first\n/*\nn = number of nodes\nTime: O(n)\nSpace: O(n)\nNote: this solution should really be considered O(n^2) runtime because the JavaScript shift() methods runs in O(n). JavaScript does not have a native queue data structure that is maximally efficient.\n*/\nfunction treeValueCount(root, target) {\n  if (root === null) return 0;\n  \n  let count = 0;\n  const queue = [ root ];\n  while (queue.length > 0) {\n    const current = queue.shift();\n    if (current.val === target) count += 1;\n    \n    if (current.left) queue.push(current.left);\n    if (current.right) queue.push(current.right);\n  }\n  \n  return count;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(12); const b = new Node(6); const c = new Node(6); const d = new Node(4); const e = new Node(6); const f = new Node(12); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.treeValueCount(a, 6);}",
                "test_expected": 3,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(12); const b = new Node(6); const c = new Node(6); const d = new Node(4); const e = new Node(6); const f = new Node(12); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.treeValueCount(a, 12);}",
                "test_expected": 2,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(7); const b = new Node(5); const c = new Node(1); const d = new Node(1); const e = new Node(8); const f = new Node(7); const g = new Node(1); const h = new Node(1); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; f.right = h; return window.treeValueCount(a, 1);}",
                "test_expected": 4,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { return window.treeValueCount(null, 42);}",
                "test_expected": 0,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "howHigh": {
        "refName": "howHigh",
        "refNumber": 20,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "How High",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, howHigh, that takes in the root of a binary tree. The function should return a number representing the height of the tree.</p><p>The height of a binary tree is defined as the maximal number of edges from the root node to any leaf node.</p><p>If the tree is empty, return -1.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "2"
            },
            "example2": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\nconst g = new Node('g');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\ne.left = g",
                "output": "3"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function howHigh(node) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction howHigh(node) {\n  if (node === null) return -1;\n  const leftHeight = howHigh(node.left);\n  const rightHeight = howHigh(node.right);\n  return 1 + Math.max(leftHeight, rightHeight);\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.howHigh(a);}",
                "test_expected": 2,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); const g = new Node('g'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; return window.howHigh(a);}",
                "test_expected": 3,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const c = new Node('c'); a.right = c; return window.howHigh(a);}",
                "test_expected": 1,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "bottomRightValue": {
        "refName": "bottomRightValue",
        "refNumber": 21,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Bottom Right Value",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, bottomRightValue, that takes in the root of a binary tree. The function should return the right-most value in the bottom-most level of the tree.</p><p>You may assume that the input tree is non-empty.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node(3);\nconst b = new Node(11);\nconst c = new Node(10);\nconst d = new Node(4);\nconst e = new Node(-2);\nconst f = new Node(1);\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "1"
            },
            "example2": {
                "input": "const a = new Node(-1);\nconst b = new Node(-6);\nconst c = new Node(-5);\nconst d = new Node(-3);\nconst e = new Node(-4);\nconst f = new Node(-13);\nconst g = new Node(-2);\nconst h = new Node(6);\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\ne.left = g;\ne.right = h;",
                "output": "6"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function bottomRightValue(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// breadth first\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\n/*\nNote: this solution should really be considered O(n^2) runtime because the JavaScript shift() methods runs in O(n). JavaScript does not have a native queue data structure that is maximally efficient.\n*/\nfunction bottomRightValue(root) {\n  const queue = [root];\n  let current = null;\n  while (queue.length > 0) {\n    current = queue.shift();\n    if (current.left !== null) queue.push(current.left);\n    if (current.right !== null) queue.push(current.right);\n  }\n  return current.val;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(3); const b = new Node(11); const c = new Node(10); const d = new Node(4); const e = new Node(-2); const f = new Node(1); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.bottomRightValue(a);}",
                "test_expected": 1,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(-1); const b = new Node(-6); const c = new Node(-5); const d = new Node(-3); const e = new Node(-4); const f = new Node(-13); const g = new Node(-2); const h = new Node(6); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; e.right = h; return window.bottomRightValue(a);}",
                "test_expected": 6,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(-1); const b = new Node(-6); const c = new Node(-5); const d = new Node(-3); const e = new Node(-4); const f = new Node(-13); const g = new Node(-2); const h = new Node(6); const i = new Node(7); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; e.right = h; f.left = i; return window.bottomRightValue(a);}",
                "test_expected": 7,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); a.left = b; a.right = c; b.right = d; d.left = e; e.right = f; return window.bottomRightValue(a);}",
                "test_expected": "f",
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(42); return window.bottomRightValue(a)}",
                "test_expected": 42,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "allTreePaths": {
        "refName": "allTreePaths",
        "refNumber": 22,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "All Tree Paths",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, allTreePaths, that takes in the root of a binary tree. The function should return a 2-Dimensional array where each subarray represents a root-to-leaf path in the tree.</p><p>The order within an individual path must start at the root and end at the leaf, but the relative order among paths in the outer array does not matter.</p><p>You may assume that the input tree is non-empty.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "[\n  ['a', 'b', 'd'],\n  ['a', 'b', 'e'],\n  ['a', 'c', 'f'],\n];"
            },
            "example2": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\nconst g = new Node('g');\nconst h = new Node('h');\nconst i = new Node('i');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\ne.left = g;\ne.right = h;\nf.left = i;",
                "output": "[\n  ['a', 'b', 'd'],\n  ['a', 'b', 'e', 'g'],\n  ['a', 'b', 'e', 'h'],\n  ['a', 'c', 'f', 'i'],\n];"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function allTreePaths(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes\n// Time: ~O(n)\n// Space: ~O(n)\nfunction allTreePaths(root, paths = [], currentPath = []) {\n    if (root === null) return;\n    currentPath = [...currentPath, root.val];\n    if (root.left === null && root.right === null) {\n        paths.push(currentPath);\n    }\n    allTreePaths(root.left, paths, currentPath);\n    allTreePaths(root.right, paths, currentPath);\n    return paths;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.allTreePaths(a);}",
                "test_expected": [
                    ["a", "b", "d"],
                    ["a", "b", "e"],
                    ["a", "c", "f"]
                ],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); const g = new Node('g'); const h = new Node('h'); const i = new Node('i'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; e.right = h; f.left = i; return window.allTreePaths(a);}",
                "test_expected": [
                    ["a", "b", "d"],
                    ["a", "b", "e", "g"],
                    ["a", "b", "e", "h"],
                    ["a", "c", "f", "i"]
                ],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const q = new Node('q'); const r = new Node('r'); const s = new Node('s'); const t = new Node('t'); const u = new Node('u'); const v = new Node('v'); q.left = r; q.right = s; r.right = t; t.left = u; u.right = v; return window.allTreePaths(q);}",
                "test_expected": [
                    ["q", "r", "t", "u", "v"],
                    ["q", "s"]
                ],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const z = new Node('z'); return window.allTreePaths(z);}",
                "test_expected": [["z"]],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "treeLevels": {
        "refName": "treeLevels",
        "refNumber": 23,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Tree Levels",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, treeLevels, that takes in the root of a binary tree. The function should return a 2-Dimensional array where each subarray represents a level of the tree.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "[['a'], ['b', 'c'], ['d', 'e', 'f']];"
            },
            "example2": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\nconst g = new Node('g');\nconst h = new Node('h');\nconst i = new Node('i');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\ne.left = g;\ne.right = h;\nf.left = i;",
                "output": "[['a'], ['b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function treeLevels(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// breadth first (iterative)\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction treeLevels(root) {\n  if (root === null) return [];\n  const levels = [];\n  const queue = [{ node: root, levelNum: 0 }];\n  while (queue.length > 0) {\n    const { node, levelNum } = queue.shift();\n    if (levels.length === levelNum) {\n      levels[levelNum] = [node.val];\n    } else {\n      levels[levelNum].push(node.val);\n    }\n    if (node.left !== null)\n      queue.push({ node: node.left, levelNum: levelNum + 1 });\n    if (node.right !== null)\n      queue.push({ node: node.right, levelNum: levelNum + 1 });\n  }\n  return levels;\n}\n// depth first (recursive)\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction treeLevels(root, paths = [], currentPath = 0) {\n    if (root === null) return [];\n    if (paths.length === currentPath) {\n        paths[currentPath] = [root.val];\n    } else {\n        paths[currentPath].push(root.val);\n    }\n    treeLevels(root.left, paths, currentPath + 1);\n    treeLevels(root.right, paths, currentPath + 1);\n    return paths;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.treeLevels(a);}",
                "test_expected": [["a"], ["b", "c"], ["d", "e", "f"]],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); const g = new Node('g'); const h = new Node('h'); const i = new Node('i'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; e.right = h; f.left = i; return window.treeLevels(a);}",
                "test_expected": [["a"], ["b", "c"], ["d", "e", "f"], ["g", "h", "i"]],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const q = new Node('q'); const r = new Node('r'); const s = new Node('s'); const t = new Node('t'); const u = new Node('u'); const v = new Node('v'); q.left = r; q.right = s; r.right = t; t.left = u; u.right = v; return window.treeLevels(q);}",
                "test_expected": [["q"], ["r", "s"], ["t"], ["u"], ["v"]],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { return window.treeLevels(null);}",
                "test_expected": [],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "levelAverages": {
        "refName": "levelAverages",
        "refNumber": 24,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Level Averages",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, levelAverages, that takes in the root of a binary tree that contains number values. The function should return an array containing the average value of each level.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node(3);\nconst b = new Node(11);\nconst c = new Node(4);\nconst d = new Node(4);\nconst e = new Node(-2);\nconst f = new Node(1);\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "[ 3, 7.5, 1 ]"
            },
            "example2": {
                "input": "const a = new Node(5);\nconst b = new Node(11);\nconst c = new Node(54);\nconst d = new Node(20);\nconst e = new Node(15);\nconst f = new Node(1);\nconst g = new Node(3);\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\ne.left = f;\ne.right = g;",
                "output": "[ 5, 32.5, 17.5, 2 ]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function levelAverages(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction levelAverages(root) {\n  const levels = [];\n  fillLevels(root, levels, 0);\n  const avgs = [];\n  for (let level of levels) {\n    avgs.push(avg(level));\n  }\n  return avgs;\n}\nconst fillLevels = (root, levels, levelNum) => {\n  if (root === null) return;\n  if (levels.length === levelNum) {\n    levels[levelNum] = [root.val];\n  } else {\n    levels[levelNum].push(root.val);\n  }\n  fillLevels(root.left, levels, levelNum + 1);\n  fillLevels(root.right, levels, levelNum + 1);\n};\nconst avg = (array) => {\n  let sum = 0;\n  for (let num of array) {\n    sum += num;\n  }\n  return sum / array.length;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(3); const b = new Node(11); const c = new Node(4); const d = new Node(4); const e = new Node(-2); const f = new Node(1); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.levelAverages(a);}",
                "test_expected": [3, 7.5, 1],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(5); const b = new Node(11); const c = new Node(54); const d = new Node(20); const e = new Node(15); f = new Node(1); const g = new Node(3); a.left = b; a.right = c; b.left = d; b.right = e; e.left = f; e.right = g; return window.levelAverages(a);}",
                "test_expected": [5, 32.5, 17.5, 2],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(-1); const b = new Node(-6); const c = new Node(-5); const d = new Node(-3); const e = new Node(0);const f = new Node(45); const g = new Node(-1); const h = new Node(-2); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; f.right = h; return window.levelAverages(a);}",
                "test_expected": [-1, -5.5, 14, -1.5],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const q = new Node(13); const r = new Node(4); const s = new Node(2); const t = new Node(9); const u = new Node(2); const v = new Node(42); q.left = r; q.right = s; r.right = t; t.left = u; u.right = v; return window.levelAverages(q);}",
                "test_expected": [13, 3, 9, 2, 42],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() { return window.levelAverages(null);}",
                "test_expected": [],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "leafList": {
        "refName": "leafList",
        "refNumber": 25,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Leaf List",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, leafList, that takes in the root of a binary tree and returns an array containing the values of all leaf nodes in left-to-right order.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;",
                "output": "[ 'd', 'e', 'f' ]"
            },
            "example2": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\nconst g = new Node('g');\nconst h = new Node('h');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\ne.left = g;\nf.right = h;",
                "output": "[ 'd', 'g', 'h' ]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function leafList(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// depth first (iterative)\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction leafList(root) {\n  if (root === null) return [];\n  const leaves = [];\n  const stack = [root];\n  while (stack.length) {\n    const current = stack.pop();\n    if (current.left === null && current.right === null)\n      leaves.push(current.val);\n    if (current.right !== null) stack.push(current.right);\n    if (current.left !== null) stack.push(current.left);\n  }\n  return leaves;\n}\n// depth first (recursive)\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction leafList(root, result = []) {\n    if (root === null) return [];\n    if (root.left === null && root.right === null)  result.push(root.val);\n    leafList(root.left, result);\n    leafList(root.right, result);\n    return result;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; return window.leafList(a);}",
                "test_expected": ["d", "e", "f"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('a'); const b = new Node('b'); const c = new Node('c'); const d = new Node('d'); const e = new Node('e'); const f = new Node('f'); const g = new Node('g'); const h = new Node('h'); a.left = b; a.right = c; b.left = d; b.right = e; c.right = f; e.left = g; f.right = h; return window.leafList(a);}",
                "test_expected": ["d", "g", "h"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node(5); const b = new Node(11); const c = new Node(54); const d = new Node(20); const e = new Node(15); const f = new Node(1); const g = new Node(3); a.left = b; a.right = c; b.left = d; b.right = e; e.left = f; e.right = g; return window.leafList(a);}",
                "test_expected": [20, 1, 3, 54],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() { function Node(val) { this.val = val; this.left = null; this.right = null; } const a = new Node('x'); return window.leafList(a);}",
                "test_expected": ["x"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_6": {
                "test_input": "function test_input() { return window.leafList(null);}",
                "test_expected": [],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "hasPath": {
        "refName": "hasPath",
        "refNumber": 26,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Has Path",
        "tags": ["Easy", "Graphs"],
        "description": "<p>There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.</p><p>You want to determine if there is a valid path that exists from vertex source to vertex destination.</p><p>Given edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.</p>",
        "examples": {
            "example1": {
                "input": "edges = [[0,1],[1,2],[2,0]]\nsource = 0\ndestination = 2",
                "output": "true"
            },
            "example2": {
                "input": "edges = [[0,1],[0,2],[3,5],[5,4],[4,3]]\nsource = 0\ndestination = 5",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function hasPath(edges, src, dst) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function hasPath(edges, src, dst) {\n    const graph = buildGraph(edges);\n    return path(graph, src, dst, new Set());\n};\n// depth first\n// n = number of nodes\n// e = number edges\n// Time: O(e)\n// Space: O(n)\nfunction path(graph, src, dst, visited) {\n    if (src === dst) return true;\n    if (visited.has(src)) return false;\n    visited.add(src);\n    for (let neighbor of graph[src]) {\n        if (path(graph, neighbor, dst, visited) === true) {\n            return true;\n        }\n    }\n    return false;\n}\n// breadth first\n// n = number of nodes\n// e = number edges\n// Time: O(e)\n// Space: O(n)\n// JavaScript shift() methods runs in linear time, so the complexity is really O(e^2).\nfunction path(graph, src, dst) {\n    const visited = new Set([ src ]);\n    const queue = [src];\n    while (queue.length) {\n        const current = queue.shift();\n        if (current === dst) return true;\n        for (let neighbor of graph[current]) {\n            if (!visited.has(neighbor)) {\n                visited.add(neighbor);\n                queue.push(neighbor);\n            }\n            \n        }\n    }\n    return false;\n};\nconst buildGraph = (edges) => {\n    const graph = {};\n    for (let edge of edges) {\n        const [ a, b ] = edge;\n        if (!(a in graph)) graph[a] = [];\n        if (!(b in graph)) graph[b] = [];\n        graph[a].push(b);\n        graph[b].push(a);\n    }\n    return graph;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        [0, 1],
                        [1, 2],
                        [2, 0]
                    ],
                    0,
                    2
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        [0, 1],
                        [0, 2],
                        [3, 5],
                        [5, 4],
                        [4, 3]
                    ],
                    0,
                    5
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "connectedComponentsCount": {
        "refName": "connectedComponentsCount",
        "refNumber": 27,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Connect Components Count",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, connectedComponentsCount, that takes in the adjacency list of an undirected graph. The function should return the number of connected components within the graph.</p>",
        "examples": {
            "example1": {
                "input": "const list = {   0: [8, 1, 5],   1: [0],   5: [0, 8],   8: [0, 5],   2: [3, 4],   3: [2, 4],   4: [3, 2], };",
                "output": "2"
            },
            "example2": {
                "input": "const list = {   1: [2],   2: [1, 8],   6: [7],   9: [8],   7: [6, 8],   8: [9, 7, 2], };",
                "output": "1"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function connectComponentsCount(graph) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// depth first\n// n = number of nodes\n// e = number edges\n// Time: O(e)\n// Space: O(n)\nfunction connectComponentsCount(graph) {\n    const visited = new Set();\n    let count = 0;\n    for (let node in graph) {\n        if (explore(graph, node, visited) === true) {\n        count += 1;\n        }\n    }\n    return count;\n}\n// DFT\nconst explore = (graph, current, visited) => {\n    if (visited.has(String(current))) return false;\n    visited.add(String(current));\n    for (let neighbor of graph[current]) {\n        explore(graph, neighbor, visited);\n    }\n    return true;\n};\n// BFT\nfunction explore(graph, node, visited) {\n    if (visited.has(String(node))) return false;\n    const queue = [node];\n    while (queue.length) {\n        const current = queue.shift();\n        for (let neighbor of graph[current]) {\n            if (!visited.has(String(neighbor))) {\n                visited.add(String(neighbor));\n                queue.push(neighbor);\n            }\n        }\n    }\n    return true;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "0": [8, 1, 5],
                        "1": [0],
                        "2": [3, 4],
                        "3": [2, 4],
                        "4": [3, 2],
                        "5": [0, 8],
                        "8": [0, 5]
                    }
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    {
                        "1": [2],
                        "2": [1, 8],
                        "6": [7],
                        "7": [6, 8],
                        "8": [9, 7, 2],
                        "9": [8]
                    }
                ],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    {
                        "1": [2],
                        "2": [1],
                        "3": [],
                        "4": [6],
                        "5": [6],
                        "6": [4, 5, 7, 8],
                        "7": [6],
                        "8": [6]
                    }
                ],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [{}],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    {
                        "0": [4, 7],
                        "1": [],
                        "2": [],
                        "3": [6],
                        "4": [0],
                        "6": [3],
                        "7": [0],
                        "8": []
                    }
                ],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "largestComponent": {
        "refName": "largestComponent",
        "refNumber": 28,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Largest Component",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, largestComponent, that takes in the adjacency list of an undirected graph. The function should return the size of the largest connected component in the graph.</p>",
        "examples": {
            "example1": {
                "input": "const input = {   0: ['8', '1', '5'],   1: ['0'],   5: ['0', '8'],   8: ['0', '5'],   2: ['3', '4'],   3: ['2', '4'],   4: ['3', '2'], };",
                "output": "4"
            },
            "example2": {
                "input": "const input = {   1: ['2'],   2: ['1', '8'],   6: ['7'],   9: ['8'],   7: ['6', '8'],   8: ['9', '7', '2'], };",
                "output": "6"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function largestComponent(graph) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function largestComponent(graph) {\n  const visited = new Set();\n  let largest = 0;\n  for (let node in graph) {\n    const size = exploreSize(graph, node, visited);\n    if (size > largest) largest = size;\n  }\n  return largest;\n}\n// DFS\nconst exploreSize = (graph, node, visited) => {\n  if (visited.has(node)) return 0;\n  visited.add(node);\n  let size = 1;\n  for (let neighbor of graph[node]) {\n    size += exploreSize(graph, neighbor, visited);\n  }\n  return size;\n};\n// BFS\nfunction exploreSize(graph, node, visited) {\n    if (visited.has(node)) return 0;\n    const queue = [node];\n    let counter = 0;\n    while(queue.length) {\n        const current = queue.shift();\n        for (let neighbor of graph[current]) {\n            if (!visited.has(neighbor)) {\n                visited.add(neighbor);\n                counter++;\n                queue.push(neighbor);\n            }\n        }\n    }\n    return counter;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "0": ["8", "1", "5"],
                        "1": ["0"],
                        "2": ["3", "4"],
                        "3": ["2", "4"],
                        "4": ["3", "2"],
                        "5": ["0", "8"],
                        "8": ["0", "5"]
                    }
                ],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    {
                        "1": ["2"],
                        "2": ["1", "8"],
                        "6": ["7"],
                        "7": ["6", "8"],
                        "8": ["9", "7", "2"],
                        "9": ["8"]
                    }
                ],
                "test_expected": 6,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    {
                        "1": ["2"],
                        "2": ["1"],
                        "3": [],
                        "4": ["6"],
                        "5": ["6"],
                        "6": ["4", "5", "7", "8"],
                        "7": ["6"],
                        "8": ["6"]
                    }
                ],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [{}],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    {
                        "0": ["4", "7"],
                        "1": [],
                        "2": [],
                        "3": ["6"],
                        "4": ["0"],
                        "6": ["3"],
                        "7": ["0"],
                        "8": []
                    }
                ],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "shortestPath": {
        "refName": "shortestPath",
        "refNumber": 29,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Shortest Path",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, shortestPath, that takes in an array of edges for an undirected graph and two nodes (nodeA, nodeB). The function should return the length of the shortest path between A and B. Consider the length as the number of edges in the path, not the number of nodes. If there is no path between A and B, then return -1.</p>",
        "examples": {
            "example1": {
                "input": "const edges = [   ['w', 'x'],   ['x', 'y'],   ['z', 'y'],   ['z', 'v'],   ['w', 'v'], ];\nconst nodeA = 'w'\nconst nodeB = 'z'",
                "output": "2"
            },
            "example2": {
                "input": "const edges = [   ['w', 'x'],   ['x', 'y'],   ['z', 'y'],   ['z', 'v'],   ['w', 'v'], ];\nconst nodeA = 'y'\nconst nodeB = 'x'",
                "output": "1"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function shortestPath(edges, nodeA, nodeB) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// breadth first\n// e = number edges\n// Time: O(e)\n// Space: O(e)\nfunction shortestPath(edges, nodeA, nodeB) {\n  const graph = buildGraph(edges);\n  const visited = new Set([nodeA]);\n  const queue = [[nodeA, 0]];\n  while (queue.length > 0) {\n    const [node, distance] = queue.shift();\n    if (node === nodeB) return distance;\n    for (let neighbor of graph[node]) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push([neighbor, distance + 1]);\n      }\n    }\n  }\n  return -1;\n}\nconst buildGraph = (edges) => {\n  const graph = {};\n  for (let edge of edges) {\n    const [a, b] = edge;\n    if (!(a in graph)) graph[a] = [];\n    if (!(b in graph)) graph[b] = [];\n    graph[a].push(b);\n    graph[b].push(a);\n  }\n  return graph;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        ["w", "x"],
                        ["x", "y"],
                        ["z", "y"],
                        ["z", "v"],
                        ["w", "v"]
                    ],
                    "w",
                    "z"
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        ["w", "x"],
                        ["x", "y"],
                        ["z", "y"],
                        ["z", "v"],
                        ["w", "v"]
                    ],
                    "y",
                    "x"
                ],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [
                        ["a", "c"],
                        ["a", "b"],
                        ["c", "b"],
                        ["c", "d"],
                        ["b", "d"],
                        ["e", "d"],
                        ["g", "f"]
                    ],
                    "a",
                    "e"
                ],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        ["a", "c"],
                        ["a", "b"],
                        ["c", "b"],
                        ["c", "d"],
                        ["b", "d"],
                        ["e", "d"],
                        ["g", "f"]
                    ],
                    "e",
                    "c"
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    [
                        ["a", "c"],
                        ["a", "b"],
                        ["c", "b"],
                        ["c", "d"],
                        ["b", "d"],
                        ["e", "d"],
                        ["g", "f"]
                    ],
                    "b",
                    "g"
                ],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    [
                        ["c", "n"],
                        ["c", "e"],
                        ["c", "s"],
                        ["c", "w"],
                        ["w", "e"]
                    ],
                    "w",
                    "e"
                ],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [
                    [
                        ["c", "n"],
                        ["c", "e"],
                        ["c", "s"],
                        ["c", "w"],
                        ["w", "e"]
                    ],
                    "n",
                    "e"
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [
                    [
                        ["m", "n"],
                        ["n", "o"],
                        ["o", "p"],
                        ["p", "q"],
                        ["t", "o"],
                        ["r", "q"],
                        ["r", "s"]
                    ],
                    "m",
                    "s"
                ],
                "test_expected": 6,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "islandCount": {
        "refName": "islandCount",
        "refNumber": 30,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Island Count",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, islandCount, that takes in a grid containing Ws and Ls. W represents water and L represents land. The function should return the number of islands on the grid. An island is a vertically or horizontally connected region of land.</p>",
        "examples": {
            "example1": {
                "input": "const grid = [   ['W', 'L', 'W', 'W', 'W'],   ['W', 'L', 'W', 'W', 'W'],   ['W', 'W', 'W', 'L', 'W'],   ['W', 'W', 'L', 'L', 'W'],   ['L', 'W', 'W', 'L', 'L'],   ['L', 'L', 'W', 'W', 'W'], ];",
                "output": "3"
            },
            "example2": {
                "input": "const grid = [   ['L', 'W', 'W', 'L', 'W'],   ['L', 'W', 'W', 'L', 'L'],   ['W', 'L', 'W', 'L', 'W'],   ['W', 'W', 'W', 'W', 'W'],   ['W', 'W', 'L', 'L', 'L'], ];",
                "output": "4"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function islandCount(grid) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// depth first\n// r = number of rows\n// c = number of columns\n// Time: O(rc)\n// Space: O(rc)\nfunction islandCount(grid) {\n  const visited = new Set();\n  let count = 0;\n  for (let r = 0; r < grid.length; r += 1) {\n    for (let c = 0; c < grid[0].length; c += 1) {\n      if (explore(grid, r, c, visited) === true) {\n        count += 1;\n      }\n    }\n  }\n  return count;\n}\nconst explore = (grid, r, c, visited) => {\n  const rowInbounds = 0 <= r && r < grid.length;\n  const colInbounds = 0 <= c && c < grid[0].length;\n  if (!rowInbounds || !colInbounds) return false;\n  if (grid[r][c] === 'W') return false;\n  const pos = r + ',' + c;\n  if (visited.has(pos)) return false;\n  visited.add(pos);\n  explore(grid, r - 1, c, visited);\n  explore(grid, r + 1, c, visited);\n  explore(grid, r, c - 1, visited);\n  explore(grid, r, c + 1, visited);\n  return true;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        ["W", "L", "W", "W", "W"],
                        ["W", "L", "W", "W", "W"],
                        ["W", "W", "W", "L", "W"],
                        ["W", "W", "L", "L", "W"],
                        ["L", "W", "W", "L", "L"],
                        ["L", "L", "W", "W", "W"]
                    ]
                ],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        ["L", "W", "W", "L", "W"],
                        ["L", "W", "W", "L", "L"],
                        ["W", "L", "W", "L", "W"],
                        ["W", "W", "W", "W", "W"],
                        ["W", "W", "L", "L", "L"]
                    ]
                ],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [
                        ["W", "W"],
                        ["W", "W"],
                        ["W", "W"]
                    ]
                ],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "minimumIsland": {
        "refName": "minimumIsland",
        "refNumber": 31,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Minimum Island",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, minimumIsland, that takes in a grid containing Ws and Ls. W represents water and L represents land. The function should return the size of the smallest island. An island is a vertically or horizontally connected region of land.</p><p>You may assume that the grid contains at least one island.</p>",
        "examples": {
            "example1": {
                "input": "const grid = [   ['W', 'L', 'W', 'W', 'W'],   ['W', 'L', 'W', 'W', 'W'],   ['W', 'W', 'W', 'L', 'W'],   ['W', 'W', 'L', 'L', 'W'],   ['L', 'W', 'W', 'L', 'L'],   ['L', 'L', 'W', 'W', 'W'], ];",
                "output": "2"
            },
            "example2": {
                "input": "const grid = [   ['L', 'W', 'W', 'L', 'W'],   ['L', 'W', 'W', 'L', 'L'],   ['W', 'L', 'W', 'L', 'W'],   ['W', 'W', 'W', 'W', 'W'],   ['W', 'W', 'L', 'L', 'L'], ];",
                "output": "1"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function minimumIsland(grid) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// depth first\n// r = number of rows\n// c = number of columns\n// Time: O(rc)\n// Space: O(rc)\nfunction minimumIsland(grid) {\n  const visited = new Set();\n  let minSize = Infinity;\n  for (let r = 0; r < grid.length; r += 1) {\n    for (let c = 0; c < grid[0].length; c += 1) {\n      const size = exploreSize(grid, r, c, visited);\n      if (size > 0 && size < minSize) {\n        minSize = size;\n      }\n    }\n  }\n  return minSize;\n}\nconst exploreSize = (grid, r, c, visited) => {\n  const rowInbounds = 0 <= r && r < grid.length;\n  const colInbounds = 0 <= c && c < grid[0].length;\n  if (!rowInbounds || !colInbounds) return 0;\n  if (grid[r][c] === 'W') return 0;\n  const pos = r + ',' + c;\n  if (visited.has(pos)) return 0;\n  visited.add(pos);\n  let size = 1;\n  size += exploreSize(grid, r - 1, c, visited);\n  size += exploreSize(grid, r + 1, c, visited);\n  size += exploreSize(grid, r, c - 1, visited);\n  size += exploreSize(grid, r, c + 1, visited);\n  return size;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        ["W", "L", "W", "W", "W"],
                        ["W", "L", "W", "W", "W"],
                        ["W", "W", "W", "L", "W"],
                        ["W", "W", "L", "L", "W"],
                        ["L", "W", "W", "L", "L"],
                        ["L", "L", "W", "W", "W"]
                    ]
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        ["L", "W", "W", "L", "W"],
                        ["L", "W", "W", "L", "L"],
                        ["W", "L", "W", "L", "W"],
                        ["W", "W", "W", "W", "W"],
                        ["W", "W", "L", "L", "L"]
                    ]
                ],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [
                        ["L", "L", "L"],
                        ["L", "L", "L"],
                        ["L", "L", "L"]
                    ]
                ],
                "test_expected": 9,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        ["W", "W"],
                        ["L", "L"],
                        ["W", "W"],
                        ["W", "L"]
                    ]
                ],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "closestCarrot": {
        "refName": "closestCarrot",
        "refNumber": 32,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Closest Carrot",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, closestCarrot, that takes in a grid, a starting row, and a starting column. In the grid, 'X's are walls, 'O's are open spaces, and 'C's are carrots. The function should return a number representing the length of the shortest path from the starting position to a carrot. You may move up, down, left, or right, but cannot pass through walls (X). If there is no possible path to a carrot, then return -1.</p>",
        "examples": {
            "example1": {
                "input": "const grid = [   ['O', 'O', 'O', 'O', 'O'],   ['O', 'X', 'O', 'O', 'O'],   ['O', 'X', 'X', 'O', 'O'],   ['O', 'X', 'C', 'O', 'O'],   ['O', 'X', 'X', 'O', 'O'],   ['C', 'O', 'O', 'O', 'O'], ];\nstartRow = 1\nstartCol= 2",
                "output": "4"
            },
            "example2": {
                "input": "const grid = [   ['O', 'O', 'O', 'O', 'O'],   ['O', 'X', 'O', 'O', 'O'],   ['O', 'X', 'X', 'O', 'O'],   ['O', 'X', 'C', 'O', 'O'],   ['O', 'X', 'X', 'O', 'O'],   ['C', 'O', 'O', 'O', 'O'], ]\n\nstartRow = 0\nstartCol= 0",
                "output": "5"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function closestCarrot(grid, startRow, startCol) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// breadth first\n// r = number of rows\n// c = number of columns\n// Time: O(rc)\n// Space: O(rc)\nfunction closestCarrot(grid, startRow, startCol) {\n    const queue = [[startRow, startCol, 0]];\n    const visited = new Set([startRow + ',' + startCol]);\n    while (queue.length > 0) {\n        const [row, col, distance] = queue.shift();\n        if (grid[row][col] === 'C') return distance;\n        const deltas = [[1, 0], [-1, 0], [0, 1], [0, -1],];\n        for (let delta of deltas) {\n            const [deltaRow, deltaCol] = delta;\n            const neighborRow = row + deltaRow;\n            const neighborCol = col + deltaCol;\n            const neighborPos = neighborRow + ',' + neighborCol;\n            const rowInbounds = 0 <= neighborRow && neighborRow < grid.length;\n            const colInbounds = 0 <= neighborCol && neighborCol < grid[0].length;\n            if (\n                rowInbounds &&\n                colInbounds &&\n                !visited.has(neighborPos) &&\n                grid[neighborRow][neighborCol] !== 'X'\n            ) {\n                visited.add(neighborPos);\n                queue.push([neighborRow, neighborCol, distance + 1]);\n            }\n        }\n    }\n    return -1;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        ["O", "O", "O", "O", "O"],
                        ["O", "X", "O", "O", "O"],
                        ["O", "X", "X", "O", "O"],
                        ["O", "X", "C", "O", "O"],
                        ["O", "X", "X", "O", "O"],
                        ["C", "O", "O", "O", "O"]
                    ],
                    1,
                    2
                ],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        ["O", "O", "O", "O", "O"],
                        ["O", "X", "O", "O", "O"],
                        ["O", "X", "X", "O", "O"],
                        ["O", "X", "C", "O", "O"],
                        ["O", "X", "X", "O", "O"],
                        ["C", "O", "O", "O", "O"]
                    ],
                    0,
                    0
                ],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [
                        ["O", "O", "X", "X", "X"],
                        ["O", "X", "X", "X", "C"],
                        ["O", "X", "O", "X", "X"],
                        ["O", "O", "O", "O", "O"],
                        ["O", "X", "X", "X", "X"],
                        ["O", "O", "O", "O", "O"],
                        ["O", "O", "C", "O", "O"],
                        ["O", "O", "O", "O", "O"]
                    ],
                    3,
                    4
                ],
                "test_expected": 9,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        ["O", "O", "X", "O", "O"],
                        ["O", "X", "X", "X", "O"],
                        ["O", "X", "C", "C", "O"]
                    ],
                    1,
                    4
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    [
                        ["O", "O", "X", "O", "O"],
                        ["O", "X", "X", "X", "O"],
                        ["O", "X", "C", "C", "O"]
                    ],
                    2,
                    0
                ],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    [
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "X", "X"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "X", "C"]
                    ],
                    0,
                    0
                ],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "longestPath": {
        "refName": "longestPath",
        "refNumber": 33,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Longest Path",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, longestPath, that takes in an adjacency list for a directed acyclic graph. The function should return the length of the longest path within the graph. A path may start and end at any two nodes. The length of a path is considered the number of edges in the path, not the number of nodes.</p>",
        "examples": {
            "example1": {
                "input": "input = {   a: ['c', 'b'],   b: ['c'],   c: [], }",
                "output": "2"
            },
            "example2": {
                "input": "input = {   a: ['c', 'b'],   b: ['c'],   c: [],   q: ['r'],   r: ['s', 'u', 't'],   s: ['t'],   t: ['u'],   u: [], }",
                "output": "4"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function longestPath(graph) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// depth first\n// e = # edges\n// n = # nodes\n// Time: O(e)\n// Space: O(n)\nfunction longestPath(graph) {\n  const distance = {};\n  for (let node in graph) {\n    if (graph[node].length === 0) {\n      distance[node] = 0;\n    }\n  }\n  for (let node in graph) {\n    traverseDistance(graph, node, distance);\n  }\n  return Math.max(...Object.values(distance));\n}\nconst traverseDistance = (graph, node, distance) => {\n  if (node in distance) return distance[node];\n  let maxDistance = 0;\n  for (let neighbor of graph[node]) {\n    const attempt = traverseDistance(graph, neighbor, distance);\n    if (attempt > maxDistance) maxDistance = attempt;\n  }\n  distance[node] = 1 + maxDistance;\n  return distance[node];\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "a": ["c", "b"],
                        "b": ["c"],
                        "c": []
                    }
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    {
                        "a": ["c", "b"],
                        "b": ["c"],
                        "c": [],
                        "q": ["r"],
                        "r": ["s", "u", "t"],
                        "s": ["t"],
                        "t": ["u"],
                        "u": []
                    }
                ],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    {
                        "h": ["i", "j", "k"],
                        "g": ["h"],
                        "i": [],
                        "j": [],
                        "k": [],
                        "x": ["y"],
                        "y": []
                    }
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "semestersRequired": {
        "refName": "semestersRequired",
        "refNumber": 34,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Semesters Required",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, semestersRequired, that takes in a number of courses (n) and a list of prerequisites as arguments. Courses have ids ranging from 0 through n - 1. A single prerequisite of [A, B] means that course A must be taken before course B. Return the minimum number of semesters required to complete all n courses. There is no limit on how many courses you can take in a single semester, as long the prerequisites of a course are satisfied before taking it.</p><p>Note that given prerequisite [A, B], you cannot take course A and course B concurrently in the same semester. You must take A in some semester before B.</p><p>You can assume that it is possible to eventually complete all courses.</p>",
        "examples": {
            "example1": {
                "input": "const numCourses = 6\nconst prereqs = [   [1, 2],   [2, 4],   [3, 5],   [0, 5], ]",
                "output": "3"
            },
            "example2": {
                "input": "const numCourses = 7\nconst prereqs = [   [4, 3],   [3, 2],   [2, 1],   [1, 0],   [5, 2],   [5, 6], ]",
                "output": "5"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function semestersRequired(numCourses, prereqs) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// depth first\n// p = # prereqs\n// c = # courses\n// Time: O(p)\n// Space: O(c)\nfunction semestersRequired(numCourses, prereqs) {\n    const graph = buildGraph(numCourses, prereqs);\n    const distance = {};\n    for (let i = 0; i < numCourses; i += 1) {\n        if (graph[i].length === 0) distance[i] = 1;\n    }\n    for (let i = 0; i < numCourses; i += 1) {\n        traverseDistance(graph, i, distance);\n    }\n    return Math.max(...Object.values(distance));\n    }\n    const traverseDistance = (graph, node, distance) => {\n    if (node in distance) return distance[node];\n    let maxDistance = 0;\n    for (let neighbor of graph[node]) {\n        const neighborDistance = traverseDistance(graph, neighbor, distance);\n        if (neighborDistance > maxDistance) maxDistance = neighborDistance;\n    }\n    distance[node] = maxDistance + 1;\n    return distance[node];\n};\nconst buildGraph = (numCourses, prereqs) => {\n    const graph = {};\n    for (let i = 0; i < numCourses; i += 1) {\n        graph[i] = [];\n    }\n    for (let prereq of prereqs) {\n        const [a, b] = prereq;\n        graph[a].push(b);\n    }\n    return graph;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    6,
                    [
                        [1, 2],
                        [2, 4],
                        [3, 5],
                        [0, 5]
                    ]
                ],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    7,
                    [
                        [4, 3],
                        [3, 2],
                        [2, 1],
                        [1, 0],
                        [5, 2],
                        [5, 6]
                    ]
                ],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    5,
                    [
                        [1, 0],
                        [3, 4],
                        [1, 2],
                        [3, 2]
                    ]
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [12, []],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    3,
                    [
                        [0, 2],
                        [0, 1],
                        [1, 2]
                    ]
                ],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    6,
                    [
                        [3, 4],
                        [3, 0],
                        [3, 1],
                        [3, 2],
                        [3, 5]
                    ]
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "bestBridge": {
        "refName": "bestBridge",
        "refNumber": 35,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Best Bridge",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, bestBridge, that takes in a grid as an argument. The grid contains water (W) and land (L). There are exactly two islands in the grid. An island is a vertically or horizontally connected region of land. Return the minimum length bridge needed to connect the two islands. A bridge does not need to form a straight line.</p>",
        "examples": {
            "example1": {
                "input": "input = [   ['W', 'W', 'W', 'L', 'L'],   ['L', 'L', 'W', 'W', 'L'],   ['L', 'L', 'L', 'W', 'L'],   ['W', 'L', 'W', 'W', 'W'],   ['W', 'W', 'W', 'W', 'W'],   ['W', 'W', 'W', 'W', 'W'], ];",
                "output": "1"
            },
            "example2": {
                "input": "input = [   ['W', 'W', 'W', 'W', 'W'],   ['W', 'W', 'W', 'W', 'W'],   ['L', 'L', 'W', 'W', 'L'],   ['W', 'L', 'W', 'W', 'L'],   ['W', 'W', 'W', 'L', 'L'],   ['W', 'W', 'W', 'W', 'W'], ];",
                "output": "2"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function bestBridge(grid) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// r = number of rows\n// c = number of columns\n// Time: O(rc)\n// Space: O(rc)\nfunction bestBridge(grid) {\n    let mainIsland;\n    for (let r = 0; r < grid.length; r += 1) {\n        for (let c = 0; c < grid[0].length; c += 1) {\n            const possibleIsland = traverseIsland(grid, r, c, new Set());\n            if (possibleIsland.size > 0) {\n                mainIsland = possibleIsland;\n                break;\n            }\n        }\n    }\n    return brith(grid, mainIsland)\n}\nfunction isInbounds(grid, row, col) {\n    const rowInbounds = 0 <= row && row < grid.length;\n    const colInbounds = 0 <= col && col < grid[0].length;\n    return rowInbounds && colInbounds;\n};\nfunction traverseIsland(grid, row, col, visited) {\n    if (!isInbounds(grid, row, col) || grid[row][col] === 'W') return visited;\n    const pos = row + ',' + col;\n    if (visited.has(pos)) return visited;\n    visited.add(pos);\n    traverseIsland(grid, row - 1, col, visited);\n    traverseIsland(grid, row + 1, col, visited);\n    traverseIsland(grid, row, col - 1, visited);\n    traverseIsland(grid, row, col + 1, visited);\n    return visited;\n};\nfunction brith(grid, mainIsland) {\n    const visited = new Set(mainIsland);\n    const queue = [];\n    for (let pos of mainIsland) {\n        const [row, col] = pos.split(',').map(Number);\n        queue.push([row, col, 0]);\n    }\n    while (queue.length > 0) {\n        const [row, col, distance] = queue.shift();\n        const pos = row + ',' + col;\n        if (grid[row][col] === 'L' && !mainIsland.has(pos)) return distance - 1;\n        const deltas = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n        for (let delta of deltas) {\n            const [deltaRow, deltaCol] = delta;\n            const neighborRow = row + deltaRow;\n            const neighborCol = col + deltaCol;\n            const neighborPos = neighborRow + ',' + neighborCol;\n            if (\n                isInbounds(grid, neighborRow, neighborCol) &&\n                !visited.has(neighborPos)\n            ) {\n                visited.add(neighborPos);\n                queue.push([neighborRow, neighborCol, distance + 1]);\n            }\n        }\n    }\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        ["W", "W", "W", "L", "L"],
                        ["L", "L", "W", "W", "L"],
                        ["L", "L", "L", "W", "L"],
                        ["W", "L", "W", "W", "W"],
                        ["W", "W", "W", "W", "W"],
                        ["W", "W", "W", "W", "W"]
                    ]
                ],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        ["W", "W", "W", "W", "W"],
                        ["W", "W", "W", "W", "W"],
                        ["L", "L", "W", "W", "L"],
                        ["W", "L", "W", "W", "L"],
                        ["W", "W", "W", "L", "L"],
                        ["W", "W", "W", "W", "W"]
                    ]
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [
                        ["W", "W", "W", "W", "W"],
                        ["W", "W", "W", "L", "W"],
                        ["L", "W", "W", "W", "W"]
                    ]
                ],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        ["W", "W", "W", "W", "W", "W", "W", "W"],
                        ["W", "W", "W", "W", "W", "W", "W", "W"],
                        ["W", "W", "W", "W", "W", "W", "W", "W"],
                        ["W", "W", "W", "W", "W", "L", "W", "W"],
                        ["W", "W", "W", "W", "L", "L", "W", "W"],
                        ["W", "W", "W", "W", "L", "L", "L", "W"],
                        ["W", "W", "W", "W", "W", "L", "L", "L"],
                        ["L", "W", "W", "W", "W", "L", "L", "L"],
                        ["L", "L", "L", "W", "W", "W", "W", "W"],
                        ["W", "W", "W", "W", "W", "W", "W", "W"]
                    ]
                ],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    [
                        ["L", "L", "L", "L", "L", "L", "L", "L"],
                        ["L", "W", "W", "W", "W", "W", "W", "L"],
                        ["L", "W", "W", "W", "W", "W", "W", "L"],
                        ["L", "W", "W", "W", "W", "W", "W", "L"],
                        ["L", "W", "W", "W", "W", "W", "W", "L"],
                        ["L", "W", "W", "W", "W", "W", "W", "L"],
                        ["L", "W", "W", "L", "W", "W", "W", "L"],
                        ["L", "W", "W", "W", "W", "W", "W", "L"],
                        ["L", "W", "W", "W", "W", "W", "W", "L"],
                        ["L", "W", "W", "W", "W", "W", "W", "L"],
                        ["L", "W", "W", "W", "W", "W", "W", "L"],
                        ["L", "L", "L", "L", "L", "L", "L", "L"]
                    ]
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    [
                        ["W", "L", "W", "W", "W", "W", "W", "W"],
                        ["W", "L", "W", "W", "W", "W", "W", "W"],
                        ["W", "W", "W", "W", "W", "W", "W", "W"],
                        ["W", "W", "W", "W", "W", "W", "W", "W"],
                        ["W", "W", "W", "W", "W", "W", "W", "W"],
                        ["W", "W", "W", "W", "W", "W", "L", "W"],
                        ["W", "W", "W", "W", "W", "W", "L", "L"],
                        ["W", "W", "W", "W", "W", "W", "W", "L"]
                    ]
                ],
                "test_expected": 8,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "hasCycle": {
        "refName": "hasCycle",
        "refNumber": 36,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Has Cycle",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, hasCycle, that takes in an object representing the adjacency list of a directed graph. The function should return a boolean indicating whether or not the graph contains a cycle.</p>",
        "examples": {
            "example1": {
                "input": "input = {   a: ['b'],   b: ['c'],   c: ['a'], };",
                "output": "true"
            },
            "example2": {
                "input": "input = { a: ['b', 'c'], b: ['c'], c: ['d'], d: [], }",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function hasCycle(graph) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function hasCycle(graph) {\n    const visited = new Set();\n    for (let startNode in graph) {\n        if (cycleDetect(graph, startNode, new Set(), visited)) return true;\n    }\n    return false;\n}\nconst cycleDetect = (graph, node, visiting, visited) => {\n    if (visited.has(node)) return false;\n    if (visiting.has(node)) return true;\n    visiting.add(node);\n    for (let neighbor of graph[node]) {\n        if (cycleDetect(graph, neighbor, visiting, visited)) return true;\n    }\n    visiting.delete(node);\n    visited.add(node);\n    return false;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "a": ["b"],
                        "b": ["c"],
                        "c": ["a"]
                    }
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    {
                        "a": ["b", "c"],
                        "b": ["c"],
                        "c": ["d"],
                        "d": []
                    }
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    {
                        "a": ["b", "c"],
                        "b": [],
                        "c": [],
                        "e": ["f"],
                        "f": ["e"]
                    }
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    {
                        "q": ["r", "s"],
                        "r": ["t", "u"],
                        "s": [],
                        "t": [],
                        "u": [],
                        "v": ["w"],
                        "w": [],
                        "x": ["w"]
                    }
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    {
                        "a": ["b"],
                        "b": ["c"],
                        "c": ["a"],
                        "g": []
                    }
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "prereqsPossible": {
        "refName": "prereqsPossible",
        "refNumber": 37,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Prereqs Possible",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, prereqsPossible, that takes in a number of courses (n) and prerequisites as arguments. Courses have ids ranging from 0 through n - 1. A single prerequisite of [A, B] means that course A must be taken before course B. The function should return a boolean indicating whether or not it is possible to complete all courses.</p>",
        "examples": {
            "example1": {
                "input": "const numCourses = 6\nconst prereqs = [   [0, 1],   [2, 3],   [0, 2],   [1, 3],   [4, 5], ];",
                "output": "true"
            },
            "example2": {
                "input": "const numCourses = 6\nconst prereqs = [   [0, 1],   [2, 3],   [0, 2],   [1, 3],   [4, 5],   [3, 0], ];",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function prereqsPossible(numCourses, prereqs) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// white-grey-black cycle detection algorithm\n// p = # prereqs\n// n = # courses\n// Time: O(p)\n// Space: O(n)\nfunction prereqsPossible(numCourses, prereqs) {\n    const visiting = new Set();\n    const visited = new Set();\n    const graph = buildGraph(numCourses, prereqs);\n    for (let node in graph) {\n        if (hasCycle(graph, node, visiting, visited)) {\n        return false;\n        }\n    }\n    return true;\n}\nconst hasCycle = (graph, node, visiting, visited) => {\n    if (visited.has(node)) return false;\n    if (visiting.has(node)) return true;\n    visiting.add(node);\n    for (let neighbor of graph[node]) {\n        if (hasCycle(graph, neighbor, visiting, visited)) {\n        return true;\n        }\n    }\n    visiting.delete(node);\n    visited.add(node);\n    return false;\n};\nconst buildGraph = (numCourses, prereqs) => {\n    const graph = {};\n    for (let i = 0; i < numCourses; i += 1) {\n        graph[i] = [];\n    }\n    for (let prereq of prereqs) {\n        const [a, b] = prereq;\n        graph[a].push(String(b));\n    }\n    return graph;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    6,
                    [
                        [0, 1],
                        [2, 3],
                        [0, 2],
                        [1, 3],
                        [4, 5]
                    ]
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    6,
                    [
                        [0, 1],
                        [2, 3],
                        [0, 2],
                        [1, 3],
                        [4, 5],
                        [3, 0]
                    ]
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    5,
                    [
                        [2, 4],
                        [1, 0],
                        [0, 2],
                        [0, 4]
                    ]
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    6,
                    [
                        [2, 4],
                        [1, 0],
                        [0, 2],
                        [0, 4],
                        [5, 3],
                        [3, 5]
                    ]
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    8,
                    [
                        [1, 0],
                        [0, 6],
                        [2, 0],
                        [0, 5],
                        [3, 7],
                        [4, 3]
                    ]
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    8,
                    [
                        [1, 0],
                        [0, 6],
                        [2, 0],
                        [0, 5],
                        [3, 7],
                        [7, 4],
                        [4, 3]
                    ]
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [42, [[6, 36]]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "sumPossible": {
        "refName": "sumPossible",
        "refNumber": 38,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Sum Possible",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function sumPossible that takes in an amount and an array of positive numbers. The function should return a boolean indicating whether or not it is possible to create the amount by summing numbers of the array. You may reuse numbers of the array as many times as necessary.</p><p>You may assume that the target amount is non-negative.</p>",
        "examples": {
            "example1": {
                "input": "const amount = 8\nconst numbers = [5, 12, 4]",
                "output": "true, 4 + 4"
            },
            "example2": {
                "input": "const amount = 15\nconst numbers = [6, 2, 10, 19]",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function sumPossible(amount, numbers, memo = {}) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// dynamic programming with memoization\n// a = amount\n// n = length of numbers\n// Time: O(a*n)\n// Space: O(a)\nfunction sumPossible(amount, numbers, memo = {}) {\n  if (amount === 0) return true;\n  \n  if (amount < 0) return false;\n  \n  if (amount in memo) return memo[amount];\n  \n  for (let num of numbers) {\n    if (sumPossible(amount - num, numbers, memo)) {\n      memo[amount] = true;\n      return true;\n    }\n  }\n  \n  memo[amount] = false;\n  return false;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [8, [5, 12, 4]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [15, [6, 2, 10, 19]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [13, [6, 2, 1]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [103, [6, 20, 1]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [12, []],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [12, [12]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [0, []],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [271, [10, 8, 265, 24]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_9": {
                "test_input": [2017, [4, 2, 10]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_10": {
                "test_input": [13, [3, 5]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "minChange": {
        "refName": "minChange",
        "refNumber": 39,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Min Change",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function minChange that takes in an amount and an array of coins. The function should return the minimum number of coins required to create the amount. You may use each coin as many times as necessary.</p><p>If it is not possible to create the amount, then return -1.</p>",
        "examples": {
            "example1": {
                "input": "const amount = 8\nconst coins = [1, 5, 4, 12]",
                "output": "2, because 4+4 is the minimum coins possible"
            },
            "example2": {
                "input": "const amount = 13\nconst coins = [1, 9, 5, 14, 30]",
                "output": "5"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function minChange(amount, coins) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// a = amount\n// c = # coins\n// Time: O(a*c)\n// Space: O(a)\nfunction minChange(amount, coins) {\n  const answer = _minChange(amount, coins);\n  return answer === Infinity ? -1 : answer;\n};\nconst _minChange = (amount, coins, memo = {}) => {\n  if (amount < 0) return Infinity;\n  \n  if (amount === 0) return 0;\n  \n  if (amount in memo) return memo[amount];\n  \n  let min = Infinity;\n  for (let coin of coins) {\n    const numCoins = 1 + _minChange(amount - coin, coins, memo);\n    min = Math.min(numCoins, min);\n  }\n  return memo[amount] = min;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [8, [1, 5, 4, 12]],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [13, [1, 9, 5, 14, 30]],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [23, [2, 5, 7]],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [102, [1, 5, 10, 25]],
                "test_expected": 6,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [200, [1, 5, 10, 25]],
                "test_expected": 8,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [2017, [4, 2, 10]],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [271, [10, 8, 265, 24]],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [0, [4, 2, 10]],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            },
            "Test_9": {
                "test_input": [0, []],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "countPaths": {
        "refName": "countPaths",
        "refNumber": 40,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Count Paths",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function, countPaths, that takes in a grid as an argument. In the grid, 'X' represents walls and 'O' represents open spaces. You may only move down or to the right and cannot pass through walls. The function should return the number of ways possible to travel from the top-left corner of the grid to the bottom-right corner.</p>",
        "examples": {
            "example1": {
                "input": "const grid = [   ['O', 'O'],   ['O', 'O'], ]",
                "output": "2"
            },
            "example2": {
                "input": "const grid = [   ['O', 'O', 'X'],   ['O', 'O', 'O'],   ['O', 'O', 'O'], ];",
                "output": "5"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function countPaths(grid, r = 0, c = 0, memo = {}) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// r = # rows\n// c = # columns\n// Time: O(r*c)\n// Space: O(r*c)\nfunction countPaths(grid, r = 0, c = 0, memo = {}) {\n  const pos = r + ',' + c;\n  if (pos in memo) return memo[pos];\n  if (r === grid.length || c === grid[0].length || grid[r][c] === 'X') return 0;\n  if (r === grid.length - 1 && c === grid[0].length - 1) return 1;\n  memo[pos] =\n    countPaths(grid, r + 1, c, memo) + countPaths(grid, r, c + 1, memo);\n  return memo[pos];\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        ["O", "O"],
                        ["O", "O"]
                    ]
                ],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        ["O", "O", "X"],
                        ["O", "O", "O"],
                        ["O", "O", "O"]
                    ]
                ],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [
                        ["O", "O", "O"],
                        ["O", "O", "X"],
                        ["O", "O", "O"]
                    ]
                ],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        ["O", "O", "O"],
                        ["O", "X", "X"],
                        ["O", "O", "O"]
                    ]
                ],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    [
                        ["O", "O", "X", "O", "O", "O"],
                        ["O", "O", "X", "O", "O", "O"],
                        ["X", "O", "X", "O", "O", "O"],
                        ["X", "X", "X", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O"]
                    ]
                ],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    [
                        ["O", "O", "X", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "X"],
                        ["X", "O", "O", "O", "O", "O"],
                        ["X", "X", "X", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O"]
                    ]
                ],
                "test_expected": 42,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [
                    [
                        ["O", "O", "X", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "X"],
                        ["X", "O", "O", "O", "O", "O"],
                        ["X", "X", "X", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "X"]
                    ]
                ],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [
                    [
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"]
                    ]
                ],
                "test_expected": 40116600,
                "code_output": null,
                "passed_test": false
            },
            "Test_9": {
                "test_input": [
                    [
                        ["O", "O", "X", "X", "O", "O", "O", "X", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "X", "X", "O", "O", "O", "X", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "X", "O", "O", "O", "X", "O", "O", "O", "O", "O", "O", "O"],
                        ["X", "O", "O", "O", "O", "O", "O", "X", "O", "O", "O", "O", "O", "O", "O"],
                        ["X", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "X", "X", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "X", "O", "O", "O", "O", "O", "X", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "X", "O", "O", "O", "O", "O", "O"],
                        ["X", "X", "X", "O", "O", "O", "O", "O", "O", "X", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "X", "X", "O", "O", "O", "O", "X", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "X", "X", "O", "O", "O", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "X", "O", "O", "O", "O", "O", "O"],
                        ["O", "O", "O", "O", "O", "O", "O", "O", "X", "O", "O", "O", "O", "O", "O"]
                    ]
                ],
                "test_expected": 3190434,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "maxPathSum": {
        "refName": "maxPathSum",
        "refNumber": 41,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Max Path Sum",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function, maxPathSum, that takes in a grid as an argument. The function should return the maximum sum possible by traveling a path from the top-left corner to the bottom-right corner. You may only travel through the grid by moving down or right.</p><p>You can assume that all numbers are non-negative.</p>",
        "examples": {
            "example1": {
                "input": "const grid = [[1, 3, 12],   [5, 1, 1],   [3, 6, 1], ];",
                "output": "18"
            },
            "example2": {
                "input": "const grid = [   [1, 2, 8, 1],   [3, 1, 12, 10],   [4, 0, 6, 3], ];",
                "output": "36"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function maxPathSum(grid, r = 0, c = 0, memo = {}) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// r = # rows\n// c = # columns\n// Time: O(r*c)\n// Space: O(r*c)\nfunction maxPathSum(grid, r = 0, c = 0, memo = {}) {\n  const pos = r + ',' + c;\n  if (pos in memo) return memo[pos];\n  if (r === grid.length || c === grid[0].length) return -Infinity;\n  if (r === grid.length - 1 && c === grid[0].length - 1) return grid[r][c];\n  const down = maxPathSum(grid, r + 1, c, memo);\n  const right = maxPathSum(grid, r, c + 1, memo);\n  memo[pos] = grid[r][c] + Math.max(down, right);\n  return memo[pos];\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        [1, 3, 12],
                        [5, 1, 1],
                        [3, 6, 1]
                    ]
                ],
                "test_expected": 18,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        [1, 2, 8, 1],
                        [3, 1, 12, 10],
                        [4, 0, 6, 3]
                    ]
                ],
                "test_expected": 36,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [
                        [1, 2, 8, 1],
                        [3, 10, 12, 10],
                        [4, 0, 6, 3]
                    ]
                ],
                "test_expected": 39,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ]
                ],
                "test_expected": 27,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    [
                        [1, 1, 3, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 2, 1, 1, 6, 1, 1, 5, 1, 1, 0, 0, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 5, 1, 1, 1, 1, 0, 1, 1, 1, 1],
                        [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [2, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1, 1],
                        [2, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                    ]
                ],
                "test_expected": 56,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "summingSquares": {
        "refName": "summingSquares",
        "refNumber": 42,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Summing Squares",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function, summingSquares, that takes a target number as an argument. The function should return the minimum number of perfect squares that sum to the target. A perfect square is a number of the form (i*i) where i >= 1.</p><p>For example: 1, 4, 9, 16 are perfect squares, but 8 is not perfect square.</p>",
        "examples": {
            "example1": {
                "input": "12",
                "output": "The minimum squares required for 12 is three, by doing 4 + 4 + 4.\nAnother way to make 12 is 9 + 1 + 1 + 1, but that requires four perfect squares."
            },
            "example2": {
                "input": "8",
                "output": "2"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function summingSquares(n, memo = {}) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of nums\n// Time: O(n * sqrt(n))\n// Space: O(n)\nfunction summingSquares(n, memo = {}) {\n  if (n in memo) return memo[n];\n  \n  if (n === 0) return 0;\n  \n  let minSquares = Infinity;\n  for (let i = 1; i <= Math.sqrt(n); i += 1) {\n    const square = i * i;\n    const numSquares = 1 + summingSquares(n - square, memo);\n    minSquares = Math.min(minSquares, numSquares);\n  }\n  \n  memo[n] = minSquares;\n  return minSquares;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [8],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [9],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [12],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [1],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [31],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [50],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [68],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [87],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "countingChange": {
        "refName": "countingChange",
        "refNumber": 43,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Counting Change",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function, countingChange, that takes in an amount and an array of coins. The function should return the number of different ways it is possible to make change for the given amount using the coins.</p><p>You may reuse a coin as many times as necessary.</p>",
        "examples": {
            "example1": {
                "input": "amount = 4\ncoins= [1,2,3]",
                "output": "4\nThere are four different ways to make an amount of 4:\n1 + 1 + 1 + 1\n1 + 1 + 2\n1 + 3\n2 + 2"
            },
            "example2": {
                "input": "amount = 8\ncoins= [1,2,3]",
                "output": "2"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function countingChange(amount, coins, i = 0, memo = {}) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// a = amount\n// c = # coins\n// Time: O(a*c)\n// Space: O(a*c)\nfunction countingChange(amount, coins, i = 0, memo = {}) {\n  const key = amount + ',' + i;\n  if (key in memo) return memo[key];\n  \n  if (amount === 0) return 1;\n  if (i === coins.length) return 0;\n    \n  const coin = coins[i];\n  \n  let count = 0;\n  for (let qty = 0; (qty * coin) <= amount; qty += 1) {\n    const remainder = amount - (coin * qty);\n    count += countingChange(remainder, coins, i + 1, memo);\n  }\n  \n  memo[key] = count;\n  return count;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [4, [1, 2, 3]],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [8, [1, 2, 3]],
                "test_expected": 10,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [24, [5, 7, 3]],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [13, [2, 6, 12, 10]],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [512, [1, 5, 10, 25]],
                "test_expected": 20119,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [1000, [1, 5, 10, 25]],
                "test_expected": 142511,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [240, [1, 2, 3, 4, 5, 6, 7, 8, 9]],
                "test_expected": 1525987916,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "arrayStepper": {
        "refName": "arrayStepper",
        "refNumber": 44,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Array Stepper",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function, arrayStepper, that takes in an array of numbers as an argument. You start at the first position of the array. The function should return a boolean indicating whether or not it is possible to reach the last position of the array. When situated at some position of the array, you may take a maximum number of steps based on the number at that position.</p>",
        "examples": {
            "example1": {
                "input": "numbers = [2, 4, 2, 0, 0, 1]",
                "output": "The answer is true. We start at idx 0, we could take 1 step or 2 steps forward. The correct choice is to take 1 step to idx 1. Then take 4 steps forward to the end at idx 5."
            },
            "example2": {
                "input": "numbers = [2, 3, 2, 0, 0, 1]",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function arrayStepper(numbers, i = 0, memo = {}) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of numbers\n// Time: O(n^2)\n// Space: O(n)\nfunction arrayStepper(numbers, i = 0, memo = {}) {\n  if (i in memo) return memo[i];\n  if (i >= numbers.length - 1) return true;\n  const maxStep = numbers[i];\n  for (let step = 1; step <= maxStep; step += 1) {\n    if (arrayStepper(numbers, i + step, memo) === true) {\n      memo[i] = true;\n      return true;\n    }\n  }\n  memo[i] = false;\n  return false;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[2, 4, 2, 0, 0, 1]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[2, 3, 2, 0, 0, 1]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[3, 1, 3, 1, 0, 1]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[4, 1, 5, 1, 1, 1, 0, 4]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [[4, 1, 2, 1, 1, 1, 0, 4]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [[1, 1, 1, 1, 1, 0]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [[1, 1, 1, 1, 0, 0]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [
                    [
                        31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7,
                        6, 5, 3, 2, 1, 0, 0, 0
                    ]
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "maxPalinSubsequence": {
        "refName": "maxPalinSubsequence",
        "refNumber": 45,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Max Palin Subsequence",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function, maxPalinSubsequence, that takes in a string as an argument. The function should return the length of the longest subsequence of the string that is also a palindrome.</p><p>A subsequence of a string can be created by deleting any characters of the string, while maintaining the relative order of characters.</p>",
        "examples": {
            "example1": {
                "input": "str = 'luwxult'",
                "output": "5"
            },
            "example2": {
                "input": "str = 'xyzaxxzy'",
                "output": "6"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function maxPalinSubsequence(str, i = 0, j = str.length - 1, memo = {}) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of the string\n// Time: O(n^2)\n// Space: O(n^2)\nfunction maxPalinSubsequence(str, i = 0, j = str.length - 1, memo = {}) {\n    const key = i + ',' + j;\n    if (key in memo) return memo[key];\n  \n    if (i === j) return 1;\n    \n    if (i > j) return 0;\n  \n    if (str[i] === str[j]) {\n      memo[key] = 2 + maxPalinSubsequence(str, i + 1, j - 1, memo);\n    } else {\n      memo[key] = Math.max(\n        maxPalinSubsequence(str, i + 1, j, memo),\n        maxPalinSubsequence(str, i, j - 1, memo)\n      );\n    }\n  \n    return memo[key];\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["luwxult"],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["xyzaxxzy"],
                "test_expected": 6,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["lol"],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["boabcdefop"],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["z"],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["chartreusepugvicefree"],
                "test_expected": 7,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": ["qwueoiuahsdjnweuueueunasdnmnqweuzqwerty"],
                "test_expected": 15,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": ["enamelpinportlandtildecoldpressedironyflannelsemioticsedisonbulbfashionaxe"],
                "test_expected": 31,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "overlapSubsequence": {
        "refName": "overlapSubsequence",
        "refNumber": 46,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Overlap Subsequence",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function, overlapSubsequence, that takes in two strings as arguments. The function should return the length of the longest overlapping subsequence.</p><p>A subsequence of a string can be created by deleting any characters of the string, while maintaining the relative order of characters.</p>",
        "examples": {
            "example1": {
                "input": "str1 = 'dogs'\nstr2 = 'daogt'",
                "output": "3"
            },
            "example2": {
                "input": "str1 = 'xcyats'\nstr2 = 'criaotsi'",
                "output": "4"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function overlapSubsequence(str1, str2, i = 0, j = 0, memo = {}) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of str1\n// m = length of str2\n// Time: O(nm)\n// Space: O(nm)\nfunction overlapSubsequence(str1, str2, i = 0, j = 0, memo = {}) {\n  const key = i + ',' + j;\n  if (key in memo) return memo[key];\n  if (i === str1.length || j === str2.length) return 0;\n  if (str1[i] === str2[j]) {\n    memo[key] = 1 + overlapSubsequence(str1, str2, i + 1, j + 1, memo);\n  } else {\n    memo[key] = Math.max(\n      overlapSubsequence(str1, str2, i + 1, j, memo),\n      overlapSubsequence(str1, str2, i, j + 1, memo)\n    );\n  }\n  return memo[key];\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["dogs", "daogt"],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["xcyats", "criaotsi"],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["xfeqortsver", "feeeuavoeqr"],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["kinfolklivemustache", "bespokekinfolksnackwave"],
                "test_expected": 11,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["mumblecorebeardleggingsauthenticunicorn", "succulentspughumblemeditationlocavore"],
                "test_expected": 15,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "canConcat": {
        "refName": "canConcat",
        "refNumber": 47,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Can Concat",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function, canConcat, that takes in a string and an array of words as arguments. The function should return boolean indicating whether or not it is possible to concatenate words of the array together to form the string.</p><p>You may reuse words of the array as many times as needed.</p>",
        "examples": {
            "example1": {
                "input": "str = 'oneisnone'\nwords = ['one', 'none', 'is']",
                "output": "true"
            },
            "example2": {
                "input": "tr = 'oneisnone'\nwords = ['on', 'e', 'is']",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function canConcat(s, words, memo = {}) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// s = length of string\n// w = # of words\n// Time: ~O(sw)\n// Space: O(s)\nfunction canConcat(s, words, memo = {}) {\n  if (s in memo) return memo[s];\n  \n  if (s.length === 0) return true;\n  \n  for (let word of words) {\n    if (s.startsWith(word)) {\n      const suffix = s.slice(word.length);\n      if (canConcat(suffix, words, memo)) {\n        memo[s] = true;\n        return true\n      }\n    }\n  }\n  \n  memo[s] = false;\n  return false;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["oneisnone", ["one", "none", "is"]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["oneisnone", ["on", "e", "is"]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["oneisnone", ["on", "e", "is", "n"]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["foodisgood", ["is", "g", "ood", "f"]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["santahat", ["santah", "hat"]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["santahat", ["santah", "san", "hat", "tahat"]],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": ["rrrrrrrrrrrrrrrrrrrrrrrrrrx", ["r", "rr", "rrr", "rrrr", "rrrrr", "rrrrrr"]],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "quickestConcat": {
        "refName": "quickestConcat",
        "refNumber": 48,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Quickest Concat",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function, quickestConcat, that takes in a string and an array of words as arguments. The function should return the minimum number of words needed to build the string by concatenating words of the array.</p><p>You may use words of the array as many times as needed.</p>",
        "examples": {
            "example1": {
                "input": "str = 'caution'\nwords = ['ca', 'ion', 'caut', 'ut']",
                "output": "2"
            },
            "example2": {
                "input": "str = 'caution'\nwords = ['ion', 'caut', 'caution']",
                "output": "1"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function quickestConcat(s, words) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// s = length of string\n// w = # of words\n// Time: ~O(sw)\n// Space: O(s)\nfunction quickestConcat(s, words) {\n  const result = _quickestConcat(s, words);\n  if (result === Infinity) {\n    return -1;\n  } else {\n    return result;\n  }\n}\nconst _quickestConcat = (s, words, memo = {}) => {\n  if (s in memo) return memo[s];\n  if (s === '') return 0;\n  let min = Infinity;\n  for (let word of words) {\n    if (s.startsWith(word)) {\n      const suffix = s.slice(word.length);\n      const attempt = 1 + _quickestConcat(suffix, words, memo);\n      min = Math.min(min, attempt);\n    }\n  }\n  memo[s] = min;\n  return min;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["caution", ["ca", "ion", "caut", "ut"]],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["caution", ["ion", "caut", "caution"]],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["respondorreact", ["re", "or", "spond", "act", "respond"]],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["simchacindy", ["sim", "simcha", "acindy", "ch"]],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["simchacindy", ["sim", "simcha", "acindy"]],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["uuuuuu", ["u", "uu", "uuu", "uuuu"]],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": ["rongbetty", ["wrong", "bet"]],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": ["uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu", ["u", "uu", "uuu", "uuuu", "uuuuu"]],
                "test_expected": 7,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "pairedParentheses": {
        "refName": "pairedParentheses",
        "refNumber": 49,
        "category": "Stacks & Queues",
        "difficulty": "Easy",
        "title": "Paired Parentheses",
        "tags": ["Easy", "Stacks & Queues"],
        "description": "<p>Write a function, pairedParentheses, that takes in a string as an argument. The function should return a boolean indicating whether or not the string has well-formed parentheses.</p><p>You may assume the string contains only alphabetic characters, '(', or ')'.</p>",
        "examples": {
            "example1": {
                "input": "input = '(david)((abby))'",
                "output": "true"
            },
            "example2": {
                "input": "input = '()rose(jeff'",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function pairedParentheses(str) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of string\n// Time: O(n)\n// Space: O(1)\nfunction pairedParentheses(str) {\n    let counter = 0;\n    for (const char of str) {\n        if (char === '(') counter++;\n        if (char === ')') {\n            if (counter === 0) return false;\n            counter--;\n        }\n    }\n    return counter === 0;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["(david)((abby))"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["()rose(jeff"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [")("],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["()"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["(((potato())))"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["(())(water)()"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": ["(())(water()()"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [""],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_9": {
                "test_input": ["))()"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "befittingBrackets": {
        "refName": "befittingBrackets",
        "refNumber": 50,
        "category": "Stacks & Queues",
        "difficulty": "Easy",
        "title": "Befitting Brackets",
        "tags": ["Easy", "Stacks & Queues"],
        "description": "<p>Write a function, befittingBrackets, that takes in a string as an argument. The function should return a boolean indicating whether or not the string contains correctly matched brackets.</p><p>You may assume the string contains only characters: ( ) [ ]</p>",
        "examples": {
            "example1": {
                "input": "input = '(){}'",
                "output": "true"
            },
            "example2": {
                "input": "input = '[][}'",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function befittingBrackets(str) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of string\n// Time: O(n)\n// Space: O(n)\nfunction befittingBrackets(str) {\n  const stack = [];\n  \n  const brackets = {\n    '(': ')',\n    '[': ']',\n    '{': '}'\n  };\n  \n  for (let char of str) {\n    if (char in brackets) {\n      stack.push(brackets[char]);\n    } else {\n      if (stack.length > 0 && stack[stack.length - 1] === char) {\n        stack.pop();\n      } else {\n        return false;\n      }\n    }\n  }\n  \n  return stack.length === 0;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["(){}[](())"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["({[]})"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["[][}"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["{[]}({}"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["[]{}(}[]"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["[]{}()[]"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": ["]{}"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [""],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_9": {
                "test_input": ["{[(}])"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "decompressBraces": {
        "refName": "decompressBraces",
        "refNumber": 51,
        "category": "Stacks & Queues",
        "difficulty": "Easy",
        "title": "Decompress Braces",
        "tags": ["Easy", "Stacks & Queues"],
        "description": "<p>Write a function, decompressBraces, that takes in a compressed string as an argument. The function should return the string decompressed.</p><p>The compression format of the input string is 'n{subString}', where the subString within braces should be repeated n times.</p><p>You may assume that every number n is guaranteed to be an integer between 1 through 9.</p><p>You may assume that the input is valid and the decompressed string will only contain alphabetic characters.</p>",
        "examples": {
            "example1": {
                "input": "input = '2{q}3{tu}v'",
                "output": "'qqtututuv'"
            },
            "example2": {
                "input": "input = 'ch3{ao}",
                "output": "'chaoaoao'"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function decompressBraces(s) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// s = length of string\n// m = count of brace pairs\n// Time: O((9^m) * s)\n// Space: O((9^m) * s)\nfunction decompressBraces(s) {\n  const nums = '123456789';\n  const stack = [];\n  for (let char of s) {\n    if (nums.includes(char)) {\n      stack.push(Number(char));\n    } else {\n      if (char === '}') {\n        let segment = '';\n        while (typeof stack[stack.length - 1] !== 'number') {\n          const popped = stack.pop();\n          segment = popped + segment;\n        }\n        const number = stack.pop();\n        stack.push(repeat(segment, number));\n      } else if (char !== '{') {\n        stack.push(char);\n      }\n    }\n  }\n  \n  return stack.join('');\n};\nconst repeat = (str, n) => {\n  let result = '';\n  for (let i = 0; i < n; i += 1) {\n    result += str;\n  }\n  return result;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["2{q}3{tu}v"],
                "test_expected": "qqtututuv",
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["ch3{ao}"],
                "test_expected": "chaoaoao",
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["2{y3{o}}s"],
                "test_expected": "yoooyooos",
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["z3{a2{xy}b}"],
                "test_expected": "zaxyxybaxyxybaxyxyb",
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["2{3{r4{e}r}io}"],
                "test_expected": "reeeerreeeerreeeerioreeeerreeeerreeeerio",
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["go3{spinn2{ing}s}"],
                "test_expected": "gospinningingsspinningingsspinningings",
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": ["2{l2{if}azu}l"],
                "test_expected": "lififazulififazul",
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": ["3{al4{ec}2{icia}}"],
                "test_expected": "alececececiciaiciaalececececiciaiciaalececececiciaicia",
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "nestingScore": {
        "refName": "nestingScore",
        "refNumber": 52,
        "category": "Stacks & Queues",
        "difficulty": "Easy",
        "title": "Nesting Score",
        "tags": ["Easy", "Stacks & Queues"],
        "description": "<p>Write a function, nestingScore, that takes in a string of brackets as an argument. The function should return the score of the string according to the following rules:</p><ul><li>[] is worth 1 point</li><li>XY is worth m + n points where X, Y are substrings of well-formed brackets and m, n are their respective scores</li><li>[S] is worth 2 * k points where S is a substring of well-formed brackets and k is the score of that substring</li></ul><p>You may assume that the input only contains well-formed square brackets.</p>",
        "examples": {
            "example1": {
                "input": "input = '[]'",
                "output": "1"
            },
            "example2": {
                "input": "input = '[][][]'",
                "output": "3"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function nestingScore(str) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of string\n// Time: O(n)\n// Space: O(n)\nfunction nestingScore(str) {\n  const stack = [0];\n  for (let char of str) {\n    if (char === '[') {\n      stack.push(0);\n    } else {\n      const popped = stack.pop();\n      if (popped === 0) {\n        stack[stack.length - 1] += 1;\n      } else {\n        stack[stack.length - 1] += 2 * popped;\n      }\n    }\n  }\n  \n  return stack[0];\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["[]"],
                "test_expected": 1,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["[][][]"],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["[[]]"],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["[[][]]"],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["[[][][]]"],
                "test_expected": 6,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["[[][]][]"],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": ["[][[][]][[]]"],
                "test_expected": 7,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": ["[[[[[[[][]]]]]]][]"],
                "test_expected": 129,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "subsets": {
        "refName": "subsets",
        "refNumber": 53,
        "category": "Recursion",
        "difficulty": "Easy",
        "title": "SubSets",
        "tags": ["Easy", "Recursion"],
        "description": "<p>Write a function, subsets, that takes in an array as an argument. The function should return a 2D array where each subarray represents one of the possible subsets of the array.</p><p>The elements within the subsets and the subsets themselves may be returned in any order.</p><p>You may assume that the input array contains unique elements.</p>",
        "examples": {
            "example1": {
                "input": "elements = ['a', 'b']",
                "output": "[[], ['b'], ['a'], ['a', 'b']]"
            },
            "example2": {
                "input": "elements = ['a', 'b', 'c']",
                "output": "[[], ['c'], ['b'], ['b', 'c'], ['a'], ['a', 'c'], ['a', 'b'], ['a', 'b', 'c']];"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function subSets(elements) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of elements array\n// Time: ~O(2^n)\n// Space: ~O(2^n)\nfunction subSets(elements) {\n  if (elements.length === 0) return [[]];\n  const ele = elements[0];\n  const remainingElements = elements.slice(1);\n  const subsetsWithoutEle = subSets(remainingElements);\n  const subsetsWithEle = subsetsWithoutEle.map((sub) => [ele, ...sub]);\n  return [...subsetsWithoutEle, ...subsetsWithEle];\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [["a", "b"]],
                "test_expected": [[], ["b"], ["a"], ["a", "b"]],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [["a", "b", "c"]],
                "test_expected": [[], ["c"], ["b"], ["b", "c"], ["a"], ["a", "c"], ["a", "b"], ["a", "b", "c"]],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [["x"]],
                "test_expected": [[], ["x"]],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[]],
                "test_expected": [[]],
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [["q", "r", "s", "t"]],
                "test_expected": [
                    [],
                    ["t"],
                    ["s"],
                    ["s", "t"],
                    ["r"],
                    ["r", "t"],
                    ["r", "s"],
                    ["r", "s", "t"],
                    ["q"],
                    ["q", "t"],
                    ["q", "s"],
                    ["q", "s", "t"],
                    ["q", "r"],
                    ["q", "r", "t"],
                    ["q", "r", "s"],
                    ["q", "r", "s", "t"]
                ],
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "permutations": {
        "refName": "permutations",
        "refNumber": 54,
        "category": "Recursion",
        "difficulty": "Easy",
        "title": "Permutations",
        "tags": ["Easy", "Recursion"],
        "description": "<p>Write a function, permutations, that takes in an array an argument. The function should return a 2D array where each subarray represents one of the possible permutations of the array.</p><p>The subarrays may be returned in any order.</p><p>You may assume that the input array contains unique elements.</p>",
        "examples": {
            "example1": {
                "input": "items = ['a', 'b', 'c']",
                "output": "[   ['a', 'b', 'c'],   ['b', 'a', 'c'],   ['b', 'c', 'a'],   ['a', 'c', 'b'],   ['c', 'a', 'b'],   ['c', 'b', 'a'], ];"
            },
            "example2": {
                "input": "items = ['red', 'blue']",
                "output": "[   ['red', 'blue'],   ['blue', 'red'], ];"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function permutations(items) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of items array\n// Time: ~O(n!)\n// Space: ~O(n!)\nfunction permutations(items) {\n  if (items.length === 0) return [[]];\n  const first = items[0];\n  const perms = permutations(items.slice(1));\n  const fullPermutations = [];\n  for (let perm of perms) {\n    for (let i = 0; i <= perm.length; i += 1) {\n      fullPermutations.push([...perm.slice(0, i), first, ...perm.slice(i)]);\n    }\n  }\n  return fullPermutations;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [["a", "b", "c"]],
                "test_expected": [
                    ["a", "b", "c"],
                    ["b", "a", "c"],
                    ["b", "c", "a"],
                    ["a", "c", "b"],
                    ["c", "a", "b"],
                    ["c", "b", "a"]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [["red", "blue"]],
                "test_expected": [
                    ["red", "blue"],
                    ["blue", "red"]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[8, 2, 1, 4]],
                "test_expected": [
                    [8, 2, 1, 4],
                    [2, 8, 1, 4],
                    [2, 1, 8, 4],
                    [2, 1, 4, 8],
                    [8, 1, 2, 4],
                    [1, 8, 2, 4],
                    [1, 2, 8, 4],
                    [1, 2, 4, 8],
                    [8, 1, 4, 2],
                    [1, 8, 4, 2],
                    [1, 4, 8, 2],
                    [1, 4, 2, 8],
                    [8, 2, 4, 1],
                    [2, 8, 4, 1],
                    [2, 4, 8, 1],
                    [2, 4, 1, 8],
                    [8, 4, 2, 1],
                    [4, 8, 2, 1],
                    [4, 2, 8, 1],
                    [4, 2, 1, 8],
                    [8, 4, 1, 2],
                    [4, 8, 1, 2],
                    [4, 1, 8, 2],
                    [4, 1, 2, 8]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[]],
                "test_expected": [[]],
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "createCombinations": {
        "refName": "createCombinations",
        "refNumber": 55,
        "category": "Recursion",
        "difficulty": "Easy",
        "title": "Create Combinations",
        "tags": ["Easy", "Recursion"],
        "description": "<p>Write a function, createCombinations, that takes in an array and a length as arguments. The function should return a 2D array representing all of the combinations of the specifized length.</p><p>The items within the combinations and the combinations themselves may be returned in any order.</p><p>You may assume that the input array contains unique elements and 1 <= k <= items.length.</p>",
        "examples": {
            "example1": {
                "input": "items = ['a', 'b', 'c']\nK = 2",
                "output": "[   ['a', 'b'],   ['a', 'c'],   ['b', 'c'], ];"
            },
            "example2": {
                "input": "items = ['q', 'r', 's', 't']\nK = 2",
                "output": "[   ['q', 'r'],   ['q', 's'],   ['q', 't'],   ['r', 's'],   ['r', 't'],   ['s', 't'], ];"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function createCombinations(items, k) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of items\n// k = target length\n// Time: ~O(n choose k)\n// Space: ~O(n choose k)\n// Note: 'n Choose k' refers to the binomial coefficient.\nfunction createCombinations(items, k) {\n  if (items.length < k) return [];\n  if (k === 0) return [[]];\n  const first = items[0];\n  const combosWithFirst = [];\n  for (let combo of createCombinations(items.slice(1), k - 1)) {\n    combosWithFirst.push([first, ...combo]);\n  }\n  const combosWithoutFirst = createCombinations(items.slice(1), k);\n  return [...combosWithFirst, ...combosWithoutFirst];\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [["a", "b", "c"], 2],
                "test_expected": [
                    ["a", "b"],
                    ["a", "c"],
                    ["b", "c"]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [["q", "r", "s", "t"], 2],
                "test_expected": [
                    ["q", "r"],
                    ["q", "s"],
                    ["q", "t"],
                    ["r", "s"],
                    ["r", "t"],
                    ["s", "t"]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [["q", "r", "s", "t"], 3],
                "test_expected": [
                    ["q", "r", "s"],
                    ["q", "r", "t"],
                    ["q", "s", "t"],
                    ["r", "s", "t"]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[1, 28, 94], 3],
                "test_expected": [[1, 28, 94]],
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "parentheticalPossibilities": {
        "refName": "parentheticalPossibilities",
        "refNumber": 56,
        "category": "Recursion",
        "difficulty": "Easy",
        "title": "Parenthetical Possibilities",
        "tags": ["Easy", "Recursion"],
        "description": "<p>Write a function, parentheticalPossibilities, that takes in a string as an argument. The function should return an array containing all of the strings that could be generated by expanding all parentheses of the string into its possibilities.</p><p>For example, the possibilities for 'x(mn)yz' are 'xmyz', 'xnyz'.</p>",
        "examples": {
            "example1": {
                "input": "string = 'x(mn)yz'",
                "output": "['xmyz', 'xnyz']"
            },
            "example2": {
                "input": "string = '(qr)ab(stu)c'",
                "output": "['qabsc', 'qabtc', 'qabuc', 'rabsc', 'rabtc', 'rabuc']"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function parentheticalPossibilities(s) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of the string, m = length of largest parenthetical group\n// Time: ~O(m^n)\n// Space: ~O(m^n)\nfunction parentheticalPossibilities(s) {\n  if (s === '') return [''];\n  const { remaining, chars } = getOptions(s);\n  const suffixes = parentheticalPossibilities(remaining);\n  const possibilities = [];\n  for (let char of chars) {\n    for (let suffix of suffixes) {\n      possibilities.push(char + suffix);\n    }\n  }\n  return possibilities;\n}\nconst getOptions = (s) => {\n  if (s[0] === '(') {\n    const endIdx = s.indexOf(')');\n    const remaining = s.slice(endIdx + 1);\n    const chars = s.slice(1, endIdx).split('');\n    return { remaining, chars };\n  } else {\n    const remaining = s.slice(1);\n    const chars = [s[0]];\n    return { remaining, chars };\n  }\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["x(mn)yz"],
                "test_expected": ["xmyz", "xnyz"],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["(qr)ab(stu)c"],
                "test_expected": ["qabsc", "qabtc", "qabuc", "rabsc", "rabtc", "rabuc"],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["taco"],
                "test_expected": ["taco"],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [""],
                "test_expected": [""],
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["(etc)(blvd)(cat)"],
                "test_expected": [
                    "ebc",
                    "eba",
                    "ebt",
                    "elc",
                    "ela",
                    "elt",
                    "evc",
                    "eva",
                    "evt",
                    "edc",
                    "eda",
                    "edt",
                    "tbc",
                    "tba",
                    "tbt",
                    "tlc",
                    "tla",
                    "tlt",
                    "tvc",
                    "tva",
                    "tvt",
                    "tdc",
                    "tda",
                    "tdt",
                    "cbc",
                    "cba",
                    "cbt",
                    "clc",
                    "cla",
                    "clt",
                    "cvc",
                    "cva",
                    "cvt",
                    "cdc",
                    "cda",
                    "cdt"
                ],
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "substituteSynonyms": {
        "refName": "substituteSynonyms",
        "refNumber": 57,
        "category": "Recursion",
        "difficulty": "Easy",
        "title": "Substitute Synonyms",
        "tags": ["Easy", "Recursion"],
        "description": "<p>Write a function, substitutingSynonyms, that takes in a sentence and an object as arguments. The object contains words as keys whose values are arrays containing synonyms. The function should return an array containing all possible sentences that can be formed by substituting words of the sentence with their synonyms.</p><p>You may return the possible sentences in any order, as long as you return all of them.</p>",
        "examples": {
            "example1": {
                "input": "const sentence = 'follow the yellow brick road'\nconst synonyms = {   follow: ['chase', 'pursue'],   yellow: ['gold', 'amber', 'lemon'], }",
                "output": "[   'chase the gold brick road',   'chase the amber brick road',   'chase the lemon brick road',   'pursue the gold brick road',   'pursue the amber brick road',   'pursue the lemon brick road', ];"
            },
            "example2": {
                "input": "const sentence = 'I think it's gonna be a long long time'; const synonyms = {   think: ['believe', 'reckon'],   long: ['lengthy', 'prolonged'], };",
                "output": "[   'I believe it's gonna be a lengthy lengthy time',   'I believe it's gonna be a lengthy prolonged time',   'I believe it's gonna be a prolonged lengthy time',   'I believe it's gonna be a prolonged prolonged time',   'I reckon it's gonna be a lengthy lengthy time',   'I reckon it's gonna be a lengthy prolonged time',   'I reckon it's gonna be a prolonged lengthy time',   'I reckon it's gonna be a prolonged prolonged time', ];"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function substituteSynonyms(sentence, synonyms) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of words in sentence\n// m = max number of synonyms for a word\n// Time: ~O(m^n)\n// Space: ~O(m^n)\nfunction substituteSynonyms(sentence, synonyms) {\n  const words = sentence.split(' ');\n  const arrays = generate(words, synonyms);\n  return arrays.map((subarray) => subarray.join(' '));\n}\nconst generate = (words, synonyms) => {\n  if (words.length === 0) return [[]];\n  const firstWord = words[0];\n  const remainingWords = words.slice(1);\n  if (firstWord in synonyms) {\n    const result = [];\n    const subarrays = generate(remainingWords, synonyms);\n    for (let synonym of synonyms[firstWord]) {\n      result.push(...subarrays.map((subarray) => [synonym, ...subarray]));\n    }\n    return result;\n  } else {\n    const subarrays = generate(remainingWords, synonyms);\n    return subarrays.map((subarray) => [firstWord, ...subarray]);\n  }\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    "follow the yellow brick road",
                    {
                        "follow": ["chase", "pursue"],
                        "yellow": ["gold", "amber", "lemon"]
                    }
                ],
                "test_expected": [
                    "chase the gold brick road",
                    "chase the amber brick road",
                    "chase the lemon brick road",
                    "pursue the gold brick road",
                    "pursue the amber brick road",
                    "pursue the lemon brick road"
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    "I think it's gonna be a long long time",
                    {
                        "think": ["believe", "reckon"],
                        "long": ["lengthy", "prolonged"]
                    }
                ],
                "test_expected": [
                    "I believe it's gonna be a lengthy lengthy time",
                    "I believe it's gonna be a lengthy prolonged time",
                    "I believe it's gonna be a prolonged lengthy time",
                    "I believe it's gonna be a prolonged prolonged time",
                    "I reckon it's gonna be a lengthy lengthy time",
                    "I reckon it's gonna be a lengthy prolonged time",
                    "I reckon it's gonna be a prolonged lengthy time",
                    "I reckon it's gonna be a prolonged prolonged time"
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    "palms sweaty knees weak arms heavy",
                    {
                        "palms": ["hands", "fists"],
                        "heavy": ["weighty", "hefty", "burdensome"],
                        "weak": ["fragile", "feeble", "frail", "sickly"]
                    }
                ],
                "test_expected": [
                    "hands sweaty knees fragile arms weighty",
                    "hands sweaty knees fragile arms hefty",
                    "hands sweaty knees fragile arms burdensome",
                    "hands sweaty knees feeble arms weighty",
                    "hands sweaty knees feeble arms hefty",
                    "hands sweaty knees feeble arms burdensome",
                    "hands sweaty knees frail arms weighty",
                    "hands sweaty knees frail arms hefty",
                    "hands sweaty knees frail arms burdensome",
                    "hands sweaty knees sickly arms weighty",
                    "hands sweaty knees sickly arms hefty",
                    "hands sweaty knees sickly arms burdensome",
                    "fists sweaty knees fragile arms weighty",
                    "fists sweaty knees fragile arms hefty",
                    "fists sweaty knees fragile arms burdensome",
                    "fists sweaty knees feeble arms weighty",
                    "fists sweaty knees feeble arms hefty",
                    "fists sweaty knees feeble arms burdensome",
                    "fists sweaty knees frail arms weighty",
                    "fists sweaty knees frail arms hefty",
                    "fists sweaty knees frail arms burdensome",
                    "fists sweaty knees sickly arms weighty",
                    "fists sweaty knees sickly arms hefty",
                    "fists sweaty knees sickly arms burdensome"
                ],
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "linkedPalindrome": {
        "refName": "linkedPalindrome",
        "refNumber": 58,
        "category": "Linked List",
        "difficulty": "Easy",
        "title": "Linked Palindrome",
        "tags": ["Easy", "Linked List"],
        "description": "<p>Write a function, linkedPalindrome, that takes in the head of a linked list as an argument. The function should return a boolean indicating whether or not the linked list is a palindrome. A palindrome is a sequence that is the same both forwards and backwards.</p>",
        "examples": {
            "example1": {
                "input": "r -> e -> d -> i -> v -> i -> d -> e -> r",
                "output": "true"
            },
            "example2": {
                "input": "a -> w -> p -> u -> b -> o",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function linkedPalindrome(head) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Solution 1\n// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction linkedPalindrome(head) {\n   const values = [];\n   let current = head;\n   while (current !== null) {\n      values.push(current.data);\n      current = current.next;\n   }\n   return values.join(',') === values.reverse().join(',');\n};\n// Solution 2\nfunction linkedPalindrome(head) {\n    let currentNode = head;\n    const stack = [];\n    while (currentNode !== null) {\n        stack.push(currentNode.data);\n        currentNode = currentNode.next;\n    }\n    currentNode = head;\n    while (currentNode !== null) {\n        const i = stack.pop();\n        if (i !== currentNode.data) return false;\n        currentNode = currentNode.next;\n    }\n    return true;\n}",
                "// Solution 2\n// n = number of nodes\n// Time: O(n)\n// Space: O(1)\nfunction linkedPalindrome(head) {\n    if (!head || !head.next) return true;\n    let slow = head;\n    let fast = head;\n    let stack = [];\n    while (fast && fast.next) {\n        stack.push(slow.data);\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    if (fast) slow = slow.next;\n    while (slow) {\n        if (slow.data !== stack.pop()) return false;\n        slow = slow.next;\n    }\n    return true;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node('r'); const b = new Node('e'); const c = new Node('d'); const d = new Node('i'); const e = new Node('v'); const f = new Node('i'); const g = new Node('d'); const h = new Node('e'); const i = new Node('r'); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; f.next = g; g.next = h; h.next = i; const val = window.linkedPalindrome(a); return ['r -> e -> d -> i -> v -> i -> d -> e -> r', val] }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() { class Node { constructor(data) { this.data = data; this.next = null; } } const a = new Node('a'); const b = new Node('w'); const c = new Node('p'); const d = new Node('u'); const e = new Node('e'); const f = new Node('b'); const g = new Node('o'); const h = new Node('s'); const i = new Node('g'); a.next = b; b.next = c; c.next = d; d.next = e; e.next = f; f.next = g; g.next = h; h.next = i; const val = window.linkedPalindrome(a); return ['a -> w -> p -> u -> b -> o', val] }",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() {   class Node {      constructor(data) {         this.data = data;         this.next = null;      }   }   const a = new Node(3);   const b = new Node(2);   const c = new Node(7);   const d = new Node(7);   const e = new Node(2);   const f = new Node(3);   a.next = b;   b.next = c;   c.next = d;   d.next = e;   e.next = f;   const val = window.linkedPalindrome(a);   return ['3 -> 2 -> 7 -> 7 -> 2 -> 3', val]}",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() {    class Node {       constructor(data) {          this.data = data;          this.next = null;       }    }    const a = new Node(3);    const b = new Node(2);    const c = new Node(4);    a.next = b;    b.next = c;    const val = window.linkedPalindrome(a);    return ['3 -> 2 -> 4', val] }",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() {    class Node {       constructor(data) {          this.data = data;          this.next = null;       }    }    const a = new Node(0);    const b = new Node(1);    const c = new Node(0);    const d = new Node(1);    const e = new Node(0);    a.next = b;    b.next = c;    c.next = d;    d.next = e;    const val = window.linkedPalindrome(a);    return ['0 -> 1 -> 0 -> 1 -> 0', val] }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_6": {
                "test_input": "function test_input() {    class Node {       constructor(data) {          this.data = data;          this.next = null;       }    }    const a = new Node(5);    const val = window.linkedPalindrome(a);    return ['5', val] }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "linkedListCycle": {
        "refName": "linkedListCycle",
        "refNumber": 59,
        "category": "Linked List",
        "difficulty": "Medium",
        "title": "Linked List Cycle",
        "tags": ["Medium", "Linked List"],
        "description": "<p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.</p><p>Return true if there is a cycle in the linked list. Otherwise, return false.</p>",
        "examples": {
            "example1": {
                "input": "head = [3,2,0,-4]\npos = 1\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
                "output": "true"
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function linkedListCycle(head) {\n    // Write your solution...\n    return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "function linkedListCycle(head) {\n  var slow = head;\n  var fast = head;\n  while (slow && fast) {\n    slow = slow.next;\n    fast = fast.next ? fast.next.next : undefined;\n    if (slow === fast) return true;\n  }\n  return false;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["geeks", "geek"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "lowestCommonAncestor": {
        "refName": "lowestCommonAncestor",
        "refNumber": 60,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "lowest Common Ancestor",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, lowestCommonAncestor, that takes in the root of a binary tree and two values. The function should return the value of the lowest common ancestor of the two values in the tree.</p><p>You may assume that the tree values are unique and the tree is non-empty.</p><p>Note that a node may be considered an ancestor of itself.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\nconst g = new Node('g');\nconst h = new Node('h');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\ne.left = g;\ne.right = h;\nlowestCommonAncestor(a, 'd', 'h'); ",
                "output": "'b'"
            },
            "example2": {
                "input": "lowestCommonAncestor(a, 'd', 'g')",
                "output": "b"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function lowestCommonAncestor(root, val1, val2) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction lowestCommonAncestor(root, val1, val2) {\n   const path1 = findPath(root, val1);\n   const path2 = findPath(root, val2);\n   const set2 = new Set(path2);\n   for (let val of path1) {\n      if (set2.has(val)) return val;\n   }\n};\nfunction findPath(root, targetVal) {\n   if (root === null) return null;\n   if (root.val === targetVal) return [root.val];\n   const leftPath = findPath(root.left, targetVal);\n   if (leftPath !== null) {\n      leftPath.push(root.val);\n      return leftPath;\n   }\n   const rightPath = findPath(root.right, targetVal);\n   if (rightPath !== null) {\n      rightPath.push(root.val);\n      return rightPath;\n   }\n   return null;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const a = new Node('a');    const b = new Node('b');    const c = new Node('c');    const d = new Node('d');    const e = new Node('e');    const f = new Node('f');    const g = new Node('g');    const h = new Node('h');    a.left = b;    a.right = c;    b.left = d;    b.right = e;    c.right = f;    e.left = g;    e.right = h;    return window.lowestCommonAncestor(a, 'd', 'h'); }",
                "test_expected": "b",
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const a = new Node('a');    const b = new Node('b');    const c = new Node('c');    const d = new Node('d');    const e = new Node('e');    const f = new Node('f');    const g = new Node('g');    const h = new Node('h');    a.left = b;    a.right = c;    b.left = d;    b.right = e;    c.right = f;    e.left = g;    e.right = h;    return window.lowestCommonAncestor(a, 'd', 'g'); }",
                "test_expected": "b",
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const a = new Node('a');    const b = new Node('b');    const c = new Node('c');    const d = new Node('d');    const e = new Node('e');    const f = new Node('f');    const g = new Node('g');    const h = new Node('h');    a.left = b;    a.right = c;    b.left = d;    b.right = e;    c.right = f;    e.left = g;    e.right = h;    return window.lowestCommonAncestor(a, 'g', 'c'); }",
                "test_expected": "a",
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const a = new Node('a');    const b = new Node('b');    const c = new Node('c');    const d = new Node('d');    const e = new Node('e');    const f = new Node('f');    const g = new Node('g');    const h = new Node('h');    a.left = b;    a.right = c;    b.left = d;    b.right = e;    c.right = f;    e.left = g;    e.right = h;    return window.lowestCommonAncestor(a, 'f', 'c'); }",
                "test_expected": "c",
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const l = new Node('l');    const m = new Node('m');    const n = new Node('n');    const o = new Node('o');    const p = new Node('p');    const q = new Node('q');    const r = new Node('r');    const s = new Node('s');    const t = new Node('t');    l.left = m;    l.right = n;    n.left = o;    n.right = p;    o.left = q;    o.right = r;    p.left = s;    p.right = t;    return window.lowestCommonAncestor(l, 'r', 'p'); }",
                "test_expected": "n",
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_6": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const l = new Node('l');    const m = new Node('m');    const n = new Node('n');    const o = new Node('o');    const p = new Node('p');    const q = new Node('q');    const r = new Node('r');    const s = new Node('s');    const t = new Node('t');    l.left = m;    l.right = n;    n.left = o;    n.right = p;    o.left = q;    o.right = r;    p.left = s;    p.right = t;    return window.lowestCommonAncestor(l, 'm', 'o'); }",
                "test_expected": "l",
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_7": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const l = new Node('l');    const m = new Node('m');    const n = new Node('n');    const o = new Node('o');    const p = new Node('p');    const q = new Node('q');    const r = new Node('r');    const s = new Node('s');    const t = new Node('t');    l.left = m;    l.right = n;    n.left = o;    n.right = p;    o.left = q;    o.right = r;    p.left = s;    p.right = t;    return window.lowestCommonAncestor(l, 't', 'q'); }",
                "test_expected": "n",
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_8": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const l = new Node('l');    const m = new Node('m');    const n = new Node('n');    const o = new Node('o');    const p = new Node('p');    const q = new Node('q');    const r = new Node('r');    const s = new Node('s');    const t = new Node('t');    l.left = m;    l.right = n;    n.left = o;    n.right = p;    o.left = q;    o.right = r;    p.left = s;    p.right = t;    return window.lowestCommonAncestor(l, 's', 'p'); }",
                "test_expected": "p",
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "flipTree": {
        "refName": "flipTree",
        "refNumber": 61,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Flip Tree",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, flipTree, that takes in the root of a binary tree. The function should flip the binary tree, turning left subtrees into right subtrees and vice-versa. This flipping should occur in-place by modifying the original tree. The function should return the root of the tree.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\nconst g = new Node('g');\nconst h = new Node('h');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\ne.left = g;\ne.right = h;\nflipTree(a); ",
                "output": ""
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function flipTree(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction flipTree(root) {\n   if (root === null) return null;\n   const left = flipTree(root.left);\n   const right = flipTree(root.right);\n   root.right = left;\n   root.left = right;\n   return root;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const a = new Node('a');    const b = new Node('b');    const c = new Node('c');    const d = new Node('d');    const e = new Node('e');    const f = new Node('f');    const g = new Node('g');    const h = new Node('h');    a.left = b;    a.right = c;    b.left = d;    b.right = e;    c.right = f;    e.left = g;    e.right = h;    return window.flipTree(a); }",
                "test_expected": {
                    "val": "a",
                    "left": {
                        "val": "c",
                        "left": {
                            "val": "f",
                            "left": null,
                            "right": null
                        },
                        "right": null
                    },
                    "right": {
                        "val": "b",
                        "left": {
                            "val": "e",
                            "left": {
                                "val": "h",
                                "left": null,
                                "right": null
                            },
                            "right": {
                                "val": "g",
                                "left": null,
                                "right": null
                            }
                        },
                        "right": {
                            "val": "d",
                            "left": null,
                            "right": null
                        }
                    }
                },
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const u = new Node('u');    const t = new Node('t');    const s = new Node('s');    const r = new Node('r');    const q = new Node('q');    const p = new Node('p');    u.left = t;    u.right = s;    s.right = r;    r.left = q;    r.right = p;    return window.flipTree(u); }",
                "test_expected": {
                    "val": "u",
                    "left": {
                        "val": "s",
                        "left": {
                            "val": "r",
                            "left": {
                                "val": "p",
                                "left": null,
                                "right": null
                            },
                            "right": {
                                "val": "q",
                                "left": null,
                                "right": null
                            }
                        },
                        "right": null
                    },
                    "right": {
                        "val": "t",
                        "left": null,
                        "right": null
                    }
                },
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const l = new Node('l');    const m = new Node('m');    const n = new Node('n');    const o = new Node('o');    const p = new Node('p');    const q = new Node('q');    const r = new Node('r');    const s = new Node('s');    const t = new Node('t');    l.left = m;    l.right = n;    n.left = o;    n.right = p;    o.left = q;    o.right = r;    p.left = s;    p.right = t;    return window.flipTree(l); }",
                "test_expected": {
                    "val": "l",
                    "left": {
                        "val": "n",
                        "left": {
                            "val": "p",
                            "left": {
                                "val": "t",
                                "left": null,
                                "right": null
                            },
                            "right": {
                                "val": "s",
                                "left": null,
                                "right": null
                            }
                        },
                        "right": {
                            "val": "o",
                            "left": {
                                "val": "r",
                                "left": null,
                                "right": null
                            },
                            "right": {
                                "val": "q",
                                "left": null,
                                "right": null
                            }
                        }
                    },
                    "right": {
                        "val": "m",
                        "left": null,
                        "right": null
                    }
                },
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const n = new Node('n');    const y = new Node('y');    const c = new Node('c');    n.left = y;    n.right = c;    return window.flipTree(n); }",
                "test_expected": {
                    "val": "n",
                    "left": {
                        "val": "c",
                        "left": null,
                        "right": null
                    },
                    "right": {
                        "val": "y",
                        "left": null,
                        "right": null
                    }
                },
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "leftyNodes": {
        "refName": "leftyNodes",
        "refNumber": 62,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Lefty Nodes",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, leftyNodes, that takes in the root of a binary tree. The function should return an array containing the left-most value on every level of the tree. The array must be ordered in a top-down fashion where the root is the first element.</p><p>Note that the left-most node on a level may not necessarily be a left child.</p>",
        "examples": {
            "example1": {
                "input": "const a = new Node('a');\nconst b = new Node('b');\nconst c = new Node('c');\nconst d = new Node('d');\nconst e = new Node('e');\nconst f = new Node('f');\nconst g = new Node('g');\nconst h = new Node('h');\na.left = b;\na.right = c;\nb.left = d;\nb.right = e;\nc.right = f;\ne.left = g;\ne.right = h;\nflipTree(a); ",
                "output": ""
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function leftyNodes(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction leftyNodes(root) {\n   const values = [];\n   const traverse = (node, level) => {\n      if (node === null) return;\n      if (values[level] === undefined) values.push(node.val);\n      traverse(node.left, level + 1);\n      traverse(node.right, level + 1);\n   };\n   traverse(root, 0);\n   return values;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() {\n   function Node(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n   }\n   const a = new Node('a');\n   const b = new Node('b');\n   const c = new Node('c');\n   const d = new Node('d');\n   const e = new Node('e');\n   const f = new Node('f');\n   const g = new Node('g');\n   const h = new Node('h');\n   a.left = b;\n   a.right = c;\n   b.left = d;\n   b.right = e;\n   c.right = f;\n   e.left = g;\n   e.right = h;\n   return window.leftyNodes(a);\n}",
                "test_expected": ["a", "b", "d", "g"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const u = new Node('u');    const t = new Node('t');    const s = new Node('s');    const r = new Node('r');    const q = new Node('q');    const p = new Node('p');    u.left = t;    u.right = s;    s.right = r;    r.left = q;    r.right = p;    return window.leftyNodes(u); }",
                "test_expected": ["u", "t", "r", "q"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const l = new Node('l');    const m = new Node('m');    const n = new Node('n');    const o = new Node('o');    const p = new Node('p');    const q = new Node('q');    const r = new Node('r');    const s = new Node('s');    const t = new Node('t');    l.left = m;    l.right = n;    n.left = o;    n.right = p;    o.left = q;    o.right = r;    p.left = s;    p.right = t;    return window.leftyNodes(l); }",
                "test_expected": ["l", "m", "o", "q"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const n = new Node('n');    const y = new Node('y');    const c = new Node('c');    n.left = y;    n.right = c;    return window.leftyNodes(n); }",
                "test_expected": ["n", "y"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const i = new Node('i');    const n = new Node('n');    const s = new Node('s');    const t = new Node('t');    i.right = n;    n.left = s;    n.right = t;    return window.leftyNodes(i); }",
                "test_expected": ["i", "n", "s"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_6": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    return window.leftyNodes(null); }",
                "test_expected": [],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "canColor": {
        "refName": "canColor",
        "refNumber": 63,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Can Color",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, canColor, that takes in an object representing the adjacency list of an undirected graph. The function should return a boolean indicating whether or not it is possible to color nodes of the graph using two colors in such a way that adjacent nodes are always different colors.</p><p>For example, given this graph:</p><p>x-y-z</p><p>It is possible to color the nodes by using red for x and z, then use blue for y. So the answer is true. For example, given this graph:</p>{q:[s,r],s:[q,r],r:[q,s]</p><p>It is not possible to color the nodes without making two adjacent nodes the same color. So the answer is false.</p>",
        "examples": {
            "example1": {
                "input": "{   x: ['y'],   y: ['x','z'],   z: ['y'] }",
                "output": "true"
            },
            "example2": {
                "input": "{   q: ['r', 's'],   r: ['q', 's'],   s: ['r', 'q'] }",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function canColor(graph) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes \n// Time: O(n^2) \n// Space: O(n) \nfunction canColor(graph) {\n   const coloring = {};\n   for (let node in graph) {\n      if (!(node in coloring)) {\n         if (!valid(graph, node, coloring, false)) {\n            return false;\n         }\n      }\n   }\n   return true;\n};\nfunction valid(graph, node, coloring, currentColor) {\n   if (node in coloring) return currentColor === coloring[node];\n   coloring[node] = currentColor;\n   for (let neighbor of graph[node]) {\n      if (!valid(graph, neighbor, coloring, !currentColor)) {\n         return false;\n      }\n   }\n   return true;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "x": ["y"],
                        "y": ["x", "z"],
                        "z": ["y"]
                    }
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    {
                        "q": ["r", "s"],
                        "r": ["q", "s"],
                        "s": ["r", "q"]
                    }
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    {
                        "a": ["b", "c", "d"],
                        "b": ["a"],
                        "c": ["a"],
                        "d": ["a"]
                    }
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    {
                        "a": ["b", "c", "d"],
                        "b": ["a"],
                        "c": ["a", "d"],
                        "d": ["a", "c"]
                    }
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    {
                        "h": ["i", "k"],
                        "i": ["h", "j"],
                        "j": ["i", "k"],
                        "k": ["h", "j"]
                    }
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    {
                        "z": []
                    }
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [
                    {
                        "h": ["i", "k"],
                        "i": ["h", "j"],
                        "j": ["i", "k"],
                        "k": ["h", "j"],
                        "q": ["r", "s"],
                        "r": ["q", "s"],
                        "s": ["r", "q"]
                    }
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "tolerantTeams": {
        "refName": "tolerantTeams",
        "refNumber": 64,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Tolerant Teams",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, tolerantTeams, that takes in an array of rivalries as an argument. A rivalry is a pair of people who should not be placed on the same team. The function should return a boolean indicating whether or not it is possible to separate people into two teams, without rivals being on the same team. The two teams formed do not have to be the same size.</p>",
        "examples": {
            "example1": {
                "input": "[ ['philip', 'seb'], ['raj', 'nader'] ]",
                "output": "true"
            },
            "example2": {
                "input": "[ ['philip', 'seb'], ['raj', 'nader'], ['raj', 'philip'], ['seb', 'raj'] ]",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function tolerantTeams(graph) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// e = number of rivalries\n// n = number of people\n// Time: O(e)\n// Space: O(n)\nfunction tolerantTeams(rivalries) {\n  const graph = buildGraph(rivalries);\n  \n  const coloring = {};\n  for (let node in graph) {\n    if (!(node in coloring) && !isBipartite(graph, node, coloring, false)) {\n      return false;\n    }\n  }\n  \n  return true;\n};\nfunction isBipartite(graph, node, coloring, currentColor) {\n  if (node in coloring) return coloring[node] === currentColor;\n  \n  coloring[node] = currentColor;\n  \n  for (let neighbor of graph[node]) {\n    if (!isBipartite(graph, neighbor, coloring, !currentColor)) {\n      return false;\n    }\n  }\n  \n  return true;\n};\nfunction buildGraph(rivalries) {\n  const graph = {};\n  for (let pair of rivalries) {\n    const [a, b] = pair;\n    if (!(a in graph)) graph[a] = [];\n    if (!(b in graph)) graph[b] = [];\n    graph[a].push(b);\n    graph[b].push(a);\n  };\n  \n  return graph;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        ["philip", "seb"],
                        ["raj", "nader"]
                    ]
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        ["philip", "seb"],
                        ["raj", "nader"],
                        ["raj", "philip"],
                        ["seb", "raj"]
                    ]
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [
                        ["cindy", "anj"],
                        ["alex", "matt"],
                        ["alex", "cindy"],
                        ["anj", "matt"],
                        ["brando", "matt"]
                    ]
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        ["alex", "anj"],
                        ["alex", "matt"],
                        ["alex", "cindy"],
                        ["anj", "matt"],
                        ["brando", "matt"]
                    ]
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    [
                        ["alan", "jj"],
                        ["betty", "richard"],
                        ["jj", "simcha"],
                        ["richard", "christine"]
                    ]
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    [
                        ["alan", "jj"],
                        ["betty", "richard"],
                        ["jj", "simcha"],
                        ["richard", "christine"]
                    ]
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [
                    [
                        ["alan", "jj"],
                        ["jj", "richard"],
                        ["betty", "richard"],
                        ["jj", "simcha"],
                        ["richard", "christine"]
                    ]
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [
                    [
                        ["alan", "jj"],
                        ["betty", "richard"],
                        ["betty", "christine"],
                        ["jj", "simcha"],
                        ["richard", "christine"]
                    ]
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "rareRouting": {
        "refName": "rareRouting",
        "refNumber": 65,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Rare Routing",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, rareRouting, that takes in a number of cities (n) and a two dimensional array where each subarray represents a direct road that connects a pair of cities. The function should return a boolean indicating whether or not there exists a unique route for every pair of cities. A route is a sequence of roads that does not visit a city more than once.</p><p>Cities will be numbered 0 to n - 1.</p><p>You can assume that all roads are two-way roads. This means if there is a road between A and B, then you can use that road to go from A to B or go from B to A.</p>",
        "examples": {
            "example1": {
                "input": "For example, given these roads:\n0 --- 1\n| \\n|  \\n|   \\n2    3\nThere is a unique route for between every pair of cities.\nSo the answer is true.\nFor example, given these roads:\n0 --- 1\n| \\n|  \\n|   \\n2 -- 3\nThere are two routes that can be used to travel from city 1 to city 2:\n- first route:  1, 0, 2\n- second route: 1, 0, 3, 2 \nThe answer is false, because routes should be unique.",
                "output": "true"
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function rareRouting(n, roads) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes\n// Time: O(n^2)\n// Space: O(n)\nfunction rareRouting(n, roads) {\n  const graph = makeGraph(n, roads);\n  const visited = new Set();\n  const valid = validate(graph, '0', visited, null);\n  return valid && visited.size === n;\n};\nfunction validate(graph, node, visited, lastNode) {\n  if (visited.has(node)) return false;\n  \n  visited.add(node);\n  \n  for (let neighbor of graph[node]) {\n    if (neighbor !== lastNode) {\n      if (!validate(graph, neighbor, visited, node)) {\n        return false;\n      }\n    }\n  }\n  \n  return true;\n};\nfunction makeGraph(n, roads) {\n  const graph = {};\n  for (let city = 0; city < n; city += 1) {\n    graph[city] = [];\n  }\n  \n  for (let road of roads) {\n    const [a, b] = road;\n    graph[a].push(String(b));\n    graph[b].push(String(a));\n  }\n  \n  return graph;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    4,
                    [
                        [0, 1],
                        [0, 2],
                        [0, 3]
                    ]
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    4,
                    [
                        [0, 1],
                        [0, 2],
                        [0, 3],
                        [3, 2]
                    ]
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    6,
                    [
                        [1, 2],
                        [5, 4],
                        [3, 0],
                        [0, 1],
                        [0, 4]
                    ]
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    6,
                    [
                        [1, 2],
                        [4, 1],
                        [5, 4],
                        [3, 0],
                        [0, 1],
                        [0, 4]
                    ]
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    4,
                    [
                        [0, 1],
                        [3, 2]
                    ]
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "maxIncreasingSubseq": {
        "refName": "maxIncreasingSubseq",
        "refNumber": 66,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Max Increasing Subseq",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function, maxIncreasingSubseq, that takes in an array of numbers as an argument. The function should return the length of the longest subsequence of strictly increasing numbers.</p><p>A subsequence of an array can be created by deleting any elements of the array, while maintaining the relative order of elements.</p>",
        "examples": {
            "example1": {
                "input": "numbers = [4, 18, 20, 10, 12, 15, 19]",
                "output": "5"
            },
            "example2": {
                "input": "numbers = [12, 9, 2, 5, 4, 32, 90, 20]",
                "output": "4"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function maxIncreasingSubseq(numbers) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of array\n// Time: O(n^2)\n// Space: O(n^2)\nfunction maxIncreasingSubseq(numbers, i = 0, previous = -Infinity, memo = {}) {\n   const key = i + ',' + previous;\n   if (key in memo) return memo[key];\n   if (i === numbers.length) return 0;\n   const options = [];\n   const dontTakeCurrent = maxIncreasingSubseq(numbers, i + 1, previous, memo);\n   options.push(dontTakeCurrent);\n   const current = numbers[i];\n   if (current > previous) {\n      const takeCurrent = 1 + maxIncreasingSubseq(numbers, i + 1, current, memo);\n      options.push(takeCurrent);\n   }\n   memo[key] = Math.max(...options);\n   return memo[key];\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[4, 18, 20, 10, 12, 15, 19]],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[12, 9, 2, 5, 4, 32, 90, 20]],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[42, 50, 51, 60, 55, 70, 4, 5, 70]],
                "test_expected": 5,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[7, 14, 10, 12]],
                "test_expected": 3,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]],
                "test_expected": 21,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    [
                        1, 2, 3, 4, 5, 12, 6, 30, 7, 8, 9, 10, 11, 12, 13, 10, 18, 14, 15, 16, 17, 18, 19, 20, 21, 100,
                        104
                    ]
                ],
                "test_expected": 23,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [
                    [
                        1, 2, 300, 3, 4, 305, 5, 12, 6, 30, 7, 8, 9, 10, 10, 10, 15, 11, 12, 13, 10, 18, 14, 15, 16, 17,
                        18, 19, 20, 21, 100, 101, 102, 103, 104, 105
                    ]
                ],
                "test_expected": 27,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "positioningPlants": {
        "refName": "positioningPlants",
        "refNumber": 67,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Positioning Plants",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>You've been hired to plant flowers in a garden with n different positions. There are m different flower types. The prices of flowers types vary depending on which position they are planted. Your bosses are picky, they tell you to never plant two of the same flower type right next to each other. What is the minimum cost we need to plant a flower in each position of the garden?</p><p>Write a function, positioningPlants, that takes in a 2D array with dimensions n * m. Each row of the array represents the costs of the flower types at that position. This means that costs[i][j] represents the cost of planting flower type j at position i. For example:</p>",
        "examples": {
            "example1": {
                "input": "costs = [   [4, 3, 7],   [6, 1, 9],   [2, 5, 3] ]",
                "output": "The costs of plants at position 1 are $6, $1, and $9.\nThe cost of planting flower type 0 at position 1 is $6.\nThe cost of planting flower type 2 at position 1 is $9.\n'The function should return the minimum cost of planting flowers without placing the same flower type in adjacent positions.'"
            },
            "example2": {
                "input": "[   [4, 3, 7],   [6, 1, 9],   [2, 5, 3] ]",
                "output": "7, by doing 4 + 1 + 2."
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function positioningPlants(costs) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = # of garden positions (rows)\n// m = # of plant types (columns)\n// Time: O(nm)\n// Space: O(nm)\nfunction positioningPlants(costs, pos = 0, lastPlant = null, memo = {}) {\n   const key = pos + ',' + lastPlant;\n   if (key in memo) return memo[key];\n   if (pos === costs.length) return 0;\n   let min = Infinity;\n   for (let plant = 0; plant < costs[pos].length; plant += 1) {\n      if (plant !== lastPlant) {\n         const candidate = costs[pos][plant] + positioningPlants(costs, pos + 1, plant, memo);\n         min = Math.min(min, candidate);\n      }\n   }\n   memo[key] = min;\n   return min;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        [4, 3, 7],
                        [6, 1, 9],
                        [2, 5, 3]
                    ]
                ],
                "test_expected": 7,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        [12, 14, 5],
                        [6, 3, 2]
                    ]
                ],
                "test_expected": 8,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [
                        [12, 14, 5],
                        [6, 3, 2],
                        [4, 2, 7],
                        [4, 8, 4],
                        [1, 13, 5],
                        [8, 6, 7]
                    ]
                ],
                "test_expected": 23,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        [12, 14, 5, 13],
                        [6, 3, 20, 3],
                        [24, 12, 7, 2],
                        [4, 80, 45, 3],
                        [104, 13, 5, 14],
                        [38, 19, 7, 6],
                        [12, 2, 1, 2]
                    ]
                ],
                "test_expected": 26,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    [
                        [12, 14, 50, 12],
                        [6, 3, 20, 3],
                        [24, 12, 7, 2],
                        [4, 80, 45, 3],
                        [104, 13, 5, 14],
                        [38, 19, 7, 6],
                        [1, 20, 1, 2],
                        [13, 12, 5, 13],
                        [60, 32, 20, 3],
                        [24, 12, 7, 2],
                        [4, 80, 44, 1],
                        [104, 13, 5, 14],
                        [38, 19, 76, 6],
                        [12, 23, 12, 20],
                        [1, 3, 1, 1],
                        [1, 2, 12, 5]
                    ]
                ],
                "test_expected": 74,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    [
                        [12, 14, 50, 12, 13],
                        [6, 3, 20, 3, 16],
                        [24, 12, 7, 2, 74],
                        [4, 80, 45, 3, 100],
                        [104, 13, 5, 14, 3],
                        [38, 19, 7, 6, 24],
                        [1, 20, 1, 2, 31],
                        [13, 12, 5, 13, 9],
                        [60, 32, 20, 3, 2],
                        [24, 12, 7, 2, 42],
                        [4, 80, 44, 1, 23],
                        [104, 13, 5, 14, 28],
                        [38, 19, 76, 6, 12],
                        [12, 23, 12, 20, 13],
                        [1, 3, 1, 1, 50],
                        [1, 2, 12, 5, 36],
                        [6, 2, 3, 12, 20],
                        [4, 6, 4, 11, 15]
                    ]
                ],
                "test_expected": 75,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "breakingBoundaries": {
        "refName": "breakingBoundaries",
        "refNumber": 68,
        "category": "Dynamic Programming",
        "difficulty": "Easy",
        "title": "Breaking Boundaries",
        "tags": ["Easy", "Dynamic Programming"],
        "description": "<p>Write a function, breakingBoundaries, that takes in 5 arguments: a number of rows (m), a number of columns (n), a number of moves (k), a starting row (r), and a starting column (c). Say you were situated in a grid with dimensions m * n. If you had to start at position (r,c), in how many different ways could you move out of bounds if you could take at most k moves. A single move is moving one space up, down, left, or right. During a path you may revisit a position.</p>",
        "examples": {
            "example1": {
                "input": "Given m, n, k, r, c: -> 3, 4, 2, 0, 0\n'This input asks us to count the numbers of ways to move out of bounds in a 3 by 4 grid, starting at position (0, 0) if we could take at most 2 moves.'",
                "output": "'The answer is 4 because of these 4 distinct ways:\n 1. left\n 2. up\n 3. right, up\n 4. down, left'"
            },
            "example2": {
                "input": "breakingBoundaries(3, 4, 2, 0, 0)",
                "output": "4"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function breakingBoundaries(m, n, k, r, c) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// m = # rows\n// n = # columns\n// k = # moves\n// Time: O(mnk)\n// Space: O(mnk)\nfunction breakingBoundaries(m, n, k, r, c, memo = {}) {\n   const key = `${k},${r},${c}`;\n   if (key in memo) return memo[key];\n   const rowInbounds = 0 <= r && r < m;\n   const colInbounds = 0 <= c && c < n;\n   if (!rowInbounds || !colInbounds) return 1;\n   if (k === 0) return 0;\n   let count = 0;\n   const deltas = [\n      [0, 1],\n      [0, -1],\n      [1, 0],\n      [-1, 0]\n   ];\n   for (let delta of deltas) {\n      const [dRow, dCol] = delta;\n      count += breakingBoundaries(m, n, k - 1, r + dRow, c + dCol, memo);\n   }\n   memo[key] = count;\n   return count;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [3, 4, 2, 0, 0],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [2, 2, 2, 1, 1],
                "test_expected": 6,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [3, 4, 3, 0, 0],
                "test_expected": 11,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [4, 4, 5, 2, 1],
                "test_expected": 160,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [5, 6, 9, 2, 5],
                "test_expected": 11635,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [6, 6, 12, 3, 4],
                "test_expected": 871065,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [6, 6, 15, 3, 4],
                "test_expected": 40787896,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [6, 8, 16, 2, 1],
                "test_expected": 137495089,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "mergeSort": {
        "refName": "mergeSort",
        "refNumber": 69,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Merge Sorts",
        "tags": ["Easy", "Array"],
        "description": "<p>Write a function, mergeSort, that takes in an array of numbers as an argument. The function should return a new array containing elements of the original array sorted in ascending order. Your function must implement the merge sort algorithm.</p><img src='https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif' width='500' height='100%'>",
        "examples": {
            "example1": {
                "input": "numbers = [10, 4, 42, 5, 8, 100, 5, 6, 12, 40]",
                "output": "[ 4, 5, 5, 6, 8, 10, 12, 40, 42, 100 ] "
            },
            "example2": {
                "input": "numbers = [7, -30, -4, -1, 12, 0, 20]",
                "output": "[ -30, -4, -1, 0, 7, 12, 20 ]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function mergeSort(nums) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = array size\n// Time: O(nlogn)\n// Space: O(n)\nfunction mergeSort(nums) {\n   if (nums.length <= 1) return nums;\n   const mid = Math.floor(nums.length / 2);\n   const left = nums.slice(0, mid);\n   const right = nums.slice(mid);\n   const sortedLeft = mergeSort(left);\n   const sortedRight = mergeSort(right);\n   return merge(sortedLeft, sortedRight);\n};\nfunction merge(array1, array2) {\n   array1.reverse();\n   array2.reverse();\n   const merged = [];\n   while (array1.length > 0 && array2.length > 0) {\n      if (array1[array1.length - 1] < array2[array2.length - 1]) {\n         merged.push(array1.pop());\n      } else {\n         merged.push(array2.pop());\n      }\n   }\n   merged.push(...array1.reverse());\n   merged.push(...array2.reverse());\n   return merged;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[10, 4, 42, 5, 8, 100, 5, 6, 12, 40]],
                "test_expected": [4, 5, 5, 6, 8, 10, 12, 40, 42, 100],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[7, -30, -4, -1, 12, 0, 20]],
                "test_expected": [-30, -4, -1, 0, 7, 12, 20],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[8, 7, 6, 5, 4, 3, 2, 1, 0]],
                "test_expected": [0, 1, 2, 3, 4, 5, 6, 7, 8],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        72, 42, 16, 81, 84, 17, 2, 81, 22, 79, 86, 38, 77, 80, 81, 70, 81, 80, 35, 21, 89, 38, 57, 28,
                        4, 17, 50, 38, 68, 82, 22, 76, 45, 40, 67, 94, 37, 27, 81, 53, 36, 18, 28, 60, 45, 74, 40, 29,
                        18, 6, 28, 57, 42, 60, 64, 12, 78, 97, 96, 1, 20, 20, 61, 67, 82, 10, 63, 71, 39, 52, 37, 69,
                        37, 24, 66, 74, 15, 92, 49, 31, 56, 67, 50, 57, 79, 0, 21, 56, 82, 22, 4, 20, 91, 72, 58, 93,
                        99, 14, 42, 91
                    ]
                ],
                "test_expected": [
                    0, 1, 2, 4, 4, 6, 10, 12, 14, 15, 16, 17, 17, 18, 18, 20, 20, 20, 21, 21, 22, 22, 22, 24, 27, 28,
                    28, 28, 29, 31, 35, 36, 37, 37, 37, 38, 38, 38, 39, 40, 40, 42, 42, 42, 45, 45, 49, 50, 50, 52, 53,
                    56, 56, 57, 57, 57, 58, 60, 60, 61, 63, 64, 66, 67, 67, 67, 68, 69, 70, 71, 72, 72, 74, 74, 76, 77,
                    78, 79, 79, 80, 80, 81, 81, 81, 81, 81, 82, 82, 82, 84, 86, 89, 91, 91, 92, 93, 94, 96, 97, 99
                ],
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "combineIntervals": {
        "refName": "combineIntervals",
        "refNumber": 70,
        "category": "Array",
        "difficulty": "Easy",
        "title": "Combine Intervals",
        "tags": ["Easy", "Array"],
        "description": "<p>Write a function, combineIntervals, that takes in an array of intervals as an argument. Each interval is an array containing a pair of numbers representing a start and end time. Your function should combine overlapping intervals and return an array containing the combined intervals.</p><p>You may return the combined intervals in any order.</p><p>You can assume that the input array contains at least one interval and all intervals are valid with start < end.</p>",
        "examples": {
            "example1": {
                "input": "const intervals = [   [1, 4],   [12, 15],   [3, 7],   [8, 13], ];",
                "output": "[ [1, 7], [8, 15] ]"
            },
            "example2": {
                "input": "[   [6, 8],   [2, 9],   [10, 12],   [20, 24], ]",
                "output": "[ [2, 9], [10, 12], [20, 24] ]"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function combineIntervals(intervals) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of intervals\n// Time: O(nlogn)\n// Space: O(n)\nfunction combineIntervals(intervals) {\n   const sortedIntervals = intervals.sort((intervalA, intervalB) => intervalA[0] - intervalB[0]);\n   const combined = [intervals[0]];\n   for (let currentInterval of sortedIntervals.slice(1)) {\n      const lastInterval = combined[combined.length - 1];\n      const [lastStart, lastEnd] = lastInterval;\n      const [currentStart, currentEnd] = currentInterval;\n      if (currentStart <= lastEnd) {\n         if (currentEnd > lastEnd) {\n            lastInterval[1] = currentEnd;\n         }\n      } else {\n         combined.push(currentInterval);\n      }\n   }\n   return combined;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        [1, 4],
                        [12, 15],
                        [3, 7],
                        [8, 13]
                    ]
                ],
                "test_expected": [
                    [1, 7],
                    [8, 15]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        [6, 8],
                        [2, 9],
                        [10, 12],
                        [20, 24]
                    ]
                ],
                "test_expected": [
                    [2, 9],
                    [10, 12],
                    [20, 24]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [
                        [3, 7],
                        [5, 8],
                        [1, 5]
                    ]
                ],
                "test_expected": [[1, 8]],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        [3, 7],
                        [10, 13],
                        [5, 8],
                        [27, 31],
                        [1, 5],
                        [12, 16],
                        [20, 22]
                    ]
                ],
                "test_expected": [
                    [1, 8],
                    [10, 16],
                    [20, 22],
                    [27, 31]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    [
                        [3, 7],
                        [10, 13],
                        [5, 8],
                        [27, 31],
                        [1, 5],
                        [12, 16],
                        [20, 32]
                    ]
                ],
                "test_expected": [
                    [1, 8],
                    [10, 16],
                    [20, 32]
                ],
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    [
                        [64, 70],
                        [50, 55],
                        [62, 65],
                        [12, 50],
                        [72, 300000]
                    ]
                ],
                "test_expected": [
                    [12, 55],
                    [62, 70],
                    [72, 300000]
                ],
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "binarySearch": {
        "refName": "binarySearch",
        "refNumber": 71,
        "category": "Array",
        "difficulty": "Medium",
        "title": "Binary Search",
        "tags": ["Medium", "Array"],
        "description": "<p>Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.</p><p>You must write an algorithm with O(log n) runtime complexity.</p>",
        "examples": {
            "example1": {
                "input": "nums = [-1,0,3,5,9,12];\ntarget = 9;",
                "output": "4\n// Explanation: 9 exists in nums and its index is 4"
            },
            "example2": {
                "input": "nums = [-1,0,3,5,9,12];\ntarget = 2;",
                "output": "-1\n// Explanation: 2 does not exist in nums so return -1"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function binarySearch(arr, target, s, e)  {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// Recursive\nfunction binarySearch(arr, target, s, e) {\n    const start = s || 0;\n    const end = e || arr.length - 1;\n    if (start > end) return -1;\n    let mid = Math.floor((start + end) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] > target)\n        return binarySearch(arr, target, start, mid - 1);\n    else return binarySearch(arr, target, mid + 1, end);\n}\n// Iterative\nfunction binarySearch(arr, target) {\n    let start = 0, end = arr.length - 1;\n    while (start <= end) {\n        let mid = Math.floor((start + end) / 2);\n        if (arr[mid] === target) return mid;\n        else if (arr[mid] < target)\n            start = mid + 1;\n        else\n            end = mid - 1;\n    }\n    return -1;\n}"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [[-1, 0, 3, 5, 9, 12], 9],
                "test_expected": 4,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [[-1, 0, 3, 5, 9, 12], 2],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [[1, 3, 5, 7, 8, 9], 5],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [[0, 1, 2, 3, 4, 5, 6, 7, 8], 6],
                "test_expected": 6,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [[0, 6, 8, 12, 16, 19, 20, 24, 28], 27],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [[0, 6, 8, 12, 16, 19, 20, 28], 8],
                "test_expected": 2,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [[], 7],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": [[7], 7],
                "test_expected": 0,
                "code_output": null,
                "passed_test": false
            },
            "Test_9": {
                "test_input": [[7, 9], 12],
                "test_expected": -1,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "binarySearchTreeIncludes": {
        "refName": "binarySearchTreeIncludes",
        "refNumber": 72,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Binary Search Tree Includes",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, binarySearchTreeIncludes, that takes in the root of a binary search tree containing numbers and a target value. The function should return a boolean indicating whether or not the target is found within the tree.</p><p>A Binary Search Tree is a binary tree where all values within a node's left subtree are smaller than the node's value and all values in a node's right subtree are greater than or equal to the node's value.</p><p>Your solution should have a best case runtime of O(log(n)).</p>",
        "examples": {
            "example1": {
                "input": "",
                "output": ""
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function binarySearchTreeIncludes(root, target) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes\n// Worst Case\n// Time: O(n)\n// Space: O(n)\n// Best Case (balanced-tree)\n// Time: O(log(n))\n// Space: O(log(n))\nfunction binarySearchTreeIncludes(root, target) {\n   if (root === null) return false;\n   if (root.val === target) return true;\n   if (target < root.val) {\n      return binarySearchTreeIncludes(root.left, target);\n   } else {\n      return binarySearchTreeIncludes(root.right, target);\n   }\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() {\n   function Node(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n   }\n   const a = new Node(12);\n   const b = new Node(5);\n   const c = new Node(18);\n   const d = new Node(3);\n   const e = new Node(9);\n   const f = new Node(19);\n   a.left = b;\n   a.right = c;\n   b.left = d;\n   b.right = e;\n   c.right = f;\n   return window.binarySearchTreeIncludes(a, 9);\n}",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() {\n   function Node(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n   }\n   const a = new Node(12);\n   const b = new Node(5);\n   const c = new Node(18);\n   const d = new Node(3);\n   const e = new Node(9);\n   const f = new Node(19);\n   a.left = b;\n   a.right = c;\n   b.left = d;\n   b.right = e;\n   c.right = f;\n   return window.binarySearchTreeIncludes(a, 15);\n}",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() {\n   function Node(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n   }\n   const a = new Node(12);\n   const b = new Node(5);\n   const c = new Node(18);\n   const d = new Node(3);\n   const e = new Node(9);\n   const f = new Node(19);\n   a.left = b;\n   a.right = c;\n   b.left = d;\n   b.right = e;\n   c.right = f;\n   return window.binarySearchTreeIncludes(a, 1);\n}",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() {   function Node(val) {      this.val = val;      this.left = null;      this.right = null;   }   const a = new Node(12);   const b = new Node(5);   const c = new Node(18);   const d = new Node(3);   const e = new Node(9);   const f = new Node(19);   a.left = b;   a.right = c;   b.left = d;   b.right = e;   c.right = f;   return window.binarySearchTreeIncludes(a, 12);}",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const q = new Node(54);    const r = new Node(42);    const s = new Node(70);    const t = new Node(31);    const u = new Node(50);    const v = new Node(72);    const w = new Node(47);    const x = new Node(90);    q.left = r;    q.right = s;    r.left = t;    r.right = u;    s.right = v;    u.left = w;    v.right = x;    return binarySearchTreeIncludes(q, 55); }",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_6": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const q = new Node(54);    const r = new Node(42);    const s = new Node(70);    const t = new Node(31);    const u = new Node(50);    const v = new Node(72);    const w = new Node(47);    const x = new Node(90);    q.left = r;    q.right = s;    r.left = t;    r.right = u;    s.right = v;    u.left = w;    v.right = x;    return binarySearchTreeIncludes(q, 47); }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_7": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const q = new Node(54);    const r = new Node(42);    const s = new Node(70);    const t = new Node(31);    const u = new Node(50);    const v = new Node(72);    const w = new Node(47);    const x = new Node(90);    q.left = r;    q.right = s;    r.left = t;    r.right = u;    s.right = v;    u.left = w;    v.right = x;    return binarySearchTreeIncludes(q, 49); }",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_8": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const q = new Node(54);    const r = new Node(42);    const s = new Node(70);    const t = new Node(31);    const u = new Node(50);    const v = new Node(72);    const w = new Node(47);    const x = new Node(90);    q.left = r;    q.right = s;    r.left = t;    r.right = u;    s.right = v;    u.left = w;    v.right = x;    return binarySearchTreeIncludes(q, 70); }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_9": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const q = new Node(54);    const r = new Node(42);    const s = new Node(70);    const t = new Node(31);    const u = new Node(50);    const v = new Node(72);    const w = new Node(47);    const x = new Node(90);    q.left = r;    q.right = s;    r.left = t;    r.right = u;    s.right = v;    u.left = w;    v.right = x;    return binarySearchTreeIncludes(q, 100); }",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "isBinarySearchTree": {
        "refName": "isBinarySearchTree",
        "refNumber": 73,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Is Binary Search Tree",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, isBinarySearchTree, that takes in the root of a binary tree. The function should return a boolean indicating whether or not the tree satisfies the binary search tree property.</p><p>A Binary Search Tree is a binary tree where all values within a node's left subtree are smaller than the node's value and all values in a node's right subtree are greater than or equal to the node's value.</p>",
        "examples": {
            "example1": {
                "input": "",
                "output": ""
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function isBinarySearchTree(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes\n// Time: O(n)\n// Space: O(n)\nfunction isBinarySearchTree(root, target) {\n   const values = [];\n   inOrderTraversal(root, values);\n   return isSorted(values);\n};\nfunction inOrderTraversal(root, values) {\n   if (root === null) return;\n   inOrderTraversal(root.left, values);\n   values.push(root.val);\n   inOrderTraversal(root.right, values);\n};\nfunction isSorted(numbers) {\n   for (let i = 0; i < numbers.length - 1; i += 1) {\n      const current = numbers[i];\n      const next = numbers[i + 1];\n      if (next < current) return false;\n   }\n   return true;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const a = new Node(12);    const b = new Node(5);    const c = new Node(18);    const d = new Node(3);    const e = new Node(9);    const f = new Node(19);    a.left = b;    a.right = c;    b.left = d;    b.right = e;    c.right = f;    return window.isBinarySearchTree(a); }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const a = new Node(12);    const b = new Node(5);    const c = new Node(18);    const d = new Node(3);    const e = new Node(15);    const f = new Node(19);    a.left = b;    a.right = c;    b.left = d;    b.right = e;    c.right = f;    return window.isBinarySearchTree(a); }",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const a = new Node(12);    const b = new Node(5);    const c = new Node(19);    const d = new Node(3);    const e = new Node(9);    const f = new Node(19);    a.left = b;    a.right = c;    b.left = d;    b.right = e;    c.right = f;    return window.isBinarySearchTree(a); }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const a = new Node(12);    const b = new Node(5);    const c = new Node(10);    const d = new Node(3);    const e = new Node(9);    const f = new Node(19);    a.left = b;    a.right = c;    b.left = d;    b.right = e;    c.right = f;    return window.isBinarySearchTree(a); }",
                "test_expected": false,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_5": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const q = new Node(54);    const r = new Node(42);    const s = new Node(70);    const t = new Node(31);    const u = new Node(50);    const v = new Node(72);    const w = new Node(47);    const x = new Node(90);    q.left = r;    q.right = s;    r.left = t;    r.right = u;    s.right = v;    u.left = w;    v.right = x;    return window.isBinarySearchTree(q); }",
                "test_expected": true,
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "postOrder": {
        "refName": "postOrder",
        "refNumber": 74,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Post Order",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, postOrder, that takes in the root of a binary tree. The function should return an array containing the post-ordered values of the tree.</p><p>Post-order traversal is when nodes are recursively visited in the order: left child, right child, self.</p>",
        "examples": {
            "example1": {
                "input": "",
                "output": ""
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function postOrder(root) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = number of nodes \n// Time: O(n) \n// Space: O(n) \nfunction postOrder(root) {\n   const values = [];\n   postOrderTraversal(root, values);\n   return values;\n};\nfunction postOrderTraversal(root, values) {\n   if (root === null) return;\n   postOrderTraversal(root.left, values);\n   postOrderTraversal(root.right, values);\n   values.push(root.val);\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const x = new Node('x');    const y = new Node('y');    const z = new Node('z');    x.left = y;    x.right = z;    return window.postOrder(x); }",
                "test_expected": ["y", "z", "x"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_2": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const a = new Node('a');    const b = new Node('b');    const c = new Node('c');    const d = new Node('d');    const e = new Node('e');    const f = new Node('f');    const g = new Node('g');    a.left = b;    a.right = c;    b.left = d;    b.right = e;    c.left = f;    c.right = g;    return window.postOrder(a); }",
                "test_expected": ["d", "e", "b", "f", "g", "c", "a"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_3": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const a = new Node('a');    const b = new Node('b');    const c = new Node('c');    const d = new Node('d');    const e = new Node('e');    const f = new Node('f');    const g = new Node('g');    const h = new Node('h');    a.left = b;    a.right = c;    b.left = d;    b.right = e;    c.right = f;    e.left = g;    e.right = h;    return window.postOrder(a); }",
                "test_expected": ["d", "g", "h", "e", "b", "f", "c", "a"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            },
            "Test_4": {
                "test_input": "function test_input() {    function Node(val) {       this.val = val;       this.left = null;       this.right = null;    }    const l = new Node('l');    const m = new Node('m');    const n = new Node('n');    const o = new Node('o');    const p = new Node('p');    const q = new Node('q');    const r = new Node('r');    const s = new Node('s');    const t = new Node('t');    l.left = m;    l.right = n;    n.left = o;    n.right = p;    o.left = q;    o.right = r;    p.left = s;    p.right = t;    return window.postOrder(l); }",
                "test_expected": ["m", "q", "r", "o", "s", "t", "p", "n", "l"],
                "code_output": null,
                "passed_test": false,
                "functionTest": true
            }
        },
        "platform": "structy"
    },
    "buildTreeInPost": {
        "refName": "buildTreeInPost",
        "refNumber": 75,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Build Tree In Post",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, buildTreeInPost, that takes in an array of in-ordered values and an array of post-ordered values for a binary tree. The function should build a binary tree that has the given in-order and post-order traversal structure. The function should return the root of this tree.</p><p>You can assume that the values of inorder and postorder are unique.</p>",
        "examples": {
            "example1": {
                "input": "",
                "output": ""
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "class Node {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\nfunction buildTreeInPost(inOrder, postOrder) {\n  // Write your solution...\n  return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of array\n// Time: O(n^2)\n// Space: O(n^2)\nfunction buildTreeInPost(inOrder, postOrder) {\n   if (inOrder.length === 0) return null;\n   const value = postOrder[postOrder.length - 1];\n   const root = new Node(value);\n   const mid = inOrder.indexOf(value);\n   const leftIn = inOrder.slice(0, mid);\n   const rightIn = inOrder.slice(mid + 1);\n   const leftPost = postOrder.slice(0, leftIn.length);\n   const rightPost = postOrder.slice(leftIn.length, -1);\n   root.left = buildTreeInPost(leftIn, leftPost);\n   root.right = buildTreeInPost(rightIn, rightPost);\n   return root;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    ["y", "x", "z"],
                    ["y", "z", "x"]
                ],
                "test_expected": {
                    "val": "x",
                    "left": {
                        "val": "y",
                        "left": null,
                        "right": null
                    },
                    "right": {
                        "val": "z",
                        "left": null,
                        "right": null
                    }
                },
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    ["d", "b", "e", "a", "f", "c", "g"],
                    ["d", "e", "b", "f", "g", "c", "a"]
                ],
                "test_expected": {
                    "val": "a",
                    "left": {
                        "val": "b",
                        "left": {
                            "val": "d",
                            "left": null,
                            "right": null
                        },
                        "right": {
                            "val": "e",
                            "left": null,
                            "right": null
                        }
                    },
                    "right": {
                        "val": "c",
                        "left": {
                            "val": "f",
                            "left": null,
                            "right": null
                        },
                        "right": {
                            "val": "g",
                            "left": null,
                            "right": null
                        }
                    }
                },
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    ["d", "b", "g", "e", "h", "a", "c", "f"],
                    ["d", "g", "h", "e", "b", "f", "c", "a"]
                ],
                "test_expected": {
                    "val": "a",
                    "left": {
                        "val": "b",
                        "left": {
                            "val": "d",
                            "left": null,
                            "right": null
                        },
                        "right": {
                            "val": "e",
                            "left": {
                                "val": "g",
                                "left": null,
                                "right": null
                            },
                            "right": {
                                "val": "h",
                                "left": null,
                                "right": null
                            }
                        }
                    },
                    "right": {
                        "val": "c",
                        "left": null,
                        "right": {
                            "val": "f",
                            "left": null,
                            "right": null
                        }
                    }
                },
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    ["m", "n"],
                    ["m", "n"]
                ],
                "test_expected": {
                    "val": "n",
                    "left": {
                        "val": "m",
                        "left": null,
                        "right": null
                    },
                    "right": null
                },
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    ["n", "m"],
                    ["m", "n"]
                ],
                "test_expected": {
                    "val": "n",
                    "left": null,
                    "right": {
                        "val": "m",
                        "left": null,
                        "right": null
                    }
                },
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "buildTreeInPre": {
        "refName": "buildTreeInPre",
        "refNumber": 76,
        "category": "Binary Tree",
        "difficulty": "Easy",
        "title": "Build Tree In Pre",
        "tags": ["Easy", "Binary Tree"],
        "description": "<p>Write a function, buildTreeInPre, that takes in an array of in-ordered values and an array of pre-ordered values for a binary tree. The function should build a binary tree that has the given in-order and pre-order traversal structure. The function should return the root of this tree.</p><p>You can assume that the values of inorder and preorder are unique.</p>",
        "examples": {
            "example1": {
                "input": "",
                "output": ""
            },
            "example2": {
                "input": "",
                "output": ""
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "class Node {\n   constructor(val) {\n      this.val = val;\n      this.left = null;\n      this.right = null;\n   }\n}\nfunction buildTreeInPre(inOrder, preOrder) {\n   // Write your solution...\n   return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of array\n// Time: O(n^2)\n// Space: O(n^2)\n// recursive with array copies\nfunction buildTreeInPre(inOrder, preOrder) {\n   if (inOrder.length === 0) return null;\n   const value = preOrder[0];\n   const root = new Node(value);\n   const mid = inOrder.indexOf(value);\n   const leftInOrder = inOrder.slice(0, mid);\n   const rightInOrder = inOrder.slice(mid + 1);\n   const leftPreOrder = preOrder.slice(1, leftInOrder.length + 1);\n   const rightPreOrder = preOrder.slice(leftInOrder.length + 1);\n   root.left = buildTreeInPre(leftInOrder, leftPreOrder);\n   root.right = buildTreeInPre(rightInOrder, rightPreOrder);\n   return root;\n};\n// n = length of array\n// Time: O(n)\n// Space: O(n)\n// recursive in-place\nfunction buildTreeInPre (\n   inOrder,\n   preOrder,\n   inOrderStart = 0,\n   inOrderEnd = inOrder.length - 1,\n   preOrderStart = 0,\n   preOrderEnd = preOrder.length - 1) {\n   if (inOrderEnd < inOrderStart) return null;\n   const value = preOrder[preOrderStart];\n   const root = new Node(value);\n   const mid = inOrder.indexOf(value);\n   const leftSize = mid - inOrderStart;\n   root.left = buildTreeInPre(\n      inOrder,\n      preOrder,\n      inOrderStart,\n      mid - 1,\n      preOrderStart + 1,\n      preOrderStart + leftSize\n   );\n   root.right = buildTreeInPre(\n      inOrder,\n      preOrder,\n      mid + 1,\n      inOrderEnd,\n      preOrderStart + leftSize + 1,\n      preOrderEnd\n   );\n   return root;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    ["z", "y", "x"],
                    ["y", "z", "x"]
                ],
                "test_expected": {
                    "val": "y",
                    "left": {
                        "val": "z",
                        "left": null,
                        "right": null
                    },
                    "right": {
                        "val": "x",
                        "left": null,
                        "right": null
                    }
                },
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    ["y", "z", "x"],
                    ["y", "x", "z"]
                ],
                "test_expected": {
                    "val": "y",
                    "left": null,
                    "right": {
                        "val": "x",
                        "left": {
                            "val": "z",
                            "left": null,
                            "right": null
                        },
                        "right": null
                    }
                },
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    ["d", "b", "g", "e", "h", "a", "c", "f"],
                    ["a", "b", "d", "e", "g", "h", "c", "f"]
                ],
                "test_expected": {
                    "val": "a",
                    "left": {
                        "val": "b",
                        "left": {
                            "val": "d",
                            "left": null,
                            "right": null
                        },
                        "right": {
                            "val": "e",
                            "left": {
                                "val": "g",
                                "left": null,
                                "right": null
                            },
                            "right": {
                                "val": "h",
                                "left": null,
                                "right": null
                            }
                        }
                    },
                    "right": {
                        "val": "c",
                        "left": null,
                        "right": {
                            "val": "f",
                            "left": null,
                            "right": null
                        }
                    }
                },
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    ["t", "u", "s", "q", "r", "p"],
                    ["u", "t", "s", "r", "q", "p"]
                ],
                "test_expected": {
                    "val": "u",
                    "left": {
                        "val": "t",
                        "left": null,
                        "right": null
                    },
                    "right": {
                        "val": "s",
                        "left": null,
                        "right": {
                            "val": "r",
                            "left": {
                                "val": "q",
                                "left": null,
                                "right": null
                            },
                            "right": {
                                "val": "p",
                                "left": null,
                                "right": null
                            }
                        }
                    }
                },
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    ["m", "l", "q", "o", "r", "n", "s", "p", "t"],
                    ["l", "m", "n", "o", "q", "r", "p", "s", "t"]
                ],
                "test_expected": {
                    "val": "l",
                    "left": {
                        "val": "m",
                        "left": null,
                        "right": null
                    },
                    "right": {
                        "val": "n",
                        "left": {
                            "val": "o",
                            "left": {
                                "val": "q",
                                "left": null,
                                "right": null
                            },
                            "right": {
                                "val": "r",
                                "left": null,
                                "right": null
                            }
                        },
                        "right": {
                            "val": "p",
                            "left": {
                                "val": "s",
                                "left": null,
                                "right": null
                            },
                            "right": {
                                "val": "t",
                                "left": null,
                                "right": null
                            }
                        }
                    }
                },
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "lexicalOrder": {
        "refName": "lexicalOrder",
        "refNumber": 77,
        "category": "String",
        "difficulty": "Easy",
        "title": "Lexical Order",
        "tags": ["Easy", "String"],
        "description": "<p>Write a function, lexicalOrder, that takes in 2 words and an alphabet string as an argument. The function should return true if the first word should appear before the second word if lexically-ordered according to the given alphabet order. If the second word should appear first, then return false.</p><p>Note that the alphabet string may be any arbitrary string.</p><p>Intuitively, Lexical Order is like 'dictionary' order:</p><p>You can assume that all characters are lowercase a-z.</p><p>You can assume that the alphabet contains all 26 letters.</p>",
        "examples": {
            "example1": {
                "input": "alphabet = 'abcdefghijklmnopqrstuvwxyz'\nword1='apple'\nword2='dock'",
                "output": "true"
            },
            "example2": {
                "input": "alphabet = 'abcdefghijklmnopqrstuvwxyz'\nword1='apple'\nword2='ample'",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function lexicalOrder(word1, word2, alphabet) {\n   // Write your solution...\n   return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of shorter string\n// Time: O(n)\n// Space: O(1)\nfunction lexicalOrder(word1, word2, alphabet) {\n   const length = Math.max(word1.length, word2.length);\n   for (let i = 0; i < length; i += 1) {\n      const char1 = word1[i];\n      const char2 = word2[i];\n      const value1 = alphabet.indexOf(char1);\n      const value2 = alphabet.indexOf(char2);\n      if (value1 < value2) {\n         return true;\n      } else if (value1 > value2) {\n         return false;\n      }\n   }\n   return true;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": ["apple", "dock", "abcdefghijklmnopqrstuvwxyz"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": ["apple", "ample", "abcdefghijklmnopqrstuvwxyz"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": ["app", "application", "abcdefghijklmnopqrstuvwxyz"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": ["backs", "backdoor", "abcdefghijklmnopqrstuvwxyz"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": ["zoo", "dinner", "abcdefghijklmnopqrstuvwxyz"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": ["leaper", "leap", "abcdefghijklmnopqrstuvwxyz"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": ["backs", "backdoor", "abcdefghijklmnopqrstuvwxyz"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_8": {
                "test_input": ["semper", "semper", "abcdefghijklmnopqrstuvwxyz"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "detectDictionary": {
        "refName": "detectDictionary",
        "refNumber": 78,
        "category": "String",
        "difficulty": "Easy",
        "title": "Detect Dictionary",
        "tags": ["Easy", "String"],
        "description": "<p>Write a function, detectDictionary, that takes in a dictionary of words and an alphabet string. The function should return a boolean indicating whether or not all words of the dictionary are lexically-ordered according to the alphabet.</p><p>You can assume that all characters are lowercase a-z.</p><p>You can assume that the alphabet contains all 26 letters.</p>",
        "examples": {
            "example1": {
                "input": "dictionary = ['zoo', 'tick', 'tack', 'door']\nalphabet = 'ghzstijbacdopnfklmeqrxyuvw'",
                "output": "true"
            },
            "example2": {
                "input": "dictionary = ['zoo', 'tack', 'tick', 'door']\nalphabet = 'ghzstijbacdopnfklmeqrxyuvw'",
                "output": "false"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function detectDictionary(dictionary, alphabet) {\n   // Write your solution...\n   return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = # of words in dictionary\n// k = # length of longest word\n// Time: O(nk)\n// Space: O(1)\nfunction detectDictionary(dictionary, alphabet) {\n   for (let i = 0; i < dictionary.length - 1; i += 1) {\n      const current = dictionary[i];\n      const next = dictionary[i + 1];\n      if (!lexicalOrder(current, next, alphabet)) return false;\n   }\n   return true;\n};\nfunction lexicalOrder(word1, word2, alphabet) {\n   const length = Math.max(word1.length, word2.length);\n   for (let i = 0; i < length; i += 1) {\n      const char1 = word1[i];\n      const char2 = word2[i];\n      const value1 = char1 === undefined ? -Infinity : alphabet.indexOf(char1);\n      const value2 = char2 === undefined ? -Infinity : alphabet.indexOf(char2);\n      if (value1 < value2) {\n         return true;\n      } else if (value1 > value2) {\n         return false;\n      }\n   }\n   return true;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [["zoo", "tick", "tack", "door"], "ghzstijbacdopnfklmeqrxyuvw"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [["zoo", "tack", "tick", "door"], "ghzstijbacdopnfklmeqrxyuvw"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [["zoos", "zoo", "tick", "tack", "door"], "ghzstijbacdopnfklmeqrxyuvw"],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [["miles", "milestone", "proper", "process", "goal"], "mnoijpqrshkltabcdefguvwzxy"],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    ["miles", "milestone", "pint", "proper", "process", "goal"],
                    "mnoijpqrshkltabcdefguvwzxy"
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    ["miles", "milestone", "pint", "proper", "process", "goal", "apple"],
                    "mnoijpqrshkltabcdefguvwzxy"
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "topologicalOrder": {
        "refName": "topologicalOrder",
        "refNumber": 79,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Topological Order",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, topologicalOrder, that takes in an object representing the adjacency list for a directed-acyclic graph. The function should return an array containing the topological-order of the graph.</p><p>The topological ordering of a graph is a sequence where 'parent nodes' appear before their 'children' within the sequence.</p>",
        "examples": {
            "example1": {
                "input": "{   a: ['f'],   b: ['d'],   c: ['a', 'f'],   d: ['e'],   e: [],   f: ['b', 'e'], }",
                "output": "['c', 'a', 'f', 'b', 'd', 'e']"
            },
            "example2": {
                "input": "{   h: ['l', 'm'],   i: ['k'],   j: ['k', 'i'],   k: ['h', 'm'],   l: ['m'],   m: [], }",
                "output": "['j', 'i', 'k', 'h', 'l', 'm']"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function topologicalOrder(graph) {\n   // Write your solution...\n   return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// e = number of edges\n// n = number of nodes\n// Time: O(e + n)\n// Space: O(n)\nfunction topologicalOrder(graph) {\n   const numParents = {};\n   for (let node in graph) {\n      numParents[node] = 0;\n   }\n   for (let node in graph) {\n      for (let child of graph[node]) {\n         numParents[child] += 1;\n      }\n   }\n   const ready = [];\n   for (let node in numParents) {\n      if (numParents[node] === 0) {\n         ready.push(node);\n      }\n   }\n   const order = [];\n   while (ready.length > 0) {\n      const node = ready.pop();\n      order.push(node);\n      for (let child of graph[node]) {\n         numParents[child] -= 1;\n         if (numParents[child] === 0) {\n            ready.push(child);\n         }\n      }\n   }\n   return order;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    {
                        "a": ["f"],
                        "b": ["d"],
                        "c": ["a", "f"],
                        "d": ["e"],
                        "e": [],
                        "f": ["b", "e"]
                    }
                ],
                "test_expected": ["c", "a", "f", "b", "d", "e"],
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    {
                        "h": ["l", "m"],
                        "i": ["k"],
                        "j": ["k", "i"],
                        "k": ["h", "m"],
                        "l": ["m"],
                        "m": []
                    }
                ],
                "test_expected": ["j", "i", "k", "h", "l", "m"],
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    {
                        "q": [],
                        "r": ["q"],
                        "s": ["r"],
                        "t": ["s"]
                    }
                ],
                "test_expected": ["t", "s", "r", "q"],
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    {
                        "v": ["z", "w"],
                        "w": [],
                        "x": ["w", "v", "z"],
                        "y": ["x"],
                        "z": ["w"]
                    }
                ],
                "test_expected": ["y", "x", "v", "z", "w"],
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "safeCracking": {
        "refName": "safeCracking",
        "refNumber": 80,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "Safe Cracking",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Oh-no! You forgot the number combination that unlocks your safe. Luckily, you knew that you'd be forgetful so you previously wrote down a bunch of hints that can be used to determine the correct combination. Each hint is a pair of numbers 'x, y' that indicates you must enter digit 'x' before 'y' (but not necessarily immediately before y).</p><p>The keypad on the safe has digits 0-9. You can assume that the hints will generate exactly one working combination and that a digit can occur zero or one time in the answer.</p><p>Write a function, safeCracking, that takes in an array of hints as an argument and determines the combination that will unlock the safe. The function should return a string representing the combination.</p>",
        "examples": {
            "example1": {
                "input": "hints = [[7, 1], [1, 8], [7, 8]]",
                "output": "'718'"
            },
            "example2": {
                "input": "hints = [   [3, 1],   [4, 7],   [5, 9],   [4, 3],   [7, 3],   [3, 5],   [9, 1], ]",
                "output": "'473591'"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function safeCracking(hints) {\n   // Write your solution...\n   return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// e = number of hints\n// Time: O(e)\n// Space: O(e)\nfunction safeCracking(hints) {\n   const graph = buildGraph(hints);\n   return topologicalOrder(graph);\n};\nfunction buildGraph(edges) {\n   const graph = {};\n   for (let edge of edges) {\n      const [a, b] = edge;\n      if (!(a in graph)) graph[a] = [];\n      if (!(b in graph)) graph[b] = [];\n      graph[a].push(b);\n   }\n   return graph;\n};\nfunction topologicalOrder(graph) {\n   const numParents = {};\n   for (let node in graph) {\n      numParents[node] = 0;\n   }\n   for (let node in graph) {\n      for (let child of graph[node]) {\n         numParents[child] += 1;\n      }\n   }\n   const ready = [];\n   for (let node in numParents) {\n      if (numParents[node] === 0) ready.push(node);\n   }\n   let order = '';\n   while (ready.length > 0) {\n      const node = ready.pop();\n      order += node;\n      for (let child of graph[node]) {\n         numParents[child] -= 1;\n         if (numParents[child] === 0) ready.push(child)\n      }\n   }\n   return order;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        [7, 1],
                        [1, 8],
                        [7, 8]
                    ]
                ],
                "test_expected": "718",
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        [3, 1],
                        [4, 7],
                        [5, 9],
                        [4, 3],
                        [7, 3],
                        [3, 5],
                        [9, 1]
                    ]
                ],
                "test_expected": "473591",
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [
                        [2, 5],
                        [8, 6],
                        [0, 6],
                        [6, 2],
                        [0, 8],
                        [2, 3],
                        [3, 5],
                        [6, 5]
                    ]
                ],
                "test_expected": "086235",
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        [0, 1],
                        [6, 0],
                        [1, 8]
                    ]
                ],
                "test_expected": "6018",
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    [
                        [8, 9],
                        [4, 2],
                        [8, 2],
                        [3, 8],
                        [2, 9],
                        [4, 9],
                        [8, 4]
                    ]
                ],
                "test_expected": "38429",
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "stringSearch": {
        "refName": "stringSearch",
        "refNumber": 81,
        "category": "Graphs",
        "difficulty": "Easy",
        "title": "String Search",
        "tags": ["Easy", "Graphs"],
        "description": "<p>Write a function, stringSearch, that takes in a grid of letters and a string as arguments. The function should return a boolean indicating whether or not the string can be found in the grid as a path by connecting horizontal or vertical positions. The path can begin at any position, but you cannot reuse a position more than once in the path.</p><p>You can assume that all letters are lowercase and alphabetic.</p>",
        "examples": {
            "example1": {
                "input": "grid = [   ['e', 'y', 'h', 'i', 'j'],   ['q', 'x', 'e', 'r', 'p'],   ['r', 'o', 'l', 'l', 'n'],   ['p', 'r', 'x', 'o', 'h'],   ['a', 'a', 'm', 'c', 'm'] ]\nstring1 = 'hello'",
                "output": "true"
            },
            "example2": {
                "input": "grid = [   [   ['e', 'y', 'h', 'i', 'j'],   ['q', 'x', 'e', 'r', 'p'],   ['r', 'o', 'l', 'l', 'n'],   ['p', 'r', 'x', 'o', 'h'],   ['a', 'a', 'm', 'c', 'm'] ]\nstring1 = 'proxy'",
                "output": "true"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function stringSearch(grid, s) {\n   // Write your solution...\n   return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// r = # grid rows\n// c = # grid columns\n// Time: O(3^(r*c))\n// Space: O(r*c)\nfunction stringSearch(grid, s) {\n   for (let r = 0; r < grid.length; r += 1) {\n      for (let c = 0; c < grid[0].length; c += 1) {\n         if (dfs(grid, s, r, c)) return true;\n      }\n   }\n   return false;\n};\nfunction dfs(grid, s, row, col) {\n   const rowInbounds = 0 <= row && row < grid.length;\n   const colInbounds = 0 <= col && col < grid[0].length;\n   if (s === '') return true;\n   if (!rowInbounds || !colInbounds) return false;\n   const char = grid[row][col];\n   if (char !== s[0]) return false;\n   const suffix = s.slice(1);\n   grid[row][col] = '*';\n   const result = dfs(grid, suffix, row + 1, col) ||\n      dfs(grid, suffix, row - 1, col) ||\n      dfs(grid, suffix, row, col + 1) ||\n      dfs(grid, suffix, row, col - 1);\n   grid[row][col] = char;\n   return result;\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    [
                        ["e", "y", "h", "i", "j"],
                        ["q", "x", "e", "r", "p"],
                        ["r", "o", "l", "l", "n"],
                        ["p", "r", "x", "o", "h"],
                        ["a", "a", "m", "c", "m"]
                    ],
                    "hello"
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    [
                        ["e", "y", "h", "i", "j"],
                        ["q", "x", "e", "r", "p"],
                        ["r", "o", "l", "l", "n"],
                        ["p", "r", "x", "o", "h"],
                        ["a", "a", "m", "c", "m"]
                    ],
                    "proxy"
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    [
                        ["e", "y", "h", "i", "j"],
                        ["q", "x", "e", "r", "p"],
                        ["r", "o", "l", "l", "n"],
                        ["p", "r", "x", "o", "h"],
                        ["a", "a", "m", "c", "m"]
                    ],
                    "rolling"
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    [
                        ["e", "y", "h", "i", "j"],
                        ["q", "x", "e", "r", "p"],
                        ["r", "o", "l", "l", "n"],
                        ["p", "r", "x", "o", "h"],
                        ["a", "a", "m", "z", "m"]
                    ],
                    "zoo"
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    [
                        ["q", "w", "h", "i", "j"],
                        ["q", "e", "r", "o", "p"],
                        ["h", "y", "t", "x", "z"],
                        ["k", "o", "m", "o", "p"]
                    ],
                    "qwerty"
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    [
                        ["f", "d", "i", "e", "l", "u", "j", "t", "q", "v", "o", "p"],
                        ["o", "p", "b", "e", "m", "w", "m", "l", "h", "j", "s", "v"],
                        ["g", "b", "s", "m", "i", "w", "w", "h", "l", "m", "l", "n"],
                        ["a", "l", "s", "k", "p", "c", "t", "u", "v", "b", "c", "m"],
                        ["m", "t", "c", "k", "e", "n", "r", "b", "a", "z", "l", "c"],
                        ["q", "m", "a", "p", "a", "p", "i", "i", "u", "t", "z", "z"],
                        ["d", "u", "z", "o", "e", "r", "a", "t", "t", "c", "q", "k"],
                        ["f", "u", "z", "g", "c", "i", "k", "v", "o", "f", "s", "w"],
                        ["p", "h", "u", "i", "k", "c", "v", "v", "h", "q", "v", "i"],
                        ["l", "q", "w", "f", "y", "g", "w", "f", "a", "u", "x", "q"]
                    ],
                    "paprika"
                ],
                "test_expected": true,
                "code_output": null,
                "passed_test": false
            },
            "Test_7": {
                "test_input": [
                    [
                        ["s", "s", "s", "s", "s", "s", "s", "s", "s", "s", "s"],
                        ["s", "s", "s", "s", "s", "s", "s", "s", "s", "s", "s"],
                        ["s", "s", "s", "s", "s", "s", "s", "s", "s", "s", "s"],
                        ["s", "s", "s", "s", "s", "s", "s", "s", "s", "s", "s"],
                        ["s", "s", "s", "s", "s", "s", "s", "s", "s", "s", "s"],
                        ["s", "s", "s", "s", "s", "s", "s", "s", "s", "s", "s"],
                        ["s", "s", "s", "s", "s", "s", "s", "s", "s", "s", "s"],
                        ["s", "s", "s", "s", "s", "s", "s", "s", "s", "x", "x"],
                        ["s", "s", "s", "s", "s", "s", "s", "s", "s", "x", "h"]
                    ],
                    "sssssssh"
                ],
                "test_expected": false,
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "tokenReplace": {
        "refName": "tokenReplace",
        "refNumber": 82,
        "category": "String",
        "difficulty": "Easy",
        "title": "Token Replace",
        "tags": ["Easy", "String"],
        "description": "<p>Write a function, tokenReplace, that takes in an object of tokens and a string. The function should return a new string where tokens are replaced.</p><p>Tokens are enclosed in a pair of '$'. You can assume that the input string is properly formatted. Tokens should be replaced from left to right in the string (see test_05).</p>",
        "examples": {
            "example1": {
                "input": "s = 'Walk the $ANIMAL$ in the $LOCATION$!'\ntokens = {   '$LOCATION$': 'park',   '$ANIMAL$': 'dog', };",
                "output": "'Walk the dog in the park!'"
            },
            "example2": {
                "input": "s = 'the $ADJECTIVE$ fox $VERB$ $ADJECTIVE$ly $DIRECTION$ward'\ntokens = {   '$ADJECTIVE$': 'quick',   '$VERB$': 'hopped',   '$DIRECTION$': 'North' }",
                "output": "'the quick fox hopped quickly Northward'"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function tokenReplace(s, tokens) {\n   // Write your solution...\n   return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of string\n// Time: O(n)\n// Space: O(n)\nfunction tokenReplace(s, tokens) {\n   let output = [];\n   let i = 0;\n   let j = 1;\n   while (i < s.length) {\n      if (s[i] !== '$') {\n         output.push(s[i]);\n         i += 1;\n         j = i + 1;\n      } else if (s[j] !== '$') {\n         j += 1;\n      } else {\n         const key = s.slice(i, j + 1);\n         output.push(tokens[key]);\n         i = j + 1;\n         j = i + 1;\n      }\n   }\n   return output.join('');\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    "Walk the $ANIMAL$ in the $LOCATION$!",
                    {
                        "$LOCATION$": "park",
                        "$ANIMAL$": "dog"
                    }
                ],
                "test_expected": "Walk the dog in the park!",
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    "the $ADJECTIVE$ fox $VERB$ $ADJECTIVE$ly $DIRECTION$ward",
                    {
                        "$ADJECTIVE$": "quick",
                        "$VERB$": "hopped",
                        "$DIRECTION$": "North"
                    }
                ],
                "test_expected": "the quick fox hopped quickly Northward",
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    "his greeting is always $greeting$.",
                    {
                        "$greeting$": "hey programmer"
                    }
                ],
                "test_expected": "his greeting is always hey programmer.",
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    "$A$$B$$C$, oh my.",
                    {
                        "$A$": "lions",
                        "$B$": "tigers",
                        "$C$": "bears"
                    }
                ],
                "test_expected": "lionstigersbears, oh my.",
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    "$B$",
                    {
                        "$A$": "lions",
                        "$B$": "tigers",
                        "$C$": "bears"
                    }
                ],
                "test_expected": "tigers",
                "code_output": null,
                "passed_test": false
            },
            "Test_6": {
                "test_input": [
                    "$first$second$third$",
                    {
                        "$second$": "beta",
                        "$first$": "alpha",
                        "$third$": "gamma"
                    }
                ],
                "test_expected": "alphasecondgamma",
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    },
    "tokenTransform": {
        "refName": "tokenTransform",
        "refNumber": 83,
        "category": "String",
        "difficulty": "Medium",
        "title": "Token Transform",
        "tags": ["Medium", "String"],
        "description": "<p>Write a function, tokenTransform, that takes in an object of tokens and a string. In the object, the replacement values for a token may reference other tokens. The function should return a new string where tokens are replaced with their fully evaluated string values.</p><p>Tokens are enclosed in a pair of '$'.</p><p>You may assume that their are no circular token dependencies.</p>",
        "examples": {
            "example1": {
                "input": "s = 'Walk the $ANIMAL$ in the $LOCATION$!'\ntokens = {   '$LOCATION$': '$ANIMAL$ park',   '$ANIMAL$': 'dog', };",
                "output": "'Walk the dog in the dog park!'"
            },
            "example2": {
                "input": "s = 'the $ADJECTIVE_1$ fox $ADVERBS$ $VERB$ward'\ntokens = {   '$ADJECTIVE_1$': 'quick',   '$ADJECTIVE_2$': 'eager',   '$ADVERBS$': '$ADJECTIVE_1$ly and $ADJECTIVE_2$ly',   '$VERB$': 'hopped $DIRECTION$',   '$DIRECTION$': 'North', }",
                "output": "'the quick fox quickly and eagerly hopped Northward'"
            }
        },
        "hints": {
            "hint_1": "...",
            "hint_2": "...",
            "hint_3": "...",
            "Optimal_Space__Time_Complexity": "..."
        },
        "startedCode": {
            "javaScript": "function tokenTransform(s, tokens) {\n   // Write your solution...\n   return true;\n}"
        },
        "solutionCode": {
            "javaScript": [
                "// n = length of longest string of value\n// m = # of unique tokens\n// Time: ~O(n^m)\n// Space: ~O(n^m)\nfunction tokenTransform (s, tokens) {\n   let output = [];\n   let i = 0;\n   let j = 1;\n   while (i < s.length) {\n      if (s[i] !== '$') {\n         output.push(s[i]);\n         i += 1;\n         j = i + 1;\n      } else if (s[j] !== '$') {\n         j += 1;\n      } else {\n         const key = s.slice(i, j + 1);\n         const value = tokens[key];\n         const evaluatedValue = tokenTransform(value, tokens);\n         tokens[key] = evaluatedValue;\n         output.push(evaluatedValue);\n         i = j + 1;\n         j = i + 1;\n      }\n   }\n   return output.join('');\n};"
            ]
        },
        "submittedCode": {
            "javaScript": ""
        },
        "testCases": {
            "Test_1": {
                "test_input": [
                    "Walk the $ANIMAL$ in the $LOCATION$!",
                    {
                        "$LOCATION$": "$ANIMAL$ park",
                        "$ANIMAL$": "dog"
                    }
                ],
                "test_expected": "Walk the dog in the dog park!",
                "code_output": null,
                "passed_test": false
            },
            "Test_2": {
                "test_input": [
                    "the $ADJECTIVE_1$ fox $ADVERBS$ $VERB$ward",
                    {
                        "$ADJECTIVE_1$": "quick",
                        "$ADJECTIVE_2$": "eager",
                        "$ADVERBS$": "$ADJECTIVE_1$ly and $ADJECTIVE_2$ly",
                        "$VERB$": "hopped $DIRECTION$",
                        "$DIRECTION$": "North"
                    }
                ],
                "test_expected": "the quick fox quickly and eagerly hopped Northward",
                "code_output": null,
                "passed_test": false
            },
            "Test_3": {
                "test_input": [
                    "What a $A$ here!",
                    {
                        "$B$": "epicly $C$",
                        "$A$": "pretty $B$ problem $D$",
                        "$D$": "we have",
                        "$C$": "clever"
                    }
                ],
                "test_expected": "What a pretty epicly clever problem we have here!",
                "code_output": null,
                "passed_test": false
            },
            "Test_4": {
                "test_input": [
                    "$1$ $1$ $1$ $1$ $1$ $1$ $4$ $4$",
                    {
                        "$1$": "a$2$",
                        "$2$": "b$3$",
                        "$3$": "c$4$",
                        "$4$": "d$5$",
                        "$5$": "e$6$",
                        "$6$": "f!"
                    }
                ],
                "test_expected": "abcdef! abcdef! abcdef! abcdef! abcdef! abcdef! def! def!",
                "code_output": null,
                "passed_test": false
            },
            "Test_5": {
                "test_input": [
                    "z$0$z$0$z$0$z$0$z$0$z$0$z",
                    {
                        "$0$": "$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$$1$",
                        "$1$": "$2$$2$$2$$2$$2$$2$$2$$2$$2$",
                        "$2$": "$3$$3$$3$$3$$3$$3$$3$",
                        "$3$": "$4$$4$$4$$4$$4$$4$",
                        "$4$": "$5$$5$$5$$5$$5$",
                        "$5$": "$6$$6$$6$$6$",
                        "$6$": "$7$$7$$7$",
                        "$7$": "$8$$8$",
                        "$8$": ""
                    }
                ],
                "test_expected": "zzzzzzz",
                "code_output": null,
                "passed_test": false
            }
        },
        "platform": "structy"
    }
}
